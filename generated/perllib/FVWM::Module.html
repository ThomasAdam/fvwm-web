<html>
<head>
<title>FVWM Perl Library - FVWM::Module</title>
<style><!--
# All these may be commented out
#H1, H2 { margin-left: -0; }
#BLACKQUOTE { margin-left: +48; }
#P { margin-left: +24; }
B { color: #ffffb0; }
I { color: #b0ffff; }
--></style>
</head>
<body BACKGROUND="../../black-stone1.jpg"
	bgcolor="#000000" text="#ffffff"
	link="#a0ffa0" vlink="#c8eec8" alink="#44ff44">
<center>
<h1><font color="pink">FVWM Perl Library</font></h1>
</center>

<H1>FVWM::Module</H1>
Section: FVWM Perl library (3)<BR>Version: FVWM 2.5.4 (from cvs)<BR>Source: <a href="ftp://ftp.fvwm.org/pub/fvwm/devel/sources/perllib/FVWM/Module.pm">FVWM/Module.pm</a><br>
<A HREF="#index">This page contents</A>
 - <a href="./">Return to main index</A><HR>


<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

<FONT>FVWM:</FONT>:Module - the base class representing <FONT>FVWM</FONT> module
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<A NAME="ixAAC"></A>
<blockquote><pre>  use lib `fvwm-perllib dir`;
  use FVWM::Module;

  my $module = new FVWM::Module(Mask =&gt; M_FOCUS_CHANGE);

  $module-&gt;send(&quot;Beep&quot;);

  # auto-raise all windows
  sub autoRaise { $_[0]-&gt;send(&quot;Raise&quot;, $_[1]-&gt;_win_id) };
  $module-&gt;addHandler(M_FOCUS_CHANGE, \&amp;autoRaise);

  $module-&gt;eventLoop;</pre></blockquote>
<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<A NAME="ixAAD"></A>
An <FONT>FVWM</FONT> module is a separate program that communicates with the main <I><a href="../manpages/fvwm.html">fvwm</a></I>
process, receives a module configuration and events and sends commands back.
This class <B></B><B>FVWM::Module</B> makes it easy to create <FONT>FVWM</FONT> modules in Perl.
<P>

If you are interested in all module protocol details that this class tries
to make invisible, visit the web page <I><A HREF="http://fvwm.org/modules.html">http://fvwm.org/modules.html</A></I>.
You will need an information about packet arguments anyway to be able to
write complex modules. This is however not obligatory for simple modules
that only send commands back when something happens.
<P>

A tipical <FONT>FVWM</FONT> module has an initialization part including setting event
handlers using <B>addHandler</B> methods and entering an event loop using
<B>eventLoop</B> method. Most of the work is done in the event handlers although
a module may define other execution ways, for example using <TT>`$SIG{ALRM}'</TT>.
<P>

The following methods are available:
<P>

<B>new</B>,
<B>version</B>,
<B>versionInfo</B>,
<B>argv</B>,
<B>send</B>,
<B>sendReady</B>,
<B>sendUnlock</B>,
<B>terminate</B>,
<B>eventLoop</B>,
<B>resetHandlers</B>,
<B>addHandler</B>,
<B>deleteHandler</B>,
<B>addDefaultErrorHandler</B>,
<B>debug</B>
<P>

The following methods are a bit less useful, since they are called from
other methods above:
<P>

<B>internalDie</B>,
<B>name</B>,
<B>mask</B>,
<B>syncMask</B>,
<B>disconnect</B>,
<B>getHandlerCategory</B>,
<B>readPacket</B>,
<B>invokeHandler</B>,
<B>processPacket</B>,
<B>readConfigInfo</B>
<P>

These methods deal with a received packet (event):
<P>

<B>isEventExtended</B>
<P>

These methods deal with configuration directories:
<P>

<B>userDataDir</B>,
<B>siteDataDir</B>,
<B>searchDirs</B>
<A NAME="lbAE">&nbsp;</A>
<H2>METHODS</H2>

<A NAME="ixAAE"></A>

<BR>




<DL COMPACT>
<DT><B>new</B> <I>param-hash</I><DD>

<A NAME="ixAAF"></A>
Creates a module object. Only one module instance may be created in the
program, since this object gets exclusive rights on communication with <I><a href="../manpages/fvwm.html">fvwm</a></I>.


<P>


The following parameters may be given in the constractor:


<P>


<blockquote><pre>    Name          - used in module configuration and debugging
    Mask          - events a module is interested to receive
    XMask         - the same for extended events
    SyncMask      - events to lock on
    SyncXMask     - the same for extended events
    EnableAlias   - a module accepts an alias in command line
    EnableOptions - a module accepts options in command line
    Debug         - if set to 1, print sent and received data
    NoConfigInfo  - don't read module configuration on startup</pre></blockquote>
Example:


<P>


<blockquote><pre>    my $module = new FVWM::Module(
        Name =&gt; &quot;FvwmPerlBasedWindowRearranger&quot;,
        Mask =&gt; M_CONFIGURE_WINDOW | M_END_WINDOWLIST,
        EnableOptions =&gt; { &quot;animate&quot; =&gt; \$a, &quot;cascade&quot; =&gt; \$c },
        Debug =&gt; 1,
    );</pre></blockquote>
Event types needed for the 4 mask parameters are defined in <B></B><B><a href="./FVWM::Constants.html">FVWM::Constants</a></B>.

<BR>




<DT><B>version</B><DD>

<A NAME="ixAAG"></A>
Returns <FONT>FVWM</FONT> version string <I>x.y.z</I>.

<BR>




<DT><B>versionInfo</B><DD>

<A NAME="ixAAH"></A>
Returns <FONT>FVWM</FONT> version info string, like `` (from cvs)'' or `` (snap-YYYYMMDD)''.
This string is usually empty for the final version.

<BR>




<DT><B>argv</B><DD>

<A NAME="ixAAI"></A>
Returns remaining module arguments (array ref) passed in the command line.
Arguments that are used for <I><a href="../manpages/fvwm.html">fvwm</a></I>-to-module communication are not included.
Arguments that are automatically parsed using <I>EnableAlias</I> and/or
<I>EnableOptions</I> specified in the constructor are not included.

<BR>




<DT><B>send</B> <I>command</I> [<I>window-id</I>]<DD>

<A NAME="ixAAJ"></A>
Sends <I>command</I> back for execution. If the <I>window-id</I> is specified this
command will be executed in this window context.

<BR>




<DT><B>eventLoop</B><DD>

<A NAME="ixAAK"></A>
The main event loop. A module should define some event handlers using
<B>addHandler</B> before entering the event loop. When the event happens all
event handlers registered on this event are called, then a module returns
to the event loop awaiting for new events forever.


<P>


This method may be finished when one of the following happens. 1) Explicit
<B>terminate</B> is called in one of the event handlers. 2) Signal handler
(system signals are independent from this event loop) decides to <I>die</I>.
This is usually catched and a proper shutdown is done. 3) An event handler
<I>die</I>d, in this case the module aborts, this is done on purpose to
encourage programmers to fix bugs. 4) Communication with <I><a href="../manpages/fvwm.html">fvwm</a></I> closed, for
example <B>KillModule</B> called or the main <I><a href="../manpages/fvwm.html">fvwm</a></I> process exited.


<P>


In all these cases (except for the third one) <I></I><FONT><I>ON_EXIT</I></FONT><I></I> event handlers are
called if defined and then <B>disconnect</B> is called. So no communication is
available after this method is finished. If you need a communication before
the module exits, define an <I></I><FONT><I>ON_EXIT</I></FONT><I></I> event handler.

<BR>




<DT><B>sendReady</B><DD>

<A NAME="ixAAL"></A>
This is automatically called (if needed) when a module enters <B>eventLoop</B>,
but sometimes you may want to tell <I><a href="../manpages/fvwm.html">fvwm</a></I> that the module is fully ready
earlier. This only makes sence if the module was run using
<B>ModuleSynchronous</B> command, in this case <I><a href="../manpages/fvwm.html">fvwm</a></I> gets locked until the module
sends the ``ready'' notification.

<BR>




<DT><B>sendUnlock</B><DD>

<A NAME="ixAAM"></A>
When an event was configured to be sent to a module synchronously using
<I>SyncMask</I> and <I>SyncXMask</I>, <I><a href="../manpages/fvwm.html">fvwm</a></I> gets locked until the module sends
the ``unlock'' notification. This is automatically sent (if needed) when a
handler is finished, but sometimes a handler should release <I><a href="../manpages/fvwm.html">fvwm</a></I> earlier.

<BR>




<DT><B>terminate</B> [<I>continue</I>]<DD>

<A NAME="ixAAN"></A>
This method is used for 2 purposed, usually in event handlers. To terminate
the entire event loop and to terminate only an execution of the current
handler if <I>continue</I> is set.

<BR>




<DT><B>resetHandlers</B><DD>

<A NAME="ixAAO"></A>
This deletes all event handlers without exception.

<BR>




<DT><B>addHandler</B> <I>mask code</I><DD>

<A NAME="ixAAP"></A>
Defines a handler (that is a <I>code</I> subroutine) for the given <I>mask</I> event
(or several events). Usually the event type is one of the <FONT>FVWM</FONT> <I>M_*</I> or
<I>MX_*</I> constants (see <B></B><B><a href="./FVWM::Constants.html">FVWM::Constants</a></B>), but it may also be <I></I><FONT><I>ON_EXIT</I></FONT><I></I>,
this special event is called just before the event loop is terminated.


<P>


The <I>mask</I> may include several events in the same category (the event types
are or-ed). In this case the handler will be called for every matching event.
Currently there are 3 categories: regular events (M_*), extended events (MX_*)
and special events (<FONT>ON_EXIT</FONT>). These 3 categories of events can't be mixed,
primary because of technical reasons.


<P>


The handler subroutine is called with these parameters:


<P>


<blockquote><pre>    ($self, $event)</pre></blockquote>
where <TT>`$self'</TT> is a module object, <TT>`$event'</TT> is <B></B><B><a href="./FVWM::Event.html">FVWM::Event</a></B> object.


<P>


If the <I>mask</I> includes more than one event type, use <TT>`$event-&gt;type'</TT>
to dispatch event types if needed.


<P>


The handler may call <TT>`$self-&gt;terminate'</TT> to terminate the event loop
completely or <TT>`$self-&gt;terminate(&quot;continue&quot;)'</TT> to terminate the current
event handler only. The second form is useful when the handler subroutine
calls other subroutines that need to terminate the primary one.


<P>


If several event handlers are added for the same event type, they are
executed in the added order. To forbid the further propagation of the
same event, an event handler may call <TT>`$event-&gt;propagationAllowed(0)'</TT>.


<P>


The return value from <B>addHandler</B> is an identifier the only purpose of
which is to be passed to <B>deleteHandler</B> in case the newly defined handler
should be deleted at some point.

<BR>




<DT><B>deleteHandler</B> <I>id</I><DD>

<A NAME="ixAAQ"></A>
Removes the handler specified by <I>id</I>. The return value is 1 if the handler
is found and deleted, 0 otherwise.

<BR>




<DT><B>addDefaultErrorHandler</B><DD>

<A NAME="ixAAR"></A>
This adds the default handler for <I>M_ERROR</I> event. This class simply prints
an error message to the standard error stream, but subclasses may define
another default handler by overwriting this method.

<BR>




<DT><B>debug</B> <I>msg</I> [<I>level</I>]<DD>

<A NAME="ixAAS"></A>
Prints <I>msg</I> to the standard error stream if <I>level</I> is greater or equal to
the module debug level defined using <I>Debug</I> in the constructor. The default
<I>level</I> for this method is 0, the default module level is 0 as well, so
just calling this method with only one parameter normally results in printing
the message. Subclasses may overwrite this method and, for example, show
all debugging messages in a separate window.


<P>


This method is automatically called (with <I>level</I> 1) to dump all incoming
and outgoing communication data in <B>send</B> and <B>processPacket</B>. Apparently
this data is only seen if <I>Debug</I> is set to something positive.

<BR>




<DT><B>internalDie</B> <I>msg</I><DD>

<A NAME="ixAAT"></A>
This may be used to end the module with the corresponding <I>msg</I>.
For a clean module exit use <B>debug</B> and <B>terminate</B> instead.

<BR>




<DT><B>name</B> [<I>name</I>]<DD>

<A NAME="ixAAU"></A>
Sets or returns the module name. Called automatically from the constructor.

<BR>




<DT><B>mask</B> [<I>mask</I>]<DD>

<A NAME="ixAAV"></A>
Sets or returns the module mask. Called automatically from the constructor.
This method should be called twice for regular and extended packet types.
If <I>M_EXTENDED_MSG</I> is given as a parameter the method returns extended
mask, all other mask parameters results in setting the mask.


<P>


The module only receives the packets matching these 2 module masks (regular
and extended).

<BR>




<DT><B>syncMask</B> [<I>mask</I>]<DD>

<A NAME="ixAAW"></A>
The same as <B>mask</B>, but sets/returns the synchronization mask of the
module.


<P>


The module is synchronized with <I><a href="../manpages/fvwm.html">fvwm</a></I> on all packets matching these 2
module synchronization masks (regular and extended).

<BR>




<DT><B>disconnect</B><DD>

<A NAME="ixAAX"></A>
This method invokes <I></I><FONT><I>ON_EXIT</I></FONT><I></I> handlers if any and closes communication.
It is called automatically from <B>eventLoop</B> before finishing.
It is safe to call this method more than once.


<P>


This method may be called from signal handlers before <I>exit</I>ing for the
proper shutdown.

<BR>




<DT><B>getHandlerCategory</B> <I>type</I><DD>

<A NAME="ixAAY"></A>
Returns one of 3 string ids depending on the event handler <I>type</I> that has
the same meaning as the corresponding packet type (``regular'' or ``extended'')
with an addition of ``special'' category for <I></I><FONT><I>ON_EXIT</I></FONT><I></I> handlers.

<BR>




<DT><B>readPacket</B><DD>

<A NAME="ixAAZ"></A>
This is a blocking method that waits until there is a packet on the
communication end from <I><a href="../manpages/fvwm.html">fvwm</a></I>. Then it returns a list of 2 values,
packet type and packet data (packed).

<BR>




<DT><B>invokeHandler</B> <I>event</I><DD>

<A NAME="ixABA"></A>
Dispatches the apropos event handlers with the event data.
This method is called automatically, so you usually should not worry about it.

<BR>




<DT><B>processPacket</B> [<I>data type</I>]<DD>

<A NAME="ixABB"></A>
This method constructs the event object from the packet data and calls
<B>invokeHandler</B> with it. Prints debug info if requested. Finally calls
<B>sendUnlock</B> if needed.


<P>


You should not really worry about this method, it is called automatically
from the event loop.

<BR>




<DT><B>readConfigInfo</B><DD>

<A NAME="ixABC"></A>
Not implemented yet.

<BR>




<DT><B>isEventExtended</B> <I>type</I><DD>

<A NAME="ixABD"></A>
For technical reasons there are 2 categories of <FONT>FVWM</FONT> events, regular and
extended. This is done to enable more events. With introdution of the
extended event types (with the highest bit set) it is now possible to have
31+31=62 different event types rather than 32. This is a good point, the bad
point is that only event types of the same category may be masked (or-ed)
together. This method returns 1 or 0 depending on whether the event <I>type</I>
is extended or not.

<BR>




<DT><B>userDataDir</B><DD>

<A NAME="ixABE"></A>
Returns the user data directory, usually ~/.fvwm or set by <TT>$FVWM_USERDIR</TT>.

<BR>




<DT><B>siteDataDir</B><DD>

<A NAME="ixABF"></A>
Returns the system-wide data directory, the one configured when <FONT>FVWM</FONT> is
installed. It is also returned by `fvwm-config --fvwm-datadir`.

<BR>




<DT><B>searchDirs</B><DD>

<A NAME="ixABG"></A>
It is a good practice for a module to search for the given configuration
in one of 2 data directories, the user one and the system-wide. This method
returns a list of both directories in that order.
</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>BUGS</H2>

<A NAME="ixABH"></A>
Awaiting for your reporting.
<A NAME="lbAG">&nbsp;</A>
<H2>CAVEATS</H2>

<A NAME="ixABI"></A>
In keeping with the <FONT>UNIX</FONT> philosophy, <B></B><B>FVWM::Module</B> does not keep you from
doing stupid things, as that would also keep you from doing clever things.
What this means is that there are several areas with which you can hang your
module or even royally confuse your running <I><a href="../manpages/fvwm.html">fvwm</a></I> process. This is due to
flexibility, not bugs.
<A NAME="lbAH">&nbsp;</A>
<H2>AUTHOR</H2>

<A NAME="ixABJ"></A>
Mikhael Goikhman &lt;<A HREF="mailto:migo@homemail.com">migo@homemail.com</A>&gt;.
<A NAME="lbAI">&nbsp;</A>
<H2>THANKS TO</H2>

<A NAME="ixABK"></A>
Randy J. Ray &lt;<A HREF="mailto:randy@byz.org">randy@byz.org</A>&gt;.
<A NAME="lbAJ">&nbsp;</A>
<H2>SEE ALSO</H2>

<A NAME="ixABL"></A>
For more information, see the <a href="../manpages/fvwm.html">fvwm</a> manpage, the <a href="./FVWM::Module::Gtk.html">FVWM::Module::Gtk</a> manpage and the <a href="./FVWM::Module::Tk.html">FVWM::Module::Tk</a> manpage.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">METHODS</A><DD>
<DT><A HREF="#lbAF">BUGS</A><DD>
<DT><A HREF="#lbAG">CAVEATS</A><DD>
<DT><A HREF="#lbAH">AUTHOR</A><DD>
<DT><A HREF="#lbAI">THANKS TO</A><DD>
<DT><A HREF="#lbAJ">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="./">man2html</A>,
using the manual pages.<BR>
Time: 18:46:58 GMT, September 17, 2002
<hr>
<!-- Automatically generated by perllib2html on 17-Sep-2002 21:46:52 -->
</body>
</html>
