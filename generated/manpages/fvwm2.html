<html>
<head>
<title>FVWM Manpage - fvwm2</title>
</head>
  <body BACKGROUND="../../black-stone1.jpg"
    bgcolor="#000000" text="#ffffff"
    link="#FFFF88" vlink="#EEDDDD" alink="#ff0000">
<center>
<h1><font color="pink">FVWM Manpage - fvwm2</font></h1>
</center>
<pre>

</pre>
	<style><!--
	# All these may be commented out
	#H1, H2 { margin-left: -0; }
	#BLACKQUOTE { margin-left: +48; }
	#P { margin-left: +24; }
	B { color: #FFFFD0; }
	I { color: #D0FFFF; }
	--></style>
    
<HTML><HEAD><TITLE>Manpage of FVWM2</TITLE>
</HEAD><BODY>
<H1>FVWM2</H1>
Section: User Commands  (1)<BR>Updated: 20 May 2001<BR><A HREF="#index">Index</A>
- <A HREF="./">Return to Main Contents</A><HR>


<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

<P>
fvwm2 - F(?) Virtual Window Manager (version 2) for X11
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<P>
<B>fvwm2</B>

[<B>-blackout</B>]

[<B>-clientId</B>

<I>id</I>]

[<B>-cmd</B>

<I>config_command</I>]

[<B>-d</B>

<I>displayname</I>]

[<B>-debug</B>]

[<B>-debug_stack_ring</B>]

[<B>-f</B>

<I>config_file</I>]

[<B>-h</B>]

[<B>-replace</B>]

[<B>-restore</B>

<I>state_file</I>]

[<B>-s</B>]

[<B>-version</B>]

[<B>-visual</B>

<I>visual_class</I>]

[<B>-visualId</B>

<I>id</I>]

<P>
<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<P>
Fvwm is a window manager for X11.  It is designed to minimize
memory consumption, provide a 3D look to window frames, and a
virtual desktop.
<P>
Note that there are several window managers around that have
&quot;fvwm&quot; in their name.  In the past, version 2.x of fvwm was
commonly called fvwm2 to distinguish it from the former version
1.x (fvwm or even fvwm1).  Since version 1.x has been replaced by
version 2.x a long time ago we simply call version 2.x and all
versions to come, fvwm, throughout this document, although the
executable program is named fvwm2.  There is an fvwm offspring
called fvwm95. Although it is very similar to older versions of
fvwm version 2 it is technically a different window manager that
has been developed by different people.  The main goal of fvwm95
was to supply a Windows 95 like look and feel.  Since then fvwm
has been greatly enhanced and only very few features of fvwm95 can
not be imitated by fvwm.  No active development has been going on
for fvwm95 for several years now.  Unfortunately Red Hat (a
popular Linux distributor) has a pre-configured fvwm package based
on fvwm version 2.x that is called fvwm95 too.
<P>
Fvwm provides both a large
<I>virtual desktop</I>

and
<I>multiple disjoint desktops</I>

which can be used separately or together.  The virtual desktop
allows you to pretend that your video screen is really quite
large, and you can scroll around within the desktop.  The multiple
disjoint desktops allow you to pretend that you really have
several screens to work at, but each screen is completely
unrelated to the others.
<P>
Fvwm provides
<I>keyboard accelerators</I>

which allow you to perform most window-manager functions,
including moving and resizing windows, and operating the menus,
using keyboard shortcuts.
<P>
Fvwm has also blurred the distinction between configuration
commands and built-in commands that most window-managers make.
Configuration commands typically set fonts, colors, menu contents,
key and mouse function bindings, while built-in commands typically
do things like raise and lower windows.  Fvwm makes no such
distinction, and allows, to the extent that is practical, anything
to be changed at any time.
<P>
Other noteworthy differences between Fvwm and other X11 window
managers are the introduction of the
<I>SloppyFocus</I>

and per-window focus methods.
<I>SloppyFocus</I>

is focus-follows-mouse, but focus is not removed from windows when
the mouse leaves a window and enters the root window.  When
<I>SloppyFocus</I>

is used as the default focus style, it is nice to make windows in
which you do not typically type into (xmag, xman, xgraph, xclock,
xbiff, etc.).
<I>NeverFocus</I>,

so that your terminal window doesn't lose focus unnecessarily.
<P>
<A NAME="lbAE">&nbsp;</A>
<H2>OPTIONS</H2>

<P>
These are the command line options that are recognized by fvwm:
<DL COMPACT>
<DT><B>-blackout</B>

<DD>
This option is provided for backward compatibility only.  Blacking
out the screen during startup is not necessary anymore.
<DT><B>-clientId </B><I>id</I>

<DD>
This option is used when fvwm is started by a session
manager. Should not be used by a user.
<P>
<DT><B>-cmd </B><I>config_command</I>

<DD>
Causes fvwm to use
<I>config_command</I>

instead of
'Read

<I>.fvwm2rc'</I>

as its initialization command.  (Note that up to 10
<B>-f</B> and <B>-cmd</B>

parameters can be given, and they are executed in the order
specified.)
<DT><B>-d </B><I>displayname</I>

<DD>
Manage the display called
<I>displayname</I>

instead of the name obtained from the environment variable
<I>$DISPLAY</I>.

<DT><B>-debug</B>

<DD>
Puts X transactions in synchronous mode, which dramatically slows
things down, but guarantees that fvwm's internal error messages
are correct. Also causes fvwm to output debug messages while
running.
<DT><B>-debug_stack_ring</B>

<DD>
Enables stack ring debugging.  This option is only intended for
internal debugging and should only be used by developers.
<DT><B>-f </B><I>config_file</I>

<DD>
Causes fvwm to read
<I>config_file</I>

instead of
<I>.fvwm2rc</I>

as its initialization file.  This is equivalent to
-cmd 'Read

<I>config_file'.</I>

<DT><B>-h</B>

<DD>
A short usage description is printed.
<DT><B>-replace</B>

<DD>
Try to take over from a previously running wm.  This does not work
unless the other wm is
<FONT SIZE="-1">ICCCM</FONT>
2.0 compliant.
<DT><B>-restore </B><I>state_file</I>

<DD>
This option is used when fvwm is started by a session manager.
Should not be used by a user.
<DT><B>-s</B>

<DD>
On a multi-screen display, run fvwm only on the screen named in
the
<I>$DISPLAY</I>

environment variable or provided through the
<B>-d</B>

option. Normally, fvwm attempts to start up on all screens of a
multi-screen display.
<DT><B>-version</B>

<DD>
Prints the version of fvwm to
<I>stderr</I>.

Also prints an information about the compiled in support for
readline, rplay, stroke, xpm, gnome hints, session management and
multibyte characters.
<DT><B>-visual </B><I>visual_class</I>

<DD>
Causes fvwm to use
<I>visual_class</I>

for the window borders and menus.
<I>visual_class</I>

can be &quot;StaticGray&quot;, &quot;GrayScale&quot;, &quot;StaticColor&quot;, &quot;PseudoColor&quot;,
&quot;TrueColor&quot; or &quot;DirectColor&quot;.
<DT><B>-visualId </B><I>id</I>

<DD>
Causes fvwm to use
<I>id</I>

as the visualId for the window borders and menus.
<I>id</I>

can be specified as N for decimal or 0xN for hexadecimal. See man
page of xdpyinfo for a list of supported visuals.
<P>
<P>
</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>ANATOMY OF A WINDOW</H2>

<P>
Fvwm puts a decorative border around most windows.  This border
consists of a bar on each side and a small L-shaped section on
each corner.  There is an additional top bar called the title-bar
which is used to display the name of the window.  In addition,
there are up to 10 title-bar buttons.  The top, side, and bottom
bars are collectively known as the side-bars.  The corner pieces
are called the frame.
<P>
Unless the standard defaults files are modified, pressing mouse
button 1 in the title or side-bars begins a move operation on the
window.  Pressing button 1 in the corner frame pieces begins a
resize operation.  Pressing button 2 anywhere in the border brings
up an extensive list of window operations.
<P>
Up to ten title-bar buttons may exist.  Their use is completely
user definable.  The default configuration has a title-bar button
on each side of the title-bar.  The one on the left is used to
bring up a list of window options, regardless of which mouse
button is used.  The one on the right is used to iconify the
window.  The number of title-bar buttons used depends on which
ones have mouse actions bound to them.  See the section on the
<B>Mouse</B>

command below.
<P>
<P>
<A NAME="lbAG">&nbsp;</A>
<H2>THE VIRTUAL DESKTOP</H2>

<P>
Fvwm provides multiple virtual desktops for users who wish to use
them.  The screen is a viewport onto a
<I>desktop</I>

which may be larger than the screen.  Several distinct desktops
can be accessed (concept: one desktop for each project, or one
desktop for each application, when view applications are
distinct).  Since each desktop can be larger than the physical
screen, divided into m by n
<I>pages</I>

which are each the size of the physical screen, windows which are
larger than the screen or large groups of related windows can
easily be viewed.
<P>
The (m by n) size (i.e. number of pages) of the virtual desktops
can be changed any time, by using the
<B>DeskTopSize</B>

built-in command.  All virtual desktops must be (are) the same
size.  The total number of distinct desktops does not need to be
specified, but is limited to approximately 4 billion total. All
windows on a range of desktops can be viewed in the
<B>FvwmPager</B>,

a miniature view of the desktops.  The pager is an accessory
program, called a module, which is not essential for the window
manager to operate.  Windows may also be listed, along with their
geometries, in a window list, accessible as a pop-up menu, or as a
separate window, called the
<B>FvwmWinList</B>

(another module).
<P>
Fvwm keeps the windows on the desktop in a layered stacking order;
a window in a lower layer never obscures a window in a higher
layer. The layer of a window can be changed by using the
<B>Layer</B>

command.  The concept of layers is a generalization of the
<I>StaysOnTop</I>

flag of older fvwm versions. The
<I>StaysOnTop</I> and <I>StaysPut</I>

<B>Style</B>

options are now implemented by putting the windows in suitable
layers and the previously missing
<I>StaysOnBottom </I><B>Style</B>

option has been added.
<P>
<B>Sticky</B>

windows are windows which transcend the virtual desktop by
&quot;Sticking to the screen's glass&quot;.  They always stay put on the
screen. This is convenient for things like clocks and xbiff's, so
you only need to run one such gadget and it always stays with you.
Icons can also be made to stick to the glass, if desired.
<P>
Window geometries are specified relative to the current viewport.
That is:


<P>


<blockquote><PRE>xterm -geometry +0+0</PRE></blockquote>
<P>



creates a window in the upper-left hand corner of the visible
portion of the screen.  It is permissible to specify geometries
which place windows on the virtual desktop, but off the screen.
For example, if the visible screen is 1000 by 1000 pixels, and the
desktop size is 3x3, and the current viewport is at the upper left
hand corner of the desktop, invoking:


<P>


<blockquote><PRE>xterm -geometry +1000+1000</PRE></blockquote>
<P>



places a window just off of the lower right hand corner of the
screen.  It can be found by moving the mouse to the lower right
hand corner of the screen and waiting for it to scroll into view.
A geometry specified as something like:


<P>


<blockquote><PRE>xterm -geometry -5-5</PRE></blockquote>
<P>



places the window's lower right hand corner 5 pixels from the
lower right corner of the visible portion of the screen.  Not all
applications support window geometries with negative offsets.
Some applications place the window's upper right hand corner 5
pixels above and to the left of the upper left hand corner of the
screen; others may do just plain bizarre things.
<P>
There are several ways to cause a window to map onto a desktop or
page other than the currently active one. The geometry technique
mentioned above (specifying x,y coordinates larger than the
physical screen size), however, suffers from the limitation of
being interpreted relative to the current viewport: the window may
not consistently appear on a specific page, unless you always
invoke the application from the same page.
<P>
A better way to place windows on a different page, screen or desk
from the currently mapped viewport is to use the
<I>StartsOnPage</I>or<I>StartsOnScreen</I>

style specification (the successors to the older
<I>StartsOnDesk</I>

style) in the
<I>.fvwm2rc</I>

configuration file.  The placement is consistent: it does not
depend on your current location on the virtual desktop.
<P>
Some applications that understand standard Xt command line
arguments and X resources, like xterm and xfontsel, allow the user
to specify the start-up desk or page on the command line:


<P>


<blockquote><PRE>xterm -xrm &quot;*Desk:1&quot;</PRE></blockquote>
<P>



starts an xterm on desk number 1;


<P>


<blockquote><PRE>xterm -xrm &quot;*Page:3 2 1&quot;</PRE></blockquote>
<P>



starts an xterm two pages to the right and one down from the upper
left hand page of desk number 3.  Not all applications understand
the use of these options, however.  You could achieve the same
results with the following lines in your
<I>.Xdefaults</I>

file:


<P>


<blockquote><PRE>XTerm*Desk: 1</PRE></blockquote>
<P>



or


<P>


<blockquote><PRE>XTerm*Page: 3 2 1</PRE></blockquote>
<P>



<P>
<P>
<A NAME="lbAH">&nbsp;</A>
<H2>USE ON MULTI-SCREEN DISPLAYS</H2>

<P>
If the
<B>-s</B>

command line argument is not given, fvwm automatically starts up
on every screen on the specified display.  After fvwm starts each
screen is treated independently.  Restarts of fvwm need to be
performed separately on each screen.  The use of


<P>


<blockquote><PRE> EdgeScroll 0 0</PRE></blockquote>
<P>



is strongly recommended for multi-screen displays.  You may need
to quit on each screen to quit from the X session completely.
This is not to be confused with Xinerama support.
<P>
<P>
<A NAME="lbAI">&nbsp;</A>
<H2>XINERAMA SUPPORT</H2>

<P>
Fvwm supports the Xinerama extension of newer X servers which
is similar to multi head support (multiple screens) but allows to
move windows between screens.  If Xinerama support has been
compiled into fvwm, it is used whenever fvwm runs on an X server
that supports and uses multiple screens via Xinerama.  Without
this option, the whole desktop is treated as one big screen.  For
example, menus might pop up right between two screens.  The
<B>EdgeResistance</B>

command allows to specify an explicit resistance value for moving
windows over the screen edge between two Xinerama screens.
Xinerama support can be enabled or disabled on the fly or from the
configuration file with the
<B>Xinerama</B>

command.  Many modules and commands work nicely with Xinerama
displays.
<P>
Everywhere where a geometry in the usual X format can be supplied,
fvwm's Xinerama extension allows to specify a screen in addition
to the geometry (or even the screen alone).  To do this, a '@' is
added to the end of the geometry string followed by either the
screen number or a letter.  A number is taken as the number of the
Xinerama screen to be used (as configured in the X server).  The
letter can be one of 'g' for the global screen (the rectangle that
encloses all Xinerama screens), 'p' for the primary screen (see
below), 'c' for the current screen (the one that currently
contains the pointer).  If the X server does not support Xinerama
or only one screen is used, the screen bit is ignored.
<P>


<P>


<blockquote><PRE>Style * IconBox 64x300-0-0@p</PRE></blockquote>
<P>



<P>
Xinerama support can be configured to use a primary screen.  New
windows and icons are usually placed on this screen - unless fvwm
is told otherwise.  The primary screen is screen 0 by default but
can be changed with the
<B>XineramaPrimaryScreen</B>

command.
<P>
Xinerama support was designed to work out of the box with the same
configurations file that would work on a single screen.  It may
not work too well if the involved screens use different screen
resolutions.  In this situation, windows may get stuck in the
portion of the whole desktop that belongs to neither screen.  If
this happens, the windows or icons can be retrieved with the
command
<P>


<P>


<blockquote><PRE>All MoveToScreen</PRE></blockquote>
<P>



<P>
that can be entered in an FvwmConsole window or with FvwmCommand.
<P>
For multi-screen implementations other than Xinerama, such as
Single Logical Screen, it is possible to simulate a Xinerama
configuration if the total screen seen by FVWM is made up of
equal sized monitors in a rectangular grid.  The commands
<B>XineramaSls</B> and <B>XineramaSlsSize</B>

are used to configure this feature.
<P>
<P>
<A NAME="lbAJ">&nbsp;</A>
<H2>INITIALIZATION</H2>

<P>
During initialization, fvwm searches for a configuration file
which describes key and button bindings, and many other
things. The format of these files is described later.  Fvwm first
searches for configuration files using the command


<P>


<blockquote><PRE><B>Read </B><I>.fvwm2rc</I></PRE></blockquote>
<P>



This looks for
<I>.fvwm2rc</I> in 

<I>$HOME/.fvwm</I> or <I>$FVWM_USERDIR</I>

directories, as described in
<B>Read</B>

below.  If this fails, fvwm also searches for this file in the
<I>$HOME</I>

directory or for
<I>system.fvwm2rc</I>

file in the system place.  If a configuration file is not found,
any mouse button or the
<FONT SIZE="-1">Help</FONT>
or
<FONT SIZE="-1">F1</FONT>
keys on the root window brings up menus and forms that can create
a starting configuration file.
<P>
Fvwm sets two environment variables which are inherited by its
children.  These are
<I>$DISPLAY</I>

which describes the display on which fvwm is running.
<I>$DISPLAY</I>

may be
<I>unix:0.0</I>

or
<I>:0.0</I>,

which doesn't work too well when passed through rsh to another
machine, so
<I>$HOSTDISPLAY</I>

is set to a network-ready description of the display.
<I>$HOSTDISPLAY</I>

always uses the TCP/IP transport protocol (even for a local
connection) so
<I>$DISPLAY</I>

should be used for local connections, as it may use Unix-domain
sockets, which are faster.
<P>
If you want to start some applications or modules with fvwm, you
can simply put


<P>


<blockquote><PRE>Exec app</PRE></blockquote>
<P>



or


<P>


<blockquote><PRE>Module FvwmXxx</PRE></blockquote>
<P>



into your
<I>.fvwm2rc</I>,

but it is not recommended; do this only if you know what you are
doing. It is usually critical to start applications or modules
after
<I>.fvwm2rc</I>

is read, because it contains styles or module configurations which
can affect window appearance and functionality.
<P>
The standard way to start applications or modules on fvwm's start
up is to add them to an initialization function (usually
<B>StartFunction</B> or <B>InitFunction</B>).

This way they are only started after fvwm reads the entire
<I>.fvwm2rc</I>.

<P>
Fvwm has three special functions for initialization:
<B>StartFunction</B>,

which is executed on startups and restarts;
<B>InitFunction</B> and <B>RestartFunction</B>,

which are executed during initialization and restarts
(respectively) just after StartFunction. These functions may be
customized in a user's
<I>.fvwm2rc</I>

file via the
<B>AddToFunc</B>

command (described later) to start up modules, xterms, or whatever
you'd like to have started by fvwm.
<P>
Fvwm has also a special exit function:
<B>ExitFunction</B>,

executed when exiting or restarting before actually quitting.
It could be used to explicitly kill modules, etc.
<P>
If fvwm is run under a session manager, functions
<B>SessionInitFunction</B> and <B>SessionRestartFunction</B>

are executed instead of InitFunction and RestartFunction.
This helps to define the user's
<I>.fvwm2rc</I>

file to be good for both running under a session manager and
without it.  Generally it is a bad idea to start xterms or other
applications in &quot;Session*&quot; functions.  Also someone can decide to
start different modules while running under a session manager or
not.  For the similar purposes
<B>SessionExitFunction</B>

is used instead of ExitFunction.


<P>


<blockquote><PRE>DestroyFunc StartFunction
AddToFunc StartFunction
 + I ModuleSynchronous FvwmTheme
 + I Module FvwmPager * *
 + I Module FvwmButtons

DestroyFunc InitFunction
AddToFunc InitFunction
 + I Module FvwmBanner
 + I Module FvwmTaskBar
 + I xsetroot -solid cyan
 + I Exec xterm
 + I Exec netscape

DestroyFunc RestartFunction
AddToFunc RestartFunction
 + I Module FvwmTaskBar

DestroyFunc SessionInitFunction
AddToFunc SessionInitFunction
 + I Module FvwmBanner

DestroyFunc SessionRestartFunction
AddToFunc SessionRestartFunction
 + I Nop</PRE></blockquote>
<P>



You don't need to define all special functions if some are empty.
<P>
<A NAME="lbAK">&nbsp;</A>
<H2>COMPILATION OPTIONS</H2>

<P>
Fvwm has a number of compile-time options.  If you have trouble
using a certain command or feature, check to see if support for it
was included at compile time.  Optional features are described in
the
<I>config.h</I>

file that is generated during compilation.
<P>
<A NAME="lbAL">&nbsp;</A>
<H2>ICONS</H2>

<P>
The basic fvwm configuration uses monochrome bitmap icons.  If
<B>XPM</B>

extensions are compiled in, then color icons can be used. In order
to use these options you need the XPM package, as described in the
<I>INSTALL.fvwm</I>

file.
<P>
If both the
<B>SHAPE</B> and <B>XPM</B>

options are compiled in you get shaped color icons, which are very
spiffy.
<P>
<A NAME="lbAM">&nbsp;</A>
<H2>MODULES</H2>

<P>
A module is a separate program which runs as a separate Unix
process but transmits commands to fvwm to execute.  Users can
write their own modules to do any weird or bizarre manipulations
without bloating or affecting the integrity of fvwm itself.
<P>
Modules must be spawned by fvwm so that it can set up two pipes
for fvwm and the module to communicate with.  The pipes are
already open for the module when it starts and the file
descriptors for the pipes are provided as command line arguments.
<P>
Modules can be spawned during fvwm at any time during the X
session by use of the
<B>Module</B>

built-in command.  Modules can exist for the duration of the X
session, or can perform a single task and exit.  If the module is
still active when fvwm is told to quit, then fvwm closes the
communication pipes and waits to receive a SIGCHLD from the
module, indicating that it has detected the pipe closure and has
exited.  If modules fail to detect the pipe closure fvwm exits
after approximately 30 seconds anyway.  The number of
simultaneously executing modules is limited by the operating
system's maximum number of simultaneously open files, usually
between 60 and 256.
<P>
Modules simply transmit text commands to the fvwm built-in command
engine.  Text commands are formatted just as in the case of a
mouse binding in the
<I>.fvwm2rc</I>

setup file.  Certain auxiliary information is also transmitted, as
in the sample module
<B>FvwmButtons</B>.

The
<B>FvwmButtons</B>

module is documented in its own man page.
<P>
Please refer to the
<B>MODULE COMMANDS</B>

section for details.
<P>
<A NAME="lbAN">&nbsp;</A>
<H2>ICCCM COMPLIANCE</H2>

<P>
Fvwm attempts to be
<FONT SIZE="-1">ICCCM</FONT>
2.0 compliant.  In addition,
<FONT SIZE="-1">ICCCM</FONT>
states that it should be possible for applications to receive any
keystroke, which is not consistent with the keyboard shortcut
approach used in fvwm and most other window managers.  In
particular you cannot have the same keyboard shortcuts working
with your fvwm and another fvwm running within Xnest (a nested X
server running in a window).  The same problem exists with mouse
bindings.
<P>
The
<FONT SIZE="-1">ICCCM</FONT>
states that windows possessing the property


<P>


<blockquote><PRE>WM_HINTS(WM_HINTS):
    Client accepts input or input focus: False</PRE></blockquote>
<P>



should not be given the keyboard input focus by the window
manager. These windows can take the input focus by themselves,
however.  A number of applications set this property, and yet
expect the window-manager to give them the keyboard focus anyway,
so fvwm provides a window-style,
<I>Lenience</I>, 

which allows fvwm to overlook this
<FONT SIZE="-1">ICCCM</FONT>
rule.  Even with this window-style it is not guaranteed that the
application accepts focus.
<P>
The differences between
<FONT SIZE="-1">ICCCM</FONT>
1.1 and 2.0 include the ability to take over from a running
<FONT SIZE="-1">ICCCM</FONT>
2.0 compliant window manager; thus


<P>


<blockquote><PRE>fvwm2; vi .fvwm2rc; fvwm2 -replace</PRE></blockquote>
<P>



resembles the
<B>Restart</B>

command.  It is not exactly the same, since killing the previously
running wm may terminate your X session, if the wm was started as
the last client in your
<I>.Xclients</I> or <I>.Xsession</I>

file.
<P>
Further additions are support for client-side colormap
installation (see the .SM ICCCM for details) and the urgency hint.
Clients can set this hint in the WM_HINTS property of their window
and expect the window manager to attract the users attention to
the window.  Fvwm has two re-definable functions for this purpose,
&quot;UrgencyFunc&quot; and &quot;UrgencyDoneFunc&quot;, which are executed when the
flag is set/cleared.  Their default definitions are:


<P>


<blockquote><PRE>AddToFunc UrgencyFunc
 + I Iconify off
 + I FlipFocus
 + I Raise
 + I WarpToWindow 5p 5p
AddToFunc UrgencyDoneFunc
 + I Nop</PRE></blockquote>
<P>



<P>
<A NAME="lbAO">&nbsp;</A>
<H2>GNOME COMPLIANCE</H2>

<P>
Fvwm attempts to be
<FONT SIZE="-1">GNOME</FONT>
compliant.  Check
<B><A HREF="http://www.gnome.org">http://www.gnome.org</A></B>

for what that may mean.
<FONT SIZE="-1">GNOME</FONT>
support is a compile time option which is on by default.  To
disable GNOME hints for some or all windows, the
<I>GNOMEIgnoreHints</I>

style can be used.
<P>
<A NAME="lbAP">&nbsp;</A>
<H2>MWM COMPATIBILITY</H2>

<P>
Fvwm provides options to emulate Motif Window Manager (Mwm) as
well as possible.  Please refer to the
<B>Emulate</B>

command as well as to the Mwm specific options of the
<B>Style</B> and <B>MenuStyle</B>

commands for details.
<P>
<A NAME="lbAQ">&nbsp;</A>
<H2>OPEN LOOK and XVIEW COMPATIBILITY</H2>

Fvwm supports all the Open Look decoration hints (except
pushpins). Most (perhaps all) Open Look applications have a
strange notion of keyboard focus handling.  Although a lot of work
went into fvwm to work well with these, you may still encounter
problems. Should you use any such application, please add the
following line to your .fvwm2rc:


<P>


<blockquote><PRE>Style * OLDecor</PRE></blockquote>
<P>



<P>
<A NAME="lbAR">&nbsp;</A>
<H2>M4 PREPROCESSING</H2>

<P>
<P>

M4 pre-processing is handled by a module in fvwm.  To get more
details, try man
<B>FvwmM4</B>.

In short, if you want fvwm to parse your files with m4, then
replace the command
<B>Read</B>

with
<B>FvwmM4</B>

in your
<I>.fvwm2rc</I>

file (if it appears at all), and start fvwm with the command


<P>


<blockquote><PRE>fvwm2 -cmd &quot;FvwmM4 .fvwm2rc&quot;</PRE></blockquote>
<P>



<P>
<A NAME="lbAS">&nbsp;</A>
<H2>CPP PREPROCESSING</H2>

<P>
<P>

Cpp is the C-language pre-processor.  fvwm offers cpp processing
which mirrors the m4 pre-processing.  To find out about it,
re-read the M4 section above, but replace &quot;m4&quot; with &quot;cpp&quot;.
<P>
<A NAME="lbAT">&nbsp;</A>
<H2>AUTO-RAISE</H2>

<P>
<P>

Windows can be automatically raised when it receives focus, or
some number of milliseconds after it receives focus, by using the
auto-raise module,
<B>FvwmAuto</B>.

<P>
<A NAME="lbAU">&nbsp;</A>
<H2>CONFIGURATION FILES</H2>

<P>
The configuration file is used to describe mouse and button
bindings, colors, the virtual display size, and related items.
The initialization configuration file is typically called
<I>.fvwm2rc</I>.

By using the
<B>Read</B>

built-in, it is easy to read in new configuration files as you go.
<P>
Lines beginning with '#' are ignored by fvwm.  Lines starting with

than configuration commands for fvwm itself). Like in shell
scripts embedded newlines in a configuration file line can be
quoted by preceding them with a backslash.  All lines linked in
this fashion are treated as a single line.  The newline itself is
ignored.
<P>
Fvwm makes no distinction between configuration commands and
built-in commands, so anything mentioned in the built-in commands
section can be placed on a line by itself for fvwm to execute as
it reads the configuration file, or it can be placed as an
executable command in a menu or bound to a mouse button or a
keyboard key.  It is left as an exercise for the user to decide
which function make sense for initialization and which ones make
sense for run-time.
<P>
<P>
<A NAME="lbAV">&nbsp;</A>
<H2>SUPPLIED CONFIGURATION</H2>

<P>
A sample configuration file,
<I>.fvwm2rc</I>,

is supplied with the fvwm distribution.  It is well commented and
can be used as a source of examples for fvwm configuration.
<P>
<P>










<P>
<A NAME="lbAW">&nbsp;</A>
<H2>KEYBOARD SHORTCUTS</H2>

<P>
Almost all window manager operations can be performed from the
keyboard so mouse-less operation should be possible.  In addition
to scrolling around the virtual desktop by binding the
<B>Scroll</B>

built-in to appropriate keys,
<B>Popup</B>, <B>Move</B>, <B>Resize</B>, 

and most other built-ins can be bound to keys.  Once a built in
function is started the pointer is moved by using the up, down,
left, and right arrows, and the action is terminated by pressing
return.  Holding down the
<FONT SIZE="-1">Shift</FONT>
key causes the pointer movement to go in larger steps and holding
down the
<FONT SIZE="-1">control</FONT>
key causes the cursor movement to go in smaller steps. Standard
emacs and vi cursor movement controls (
<FONT SIZE="-1">Ctrl-n,</FONT>
<FONT SIZE="-1">Ctrl-p,</FONT>
<FONT SIZE="-1">Ctrl-f,</FONT>
<FONT SIZE="-1">Ctrl-b,</FONT>
and
<FONT SIZE="-1">Ctrl-j,</FONT>
<FONT SIZE="-1">Ctrl-k,</FONT>
<FONT SIZE="-1">Ctrl-h,</FONT>
<FONT SIZE="-1">Ctrl-l</FONT>
) can be used instead of the arrow keys.
<P>
<P>
<A NAME="lbAX">&nbsp;</A>
<H2>SESSION MANAGEMENT</H2>

<P>
Fvwm supports session management according to the X Session
Management Protocol.  It saves and restores window position, size,
stacking order, desk, stickiness, shadedness, maximizedness,
iconifiedness for all windows. Furthermore, some global state is
saved.
<P>
Fvwm doesn't save any information regarding styles, decors,
functions or menus.  If you change any on these resources during a
session (e.g. by issuing
<B>Style</B>

commands or by using various modules), these changes are lost
after saving and restarting the session.  To become permanent,
such changes have to be added to the configuration file.
<P>
Note further that the current implementation has the following
anomaly when used on a multi-screen display: Starting fvwm for the
first time, fvwm manages all screens by forking a copy of itself
for each screen.  Every copy knows its parent and issuing a
<B>Quit</B>

command to any instance of fvwm kills the master and thus all
copies of fvwm.  When you save and restart the session, the
session manager brings up a copy of fvwm on each screen, but this
time they are started as individual instances managing one screen
only.  Thus a
<B>Quit</B>

kills only the copy it was sent to.  This is probably not a very
serious problem, since with session management, you are supposed
to quit a session through the session manager anyway. If it is
really needed,


<P>


<blockquote><PRE>Exec exec killall fvwm2</PRE></blockquote>
<P>



still kills all copies of fvwm.  Your system must have the
<B>killall</B>

command though.
<P>
<A NAME="lbAY">&nbsp;</A>
<H2>BOOLEAN ARGUMENTS</H2>

<P>
A number of commands take one or several boolean arguments.  These
take a few equivalent inputs: &quot;yes&quot;, &quot;on&quot;, &quot;true&quot;, &quot;t&quot; and &quot;y&quot; all
evaluate to true while &quot;no&quot;, &quot;off&quot;, &quot;false&quot;, &quot;f&quot; and &quot;n&quot; evaluate
to false.  Some commands allow &quot;toggle&quot; too which means that the
feature is disabled if it is currently enabled and vice versa.
<P>
<A NAME="lbAZ">&nbsp;</A>
<H2>BUILT IN KEY AND MOUSE BINDINGS</H2>

<P>
The following commands are built-in to fvwm:


<P>


<blockquote><PRE>Key Help R A Popup MenuFvwmRoot
Key F1 R A Popup MenuFvwmRoot
Key Tab A M WindowList Root c c NoDeskSort, ReverseOrder
Key Escape A MC EscapeFunc
Mouse 0 R N Menu MenuFvwmRoot
Mouse 1 TS A FuncFvwmRaiseLowerX Move
Mouse 1 F  A FuncFvwmRaiseLowerX Resize
AddToFunc FuncFvwmRaiseLowerX I Raise
+ M $0
+ D Lower</PRE></blockquote>
<P>



The
<FONT SIZE="-1">Help</FONT>
and
<FONT SIZE="-1">F1</FONT>
keys invoke a built-in menu that fvwm creates.  This is primarily
for new users that have not created their own configuration
file. Either key on the root (background) window pops up an menu
to help you get started.
<P>
The
<FONT SIZE="-1">Tab</FONT>
key pressed anywhere with the
<FONT SIZE="-1">Meta</FONT>
key (same as the
<FONT SIZE="-1">Alt</FONT>
key on PC keyboards) held down pop-ups a window list.
<P>
Mouse button 1 on the title-bar or side frame can move, raise or
lower a window.
<P>
Mouse button 1 on the window corners can resize, raise or lower a
window.
<P>
You can override or remove these bindings. To remove the window
list binding, use this:


<P>


<blockquote><PRE>Key Tab A M -</PRE></blockquote>
<P>



<P>
<A NAME="lbBA">&nbsp;</A>
<H2>BUILT IN COMMANDS</H2>

<P>
Fvwm supports a set of built-in functions which can be bound to
keyboard or mouse buttons.  If fvwm expects to find a built-in
function in a command, but fails, it checks to see if the
specified command should have been


<P>


<blockquote><PRE>Function (rest of command)</PRE></blockquote>
<P>



or


<P>


<blockquote><PRE>Module (rest of command)</PRE></blockquote>
<P>



This allows complex functions or modules to be invoked in a manner
which is fairly transparent to the configuration file.
<P>
Example: the
<I>.fvwm2rc</I>

file contains the line


<P>


<blockquote><PRE>HelpMe</PRE></blockquote>
<P>



Fvwm looks for a built-in command called &quot;HelpMe&quot;, and fails.
Next it looks for a user-defined complex function called &quot;HelpMe&quot;.
If no such user defined function exists, Fvwm tries to execute a
module called &quot;HelpMe&quot;.
<P>
Note: There are many commands that affect look and feel of
specific, some or all windows, like
<B>Style</B>, <B>Mouse</B>, the <B>FvwmTheme</B>

module and many others.  For performance reasons such changes are
not applied immediately but only when fvwm is idle, i.e. no user
interaction or module input is pending.  Specifically, new
<B>Style</B>

options that are set in a function are not applied until after the
function has completed.  This can sometimes lead to unwanted
effects.
<P>
To force that all pending changes are applied immediately, use the
<B>UpdateStyles</B>, <B>Refresh</B> or <B>RefreshWindow</B>

commands.
<P>
<A NAME="lbBB">&nbsp;</A>
<H3>QUOTING</H3>

<P>
Quotes are required only when needed to make fvwm consider two or
more words to be a single argument.  Unnecessary quoting is
allowed.  If you want a quote character in your text, you must
escape it by using the backslash character.  For example, if you
have a pop-up menu called &quot;Window-Ops&quot;, then you don't need
quotes:


<P>


<blockquote><PRE>Popup Window-Ops</PRE></blockquote>
<P>



but if you replace the dash with a space, then you need
quotes:


<P>


<blockquote><PRE>Popup &quot;Window Ops&quot;</PRE></blockquote>
<P>



The supported quoting characters are double quotes, single quotes
and reverse single quotes.  All three kinds of quotes are treated
in the same way.  Single characters can be quoted with a preceding
backslash.  Quoting single characters works even inside other
kinds of quotes.
<P>
<A NAME="lbBC">&nbsp;</A>
<H3>COMMAND EXPANSION</H3>

<P>
Whenever a fvwm command line is executed, fvwm performs parameter
expansion.  A parameter is a '$' followed by a single letter or a
word enclosed in brackets ($[...]).  If fvwm encounters an
unquoted parameter on the command line it expands it to a string
indicated by the parameter name.  Unknown parameters are left
untouched. Parameter expansion is performed before quoting.  To
quote a '$' use &quot;$$&quot;.  Note that module configuration lines
(i.e. lines beginning with '*') are not fully expanded; for
backward compatibility single alphabetic-letter parameters (like
&quot;$d&quot; or &quot;$n&quot;) are not expanded in these lines.
<P>
The general idea is to expand single letter parameters as soon as
possible.  So a &quot;$d&quot; is expanded immediately when read by the
parser, but &quot;$3&quot; is only expanded in the context of a complex
function with at least four parameters.  Otherwise it is left
untouched.  Similarly, &quot;$c&quot; is only expanded in the context of a
window.
<P>
Parameter expansion in the
<B>+</B>

command is different than in normal commands.  If the command is
adding to a function, single letter parameters are expanded
normally which is often not what was intended.  To suppress
expansion the '$' has to be doubled.  Parameters enclosed in
brackets are protected from parameter expansion in these commands
so the '$' must not be doubled.
<P>
Example:
<P>


<P>


<blockquote><PRE># Print the current desk number, horizontal
# page and the window's class.
Echo $d $[page.nx] $c
# But a function that prints $d needs $$,
# but not before $[page.nx] or $c:
AddToFunc PrintDeskNumber
+ I Echo $$d $[page.nx] $c</PRE></blockquote>
<P>



<P>
Note: If this funtion is called outside a window context, it will
print &quot;$c&quot; instead of the class name.  It is usually not enough to
have the pointer over a window to have a context window.  To force
using the window with the focus, the
<B>Current</B>

command can be used:


<P>


<blockquote><PRE>Current Echo $d $[page.nx] $c</PRE></blockquote>
<P>



<P>
The parameters known by fvwm are:
<P>
<blockquote>
$$
<blockquote>
A literal '$'.
</blockquote>
</blockquote>
<P>
<blockquote>
$.
<blockquote>
The absolute directory of the currently Read file.  Intended for
creating relative and relocatable configuration trees.  If used
outside of any read file, the returned value is '.'.
</blockquote>
</blockquote>
<P>
<blockquote>
$c
<blockquote>
The window's resource class name or &quot;$c&quot; if no window is
associated with the command.
</blockquote>
</blockquote>
<P>
<blockquote>
$d
<blockquote>
The current desk number.
</blockquote>
</blockquote>
<P>
<blockquote>
$n
<blockquote>
The window's name or &quot;$n&quot; if no window is associated with the
command.
</blockquote>
</blockquote>
<P>
<blockquote>
$r
<blockquote>
The window's resource name or &quot;$r&quot; if no window is associated with
the command.
</blockquote>
</blockquote>
<P>
<blockquote>
$v
<blockquote>
The first line printed by the -version command line option.
</blockquote>
</blockquote>
<P>
<blockquote>
$w
<blockquote>
The window-id (expressed in hex, e.g. 0x10023c) of the window the
command was called for or &quot;$w&quot; if no window is associated with the
command.
</blockquote>
</blockquote>
<P>
<blockquote>
$x
<blockquote>
The x coordinate of the current viewport.
</blockquote>
</blockquote>
<P>
<blockquote>
$y
<blockquote>
The y coordinate of the current viewport.
</blockquote>
</blockquote>
<P>
<blockquote>
$0 to $9
<blockquote>
The positional parameters given to a complex function (a function
that has been defined with the
<B>AddToFunc</B>

command).  &quot;$0&quot; is replaced with the first parameter, &quot;$1&quot; with
the second parameter and so on.  If the corresponding parameter is
undefined, the &quot;$...&quot; is deleted from the command line.
</blockquote>
</blockquote>
<P>
<blockquote>
$*
<blockquote>
All positional parameters given to a complex function.  This
includes parameters that follow after &quot;$9&quot;.
</blockquote>
</blockquote>
<P>
<blockquote>
$[vp.x]
$[vp.y]
$[vp.width]
$[vp.height]
<blockquote>
Either coordinate or the width or height of the current viewport.
</blockquote>
</blockquote>
<P>
<blockquote>
$[desk.width]
$[desk.height]
<blockquote>
The width or height of the whole desktop, i.e. the width or height
multiplied by the number of pages in x or y direction.
</blockquote>
</blockquote>
<P>
<blockquote>
$[page.nx]
$[page.ny]
<blockquote>
The current page numbers, by X and Y axes, starting from 0.
<I>page</I> is equivalent to <I>area</I> in the GNOME terminology.

</blockquote>
</blockquote>
<P>
<blockquote>
$[w.x]
$[w.y]
$[w.width]
$[w.height]
<blockquote>
Either coordinate or the width or height of the current window if
it is not iconified.  If no window is associated with the command
or the window is iconified, the string is left as is.
</blockquote>
</blockquote>
<P>
<blockquote>
$[screen]
<blockquote>
The screen number fvwm is running on.  Useful for setups with
multiple screens.
</blockquote>
</blockquote>
<P>
<blockquote>
$[fg.cs&lt;n&gt;]
</blockquote>
<blockquote>
$[bg.cs&lt;n&gt;]
</blockquote>
<blockquote>
$[hilight.cs&lt;n&gt;]
</blockquote>
<blockquote>
$[shadow.cs&lt;n&gt;]
<blockquote>
These class of parameters is replaced with the name of the
foreground (fg), background (bg), hilight (hilight) or shadow
(shadow) color that is defined in colorset &lt;n&gt; (replace &lt;n&gt; with
zero or a positive integer).  For example &quot;$[fg.cs3]&quot; is expanded
to the name of the foreground color of colorset 3 (in
rgb:rrrr/gggg/bbbb form).  Please refer to the man page of the
<B>FvwmTheme</B>

module for details about colorsets.  Note that although other
parameters cannot be used in module configuration lines, it is
possible to use this class of parameters.  They can be used
wherever a module expects a color name.  Since the
<B>FvwmTheme</B>

module is not running when fvwm first passes through its
configuration file, you may not get the desired results if you use
this in commands like


<P>


<blockquote><PRE>Style * HilightFore $[fg.cs0], HilightBack $[bg.cs0]</PRE></blockquote>
<P>



</blockquote>
</blockquote>
<P>
<blockquote>
$[...]
<blockquote>
If the string within the braces is neither of the above, fvwm
tries to find an environment variable with this name and replaces
its value if one is found (e.g. &quot;$[PAGER]&quot; could be replaced by
&quot;more&quot;).  Otherwise the string is left as is.
</blockquote>
</blockquote>
<P>
Some examples can be found in the description of the
<B>AddToFunc</B>

command.
<P>
<A NAME="lbBD">&nbsp;</A>
<H3>THE LIST OF BUILTIN COMMANDS</H3>

<P>
The commands descriptions below are grouped together in the
following sections.  The sections are hopefully sorted in order of
usefulness to the newcomer.


<P>


<blockquote><PRE>- Menu commands
- Miscellaneous commands
- Commands affecting window movement and placement
- Commands for focus and mouse movement
- Commands controlling window state
- Commands for mouse, key and stroke bindings
- The Style command (controlling window styles)
- Other commands controlling window styles
- Commands controlling the virtual desktop
- Commands for user functions and shell commands
- Conditional commands
- Module commands
- Quit, restart and session management commands
- Color gradients</PRE></blockquote>
<P>



<P>
<A NAME="lbBE">&nbsp;</A>
<H3>COMMANDS FOR MENUS</H3>

<P>
<DL COMPACT>
<DT><B>AddToMenu </B><I>menu-name</I><B> [</B><I>menu-label</I><B> </B><I>action</I><B>]</B>

<DD>
<P>
Begins or adds to a menu definition.  Typically a menu definition
looks like this:


<P>


<blockquote><PRE>AddToMenu Utilities Utilities Title
 + Xterm           Exec  exec xterm -e tcsh
 + Rxvt            Exec  exec rxvt
 + &quot;Remote Logins&quot; Popup Remote-Logins
 + Top             Exec  exec rxvt -T Top -n \
                   Top -e top
 + Calculator      Exec  exec xcalc
 + Xman            Exec  exec xman
 + Xmag            Exec  exec xmag
 + emacs           Exec  exec xemacs
 + Mail            MailFunction \
                   xmh &quot;-font fixed&quot;
 + &quot;&quot;              Nop
 + Modules         Popup Module-Popup
 + &quot;&quot;              Nop
 + Exit Fvwm       Popup Quit-Verify</PRE></blockquote>
<P>



The menu could be invoked via


<P>


<blockquote><PRE>Mouse 1 R A Menu Utilities Nop</PRE></blockquote>
<P>



or


<P>


<blockquote><PRE>Mouse 1 R A Popup Utilities</PRE></blockquote>
<P>



There is no end-of-menu symbol.  Menus do not have to be defined
in a contiguous region of the
<I>.fvwm2rc</I>

file.  The quoted portion in the above examples is the menu label,
which appears in the menu when the user pops it up.  The remaining
portion is a built-in command which should be executed if the user
selects that menu item.  An empty menu-label (&quot;&quot;) and the
<B>Nop</B>

function can be used to insert a separator into the menu.
<P>
The keywords
<I>DynamicPopUpAction</I> and <I>DynamicPopDownAction</I>

have a special meaning when used as the name of a menu item.  The
action following the keyword is executed whenever the menu is
popped up or down.  This way you can implement dynamic menus.  It
is even possible to destroy itself with
<B>DestroyMenu</B>

and the rebuild from scratch.  When the menu has been destroyed
(unless you used the
<I>recreate</I>

option when destroying the menu), do not forget to add the dynamic
action again.
<P>
Note: Do not trigger actions that require user interaction. They
will probably fail and may screw up your menus.  See
<B>Silent</B>

command.
<P>
Warning: Do not issue
<B>MenuStyle</B>

commands as dynamic menu actions.  Chances are good that this will
crash fvwm.
<P>
Example (File browser):


<P>


<blockquote><PRE># You can find the shell script
# fvwm_make_browse_menu.sh in the utils
# directory of the distribution.
AddToMenu BrowseMenu
+ DynamicPopupAction Piperead \
  'fvwm_make_browse_menu.sh BrowseMenu'</PRE></blockquote>
<P>



Example (Picture menu):


<P>


<blockquote><PRE># Build a menu of all .jpg files in
# $HOME/Pictures
AddToMenu JpgMenu foo title
+ DynamicPopupAction Function MakeJpgMenu

AddToFunc MakeJpgMenu
+ I DestroyMenu recreate JpgMenu
+ I AddToMenu JpgMenu Pictures Title
+ I PipeRead 'for i in $HOME/Pictures/*.jpg; \
  do echo AddToMenu JpgMenu &quot;`basename $i`&quot; Exec xv $i; done'</PRE></blockquote>
<P>



The keyword
<I>MissingSubmenuFunction</I>

has a similar meaning.  It is executed whenever you try to pop up
a sub-menu that does not exist.  With this function you can define
and destroy menus on the fly.  You can use any command after the
keyword, but the name of a function defined with
<B>AddToFunc</B>

follows it, fvwm executes this command:


<P>


<blockquote><PRE>Function &lt;function-name&gt; &lt;menu-name&gt;</PRE></blockquote>
<P>



I.e. the name is passed to the function as its first argument and
can be referred to with &quot;$0&quot;.
<P>
Example:


<P>


<blockquote><PRE># There is another shell script
# fvwm_make_directory_menu.sh in the utils
# directory of the distribution. To use it,
# define this function in your configuration
# file:

AddToFunc MakeMissingDirectoryMenu
+ I Exec fvwm_make_directory_menu.sh $0

AddToMenu SomeMenu
+ MissingSubmenuFunction MakeMissingDirectoryMenu
+ &quot;Root directory&quot; Popup /</PRE></blockquote>
<P>



This is another implementation of the file browser that uses
sub-menus for subdirectories.
<P>
Titles can be used within the menu. If you add the option
<I>top</I>

behind the keyword
<B>Title</B>,

the title is added to the top of the menu.  If there was a title
already, it is overwritten.


<P>


<blockquote><PRE>AddToMenu Utilities Tools Title top</PRE></blockquote>
<P>



All text up to the first
<FONT SIZE="-1">Tab</FONT>
in the menu label is aligned to the left side of the menu, all
text right of the first
<FONT SIZE="-1">Tab</FONT>
is aligned to the left in a second column and all text thereafter
is placed right aligned in the third column.  All other
<FONT SIZE="-1">Tabs</FONT>
are replaced by spaces.  Note that you can change this format with
the
<I>ItemFormat</I>

option of the
<B>MenuStyle</B>

command.
<P>
If the menu-label contains an ampersand ('&amp;'), the next character
is taken as a hot-key for the menu item.  Hot-keys are underlined
in the label.  To get a literal '&amp;', insert &quot;&amp;&amp;&quot;.  Pressing the
hot-key moves through the list of menu items with this hot-key or
selects an item that is the only one with this hot-key.
<P>
If the menu-label contains a sub-string which is set off by stars,
then the text between the stars is expected to be the name of an
xpm-icon or bitmap-file to insert in the menu.  To get a literal



<P>


<blockquote><PRE> + Calculator*xcalc.xpm* Exec exec xcalc</PRE></blockquote>
<P>



inserts a menu item labeled &quot;Calculator&quot; with a picture of a
calculator above it.  The following:


<P>


<blockquote><PRE> + *xcalc.xpm*           Exec exec xcalc</PRE></blockquote>
<P>



Omits the &quot;Calculator&quot; label, but leaves the picture.
<P>
If the menu-label contains a sub-string which is set off by
percent signs, then the text between the percent signs is expected
to be the name of an xpm-icon or bitmap-file (a so called mini
icon to insert to the left of the menu label.  A second mini icon
that is drawn at the right side of the menu can be given in the
same way.  To get a literal '%', insert &quot;%%&quot;. For example


<P>


<blockquote><PRE> + Calculator%xcalc.xpm% Exec exec xcalc</PRE></blockquote>
<P>



inserts a menu item labeled &quot;Calculator&quot; with a picture of a
calculator to the left.  The following:


<P>


<blockquote><PRE> + %xcalc.xpm%           Exec exec xcalc</PRE></blockquote>
<P>



Omits the &quot;Calculator&quot; label, but leaves the picture.  The
pictures used with this feature should be small (perhaps 16x16).
If the menu-name (not the label) contains a sub-string which is
set off by at signs ('@'), then the text between them is expected
to be the name of an xpm or bitmap file to draw along the left
side of the menu (a side pixmap).  You may want to use the
<I>SidePic</I>

option of the
<B>MenuStyle</B>

command instead.  To get a literal '@', insert &quot;@@&quot;.  For example


<P>


<blockquote><PRE>AddToMenu <a name="local-fix:linux-menu.xpm">StartMenu@linux-menu.xpm</A>@</PRE></blockquote>
<P>



creates a menu with a picture in its bottom left corner.
<P>
If the menu-name also contains a sub-string surrounded by '^'s, then
the text between '^'s is expected to be the name of an X11 color
and the column containing the side picture is colored with that
color.  You can set this color for a menu style using the
<I>SideColor</I>

option of the
<B>MenuStyle</B>

command.  To get a literal '^', insert &quot;^^&quot;.  Example:


<P>


<blockquote><PRE>AddToMenu <a name="local-fix:linux-menu.xpm">StartMenu@linux-menu.xpm</A>@^blue^</PRE></blockquote>
<P>



creates a menu with a picture in its bottom left corner and
colors with blue the region of the menu containing the picture.
<P>
In all the above cases, the name of the resulting menu is name
specified, stripped of the substrings between the various
delimiters.
<P>
<DT><B>ChangeMenuStyle </B><I>menustyle menu ...</I>

<DD>
Changes the menu style of
<I>menu</I> to <I>menustyle</I>.

You may specified more than one menu in each call of
<B>ChangeMenuStyle</B>.



<P>


<blockquote><PRE>ChangeMenuStyle pixmap1 \
  ScreenSaverMenu ScreenLockMenu</PRE></blockquote>
<P>



<P>
<DT><B>CopyMenuStyle </B><I>orig-menustyle dest-menustyle</I>

<DD>
Copy
<I>orig-menustyle</I> to <I>dest-menustyle</I>,

where
<I>orig-menustyle</I>

is an existing menu style.  If the menu style
<I>dest_menustyle</I>

does not exist, then it is created.
<P>
<DT><B>DestroyMenu [</B><I>recreate</I><B>] </B><I>menu</I>

<DD>
Deletes a menu, so that subsequent references to it are no longer
valid.  You can use this to change the contents of a menu during
an fvwm session.  The menu can be rebuilt using
<B>AddToMenu</B>.

The optional parameter
<I>recreate</I>

tells fvwm not to throw away the menu completely but to throw away
all the menu items (including the title).


<P>


<blockquote><PRE>DestroyMenu Utilities</PRE></blockquote>
<P>



<P>
<DT><B>DestroyMenuStyle </B><I>menustyle</I>

<DD>
Deletes the menu style named
<I>menustyle</I>

and changes all menus using this style to the default style, you
cannot destroy the default menu style.


<P>


<blockquote><PRE>DestroyMenuStyle pixamp1</PRE></blockquote>
<P>



<P>
<DT><B>Menu</B> <I>menu-name</I> <B>[</B> <I>position</I> <B>] [</B> <I>double-click-action</I> <B>]</B><DD>
Causes a previously defined menu to be popped up in a sticky
manner. That is, if the user invokes the menu with a click action
instead of a drag action, the menu stays up.  The command
<I>double-click-action</I>

is invoked if the user double-clicks a button (or hits the key
rapidly twice if the menu is bound to a key) when bringing up the
menu.  If the double click action is not specified, double
clicking on the menu does nothing.  However, if the menu begins
with a menu item (i.e. not with a title or a separator) and the
double click action is not given, double clicking invokes the
first item of the menu (but only if the pointer really was over
the item).
<P>
Several other commands affect menu operation.  See
<B>MenuStyle</B> and <B>SetAnimation</B>.

When in a menu, keyboard shortcuts work as expected.  Cursor
keystrokes are also allowed. Specifically,
<FONT SIZE="-1">Tab,</FONT>
<FONT SIZE="-1">Meta-Tab,</FONT>
<FONT SIZE="-1">Cursor-Down,</FONT>
<FONT SIZE="-1">Ctrl-N,</FONT>
or
<FONT SIZE="-1">Ctrl-J</FONT>
move to the next item;
<FONT SIZE="-1">Shift-Tab,</FONT>
<FONT SIZE="-1">Shift-Meta-Tab,</FONT>
<FONT SIZE="-1">Cursor-Up,</FONT>
<FONT SIZE="-1">Ctrl-P,</FONT>
or
<FONT SIZE="-1">Ctrl-K</FONT>
move to the prior item;
<FONT SIZE="-1">Cursor-Left</FONT>
or
<FONT SIZE="-1">Ctrl-B</FONT>
returns to the prior menu;
<FONT SIZE="-1">Cursor-Right</FONT>
or
<FONT SIZE="-1">Ctrl-F</FONT>
pop up the next menu;
<FONT SIZE="-1">Ctrl-Cursor-Up,</FONT>
<FONT SIZE="-1">Shift-Ctrl-Meta-Tab</FONT>
and
<FONT SIZE="-1">Page-Up</FONT>
move up five items;
<FONT SIZE="-1">Ctrl-Cursor-Down,</FONT>
<FONT SIZE="-1">Ctrl-Meta-Tab</FONT>
and
<FONT SIZE="-1">Page-Down</FONT>
move down five items, respectively;
<FONT SIZE="-1">Home,</FONT>
<FONT SIZE="-1">Shift-Cursor-Up</FONT>
or
<FONT SIZE="-1">End,</FONT>
<FONT SIZE="-1">Shift-Cursor-Down</FONT>
move to the first or last item, respectively;
<FONT SIZE="-1">Meta-Cursor-Up</FONT>
or
<FONT SIZE="-1">Meta-Cursor-Down</FONT>
move just behind the next or previous separator;
<FONT SIZE="-1">Shift-Ctrl-Tab</FONT>
or
<FONT SIZE="-1">Ctrl-Tab</FONT>
work exactly the same;
<FONT SIZE="-1">Enter,</FONT>
<FONT SIZE="-1">Return,</FONT>
or
<FONT SIZE="-1">Space</FONT>
executes the current item;
<FONT SIZE="-1">Insert</FONT>
opens the &quot;More...&quot; sub-menu if any;
<FONT SIZE="-1">Escape</FONT>
and
<FONT SIZE="-1">Delete</FONT>
exit the current sequence of menus.
<P>
The pointer is warped to where it was when the menu was invoked if
it was both invoked and terminated with a keystroke.
<P>
The
<I>position</I>

arguments allow placement of the menu somewhere on the screen, for
example centered on the visible screen or above a title bar.
Basically it works like this: you specify a
<I>context-rectangle</I>

and an offset to this rectangle by which the upper left corner of
the menu is moved from the upper left corner of the rectangle.
The
<I>position</I>

arguments consist of several parts:


<P>


<blockquote><PRE><B>[</B><I>context-rectangle</I><B>] </B><I>x y</I><B> [</B><I>special-options</I><B>]</B></PRE></blockquote>
<P>



The
<I>context-rectangle</I>

can be one of:
<P>
<blockquote>
<B>Root</B>

<blockquote>
the root window of the current screen.
</blockquote>
<B>XineramaRoot</B>

<blockquote>
the root window of the whole Xinerama screen.  Equivalent to
&quot;root&quot; when Xinerama is not used.
</blockquote>
<B>Mouse</B>

<blockquote>
a 1x1 rectangle at the mouse position.
</blockquote>
<B>Window</B>

<blockquote>
the window with the focus.
</blockquote>
<B>Interior</B>

<blockquote>
the inside of the focused window.
</blockquote>
<B>Title</B>

<blockquote>
the title of the focused window or icon.
</blockquote>
<B>Button&lt;n&gt;</B>

<blockquote>
button #n of the focused window.
</blockquote>
<B>Icon</B>

<blockquote>
the focused icon.
</blockquote>
<B>Menu</B>

<blockquote>
the current menu.
</blockquote>
<B>Item</B>

<blockquote>
the current menu item.
</blockquote>
<B>Context</B>

<blockquote>
the current window, menu or icon.
</blockquote>
<B>This</B>

<blockquote>
whatever widget the pointer is on (e.g. a corner of a window or
the root window).
</blockquote>
<B>Rectangle &lt;</B><I>geometry</I><B>&gt;</B>

<blockquote>
the rectangle defined by
&lt;<I>geometry</I>&gt;

in X geometry format.  Width and height default to 1 if omitted.
</blockquote>
</blockquote>
<P>
If the context-rectangle is omitted or illegal (e.g. &quot;item&quot; on a
window), &quot;Mouse&quot; is the default.  Note that not all of these make
sense under all circumstances (e.g. &quot;Icon&quot; if the pointer is on a
menu).
<P>
The offset values
<I>x</I>

and
<I>y</I>

specify how far the menu is moved from it's default position.  By
default, the numeric value given is interpreted as a percentage of
the context rectangle's width (height), but with a trailing
'<I>m</I>'

the menu's width (height) is used instead.  Furthermore a trailing
'<I>p</I>'

changes the interpretation to mean pixels.
<P>
Instead of a single value you can use a list of values.  All
additional numbers after the first one are separated from their
predecessor by their sign.  Do not use any other separators.
<P>
If
<I>x</I> or <I>y</I>

are prefixed with &quot;o&lt;number&gt;&quot; where &lt;number&gt; is an integer, the
menu and the rectangle are moved to overlap at the specified
position before any other offsets are applied.  The menu and the
rectangle are placed so that the pixel at &lt;number&gt; percent of the
rectangle's width/height is right over the pixel at &lt;number&gt;
percent of the menu's width/height. So &quot;o0&quot; means that the
top/left borders of the menu and the rectangle overlap, with
&quot;o100&quot; it's the bottom/right borders and if you use &quot;o50&quot; they are
centered upon each other (try it and you will see it is much
simpler than this description).  The default is &quot;o0&quot;.  The prefix
&quot;o&lt;number&gt;&quot; is an abbreviation for &quot;+&lt;number&gt;-&lt;number&gt;m&quot;.
<P>
A prefix of
'<I>c</I>'

is equivalent to &quot;o50&quot;.  Examples:


<P>


<blockquote><PRE># window list in the middle of the screen
WindowList Root c c

# menu to the left of a window
Menu name window -100m c+0

# popup menu 8 pixels above the mouse pointer
Popup name mouse c -100m-8p

# somewhere on the screen
Menu name rectangle 512x384+1+1 +0 +0

# centered vertically around a menu item
AddToMenu foobar-menu
 + &quot;first item&quot; Nop
 + &quot;special item&quot; Popup &quot;another menu&quot; item \
                  +100 c
 + &quot;last item&quot; Nop

# above the first menu item
AddToMenu foobar-menu
 + &quot;first item&quot; Popup &quot;another menu&quot; item \
                +0 -100m</PRE></blockquote>
<P>



Note that you can put a sub-menu far off the current menu so you
could not reach it with the mouse without leaving the menu.  If
the pointer leaves the current menu in the general direction of
the sub-menu the menu stays up.
<P>
The
<I>special-options</I>:

<P>
<blockquote>
The
<I>animated</I> and <I>Mwm</I> or <I>Win</I>

menu styles may move a menu somewhere else on the screen.  If you
do not want this you can add
<I>Fixed</I>

as an option.  This might happen for example if you want the menu
always in the top right corner of the screen.
<P>
Where do you want a sub-menu to appear when you click on it's menu
item? The default is to place the title under the cursor, but if
you want it where the position arguments say, use the
<I>SelectInPlace</I>

option.  If you want the pointer on the title of the menu, use
<I>SelectWarp</I>

too. Note that these options apply only if the
<I>PopupAsRootMenu </I><B>MenuStyle</B>

option is used.
<P>
The pointer is warped to the title of a sub-menu whenever the
pointer would be on an item when the sub-menu is popped up
(<I>fvwm</I>

menu style) or never warped to the title at all
(<I>Mwm</I> or <I>Win</I>

menu styles). You can force (forbid) warping whenever the sub-menu
is opened with the
<I>WarpTitle</I> (<I>NoWarp</I>) option.

<P>
Note that the
<I>special-options</I>

do work with a normal menu that has no other position arguments.
</blockquote>
<P>
<DT><B>MenuStyle </B><I>stylename options</I>

<DD>
Sets a new menu style or changes a previously defined style.  The
<I>stylename</I>

is the style name; if it contains spaces or tabs it has to be
quoted.  The name &quot;*&quot; is reserved for the default menu style. The
default menu style is used for every menu-like object (e.g. the
window created by the
<B>WindowList</B>

command) that had not be assigned a style using the
<B>ChangeMenuStyle</B>.

See also
<B>DestroyMenuStyle</B>.

When using monochrome color options are ignored.
<P>
<I>options</I>

is a comma separated list containing some of the keywords
Fvwm / Mwm / Win,
BorderWidth,
Foreground,
Background,
Greyed,
HilightBack / HilightBackOff,
ActiveFore / ActiveForeOff,
MenuColorset,
ActiveColorset,
GreyedColorset,
Hilight3DThick / Hilight3DThin / Hilight3DOff,
Hilight3DThickness,
Animation / AnimationOff,
Font,
MenuFace,
PopupDelay,
PopupOffset,
TitleWarp / TitleWarpOff,
TitleUnderlines0 / TitleUnderlines1 / TitleUnderlines2,
SeparatorsLong / SeparatorsShort,
TrianglesSolid / TrianglesRelief,
PopupImmediately / PopupDelayed,
PopdownImmediately / PopdownDelayed,
DoubleClickTime,
SidePic,
SideColor,
PopupAsRootMenu / PopupAsSubmenu,
RemoveSubmenus / HoldSubmenus,
SubmenusRight / SubmenusLeft,
SelectOnRelease,
ItemFormat,
VerticalItemSpacing,
VerticalTitleSpacing,
AutomaticHotkeys / AutomaticHotkeysOff.
<P>
In the above list some options are listed as option pairs or
triples with a '/' in between.  These options exclude each other.
<P>
<I>Fvwm</I>, <I>Mwm</I>, <I>Win</I>

reset all options to the style with the same name in former
versions of fvwm.  The default for new menu styles is
<I>Fvwm</I>

style.  These options override all others except
<I>Foreground</I>, <I>Background</I>, <I>Greyed</I>, <I>HilightBack</I>, 

<I>HilightFore</I> and <I>PopupDelay</I>,

so they should be used only as the first option specified for a
menu style or to reset the style to defined behavior.  The same
effect can be created by setting all the other options one by one.
<P>
<I>Mwm</I> and <I>Win</I>

style menus popup sub-menus automatically.
<I>Win</I>

menus indicate the current menu item by changing the background to dark.
<I>Fvwm</I>

sub-menus overlap the parent menu,
<I>Mwm</I> and <I>Win</I>

style menus never overlap the parent menu.
<P>
<I>Fvwm</I>

style is equivalent to HilightBackOff, Hilight3DThin,
ActiveForeOff, AnimationOff, Font, MenuFace, PopupOffset 0 67,
TitleWarp, TitleUnderlines1, SeparatorsShort, TrianglesRelief,
PopupDelayed, PopdownDelayed, PopupAsSubmenu, HoldSubmenus,
SubmenusRight, BorderWidth 2, AutomaticHotkeysOff.
<P>
<I>Mwm</I>

style is equivalent to HilightBackOff, Hilight3DThick,
ActiveForeOff, AnimationOff, Font, MenuFace, PopupOffset -3 100,
TitleWarpOff, TitleUnderlines2, SeparatorsLong, TrianglesRelief,
PopupImmediately, PopdownDelayed, PopupAsSubmenu, HoldSubmenus,
SubmenusRight, BorderWidth 2, AutomaticHotkeysOff.
<P>
<I>Win</I>

style is equivalent to HilightBack, Hilight3DOff, ActiveForeOff,
AnimationOff, Font, MenuFace, PopupOffset -5 100, TitleWarpOff,
TitleUnderlines1, SeparatorsShort, TrianglesSolid,
PopupImmediately, PopdownDelayed, PopupAsSubmenu, RemoveSubmenus,
SubmenusRight, BorderWidth 2, AutomaticHotkeysOff.
<P>
<I>BorderWidth</I>

takes the thickness of the border around the menus in pixels. It
may be zero to 50 pixels.  The default is 2.  Using an illegal
value reverts the border width to the default.
<P>
<I>Foreground</I> and <I>Background</I>

may have a color name as an argument.  This color is used for menu
text or the menu's background.  You can omit the color name to
reset these colors to the built in default.
<P>
<I>Greyed</I>

may have a color name as an argument.  This color is the one used
to draw a menu-selection which is prohibited (or not recommended)
by the Mwm hints which an application has specified. If the color
is omitted the color of greyed menu entries is based on the
background color of the menu.
<P>
<I>HilightBack</I> and <I>HilightBackOff</I>

switch hilighting the background of the selected menu item on and
off.  A specific background color may be used by providing the
color name as an argument to
<I>HilightBack</I>.

If you use this option without an argument the color is based on
the menu's background color.
<P>
<I>ActiveFore  and  ActiveForeOff</I>

switch hilighting the foreground of the selected menu item on and
off.  A specific foreground color may be used by providing the
color name as an argument to
<I>ActiveFore</I>.

Omitting the color name has the same effect as using
<I>ActiveForeOff</I>.

<P>
<I>MenuColorset</I>

controls if a colorset is used instead of the
<I>Foreground</I>, <I>Background</I> and <I>MenuFace</I>

menu styles.  If the
<I>MenuColorset</I>

keyword is followed by a number equal to zero or greater, this
number is taken as the number of the colorset to use.  If the
number is omitted, the colorset is switched off and the regular
menu styles are used again.  The foreground and background colors
of the menu items are replaced by the colors from the colorset.
If the colorset has a pixmap defined, this pixmap is used as the
background of the menu.  Note that the
<I>MenuFace</I>

menu style has been optimized for memory consumption and may use
less memory than the background from a colorset.  The shape mask
from the colorset is used to shape the menu.  Please refer to the
description of the
<B>Colorset</B>

command and the documentation of the
<B>FvwmTheme</B>

module for details about colorsets.
<P>
<I>ActiveColorset</I>

works exactly like
<I>MenuColorset</I>,

but the foreground from the colorset replaces the color given with
the
<I>ActiveFore</I>

menu style and the colorset's background color replaces the color
given with the
<I>HilightBack</I>

command (to turn on background hilighting you have to use the
<I>HilightBack</I>

menu style too).  If specified, the hilight and shadow colors
from the colorset are used too.  The pixmap and shape mask from
the colorset are not used.
<P>
<I>GreyedColorset</I>

works exactly like
<I>MenuColorset</I>,

but the foreground from the colorset replaces the color given with
the
<I>Greyed</I>

menu style.  No other parts of the colorset are used.
<P>
<I>Hilight3DThick</I>, <I>Hilight3DThin</I> and <I>Hilight3DOff</I>

determine if the selected menu item is hilighted with a 3D
relief. Thick reliefs are two pixels wide, thin reliefs are one
pixel wide.
<P>
<I>Hilight3DThickness</I>

takes one numeric argument that may be between -50 and +50
pixels. With negative values the menu item gets a pressed in look.
The above three commands are equivalent to a thickness of 2, 1 and
0.
<P>
<I>Animation</I> and <I>AnimationOff</I>

turn menu animation on or off.  When animation is on, sub-menus
that don't fit on the screen cause the parent menu to be shifted
to the left so the sub-menu can be seen.
<P>
<I>Font</I>

takes a font name as an argument.  If a font by this name exists
it is used for the text of all menu items.  If it does not exist
or if the name is left blank the built in default is used.
<P>
<I>MenuFace</I>

enforces a fancy background upon the menus.  You can use the same
options for
<I>MenuFace</I>

as for the
<B>ButtonStyle</B>.

See description of
<B>ButtonStyle</B>

command and the
<B>COLOR GRADIENTS</B>

sections for more information.  If you use
<I>MenuFace</I>

without arguments the style is reverted back to normal.
<P>
Some examples of MenuFaces are:


<P>


<blockquote><PRE>MenuFace DGradient 128 2 lightgrey 50 blue 50 \
  white
MenuFace TiledPixmap texture10.xpm
MenuFace HGradient 128 2 Red 40 Maroon 60 \
  White
MenuFace Solid Maroon</PRE></blockquote>
<P>



Note: The gradient styles H, V, B and D are optimized for high
speed and low memory consumption in menus.  This is not the case
for all the other gradient styles.  They may be slow and consume
huge amounts of memory, so if you encounter performance problems
with them you may be better off by not using them.  To improve
performance you can try one or all of the following:
<P>
Turn hilighting of the active menu item other than foreground
color off:


<P>


<blockquote><PRE>MenuStyle &lt;style&gt; Hilight3DOff, HilightBackOff
MenuStyle &lt;style&gt; ActiveFore &lt;preferred color&gt;</PRE></blockquote>
<P>



Make sure sub-menus do not overlap the parent menu. This can
prevent menus being redrawn every time a sub-menu pops up or down.


<P>


<blockquote><PRE>MenuStyle &lt;style&gt; PopupOffset 1 100</PRE></blockquote>
<P>



Run you X server with backing storage.  If your X Server is
started with the -bs option, turn it off.  If not try the -wm
option.


<P>


<blockquote><PRE>startx -- -wm</PRE></blockquote>
<P>



You may have to adapt this example to your system (e.g. if you use
xinit to start X).
<P>
<I>PopupDelay</I>

requires one numeric argument.  This value is the delay in
milliseconds before a sub-menu is popped up when the pointer moves
over a menu item that has a sub-menu.  If the value is zero no
automatic pop up is done.  If the argument is omitted the built in
default is used. Note that the popup delay has no effect if the
<I>PopupImmediately</I>

option is used since sub-menus pop up immediately then.
<P>
<I>PopupImmediately</I>

makes menu items with sub-menus pop up it up as soon as the
pointer enters the item.  The
<I>PopupDelay option</I>

is ignored then.  If
<I>PopupDelayed</I>

is used fvwm looks at the
<I>PopupDelay</I>

option if or when this automatic popup happens.
<P>
<I>PopdownDelay</I>

works exactly like
<I>PopupDelay</I>

but determines the timeout of the
<I>PopupDelayed</I>

style.
<P>
<I>PopdownImmediately</I>

makes sub-menus vanish as soon as the pointer leaves the sub-menu
and the correspondent item in the parent menu.  With the opposite
option
<I>PopdownDelayed</I>

the sub-menu only pops down after the time specified with the
<I>PopdownDelay</I>

option.  This comes handy when the pointer often strays off the
menu item when trying to move into the sub-menu.  Whenever there
is a conflict between the
<I>PopupImmediately</I>, <I>PopupDelayed</I>, <I>PopupDelay</I>

styles and the
<I>PopdownImmediately</I>, <I>PopdownDelayed</I>, <I>PopdownDelay</I>

styles, the
<I>Popup...</I>

styles win when using mouse navigation and the
<I>Popdown...</I>

styles win when navigating with the keyboard.
<P>
<I>PopupOffset</I>

requires two integer arguments.  Both values affect where
sub-menus are placed relative to the parent menu.  If both values
are zero, the left edge of the sub-menu overlaps the left edge of
the parent menu.  If the first value is non-zero the sub-menu is
shifted that many pixels to the right (or left if negative).  If
the second value is non-zero the menu is moved by that many
percent of the parent menu's width to the right or left.
<P>
<I>TitleWarp</I> and <I>TitleWarpOff</I>

affect if the pointer warps to the menu title when a sub-menu is
opened or not. Note that regardless of this setting the pointer is
not warped if the menu does not pop up under the pointer.
<P>
<I>TitleUnderlines0</I>, <I>TitleUnderlines1</I> and <I>TitleUnderlines2</I>

specify how many lines are drawn below a menu title.
<P>
<I>SeparatorsLong</I> and <I>SeparatorsShort</I>

set the length of menu separators.  Long separators run from the
left edge all the way to the right edge.  Short separators leave a
few pixels to the edges of the menu.
<P>
<I>TrianglesSolid</I> and <I>TrianglesRelief</I>

affect how the small triangles for sub-menus is drawn.  Solid
triangles are filled with a color while relief triangles are
hollow.
<P>
<I>DoubleClickTime</I>

requires one numeric argument.  This value is the time in
milliseconds between two mouse clicks in a menu to be considered
as a double click.  The default is 450 milliseconds.  If the
argument is omitted the double click time is reset to this
default.
<P>
<I>SidePic</I>

takes the name of an xpm or bitmap file as an argument. The
picture is drawn along the left side of the menu.  The
<I>SidePic</I>

option can be overridden by a menu specific side pixmap (see
<B>AddToMenu</B>).

If the file name is omitted an existing side pixmap is remove from
the menu style.
<P>
<I>SideColor</I>

takes the name of an X11 color as an argument. This color is used
to color the column containing the side picture (see
above). The SideColor option can be overridden by a menu specific
side color (see
<B>AddToMenu</B>).

If the color name is omitted the side color option is switched off.
<P>
<I>PopupAsRootMenu</I> and <I>PopupAsSubmenu</I>

change the behavior when you click on a menu item that opens a
sub-menu. With
<I>PopupAsRootMenu</I>

the original menu is closed before the sub-menu appears, with
<I>PopupAsSubmenu</I>

it is not, so you can navigate back into the
parent menu.  Furthermore, with
<I>PopupAsSubmenu</I>

the sub-menu is held open (posted) regardless of where you move
the mouse.  Depending on your menu style this may simplify
navigating through the menu.  Any keystroke while a menu is posted
reverts the menu back to the normal behavior.
<I>PopupAsSubmenu</I>

is the default.
<P>
<I>RemoveSubmenus</I>

instructs fvwm to remove sub-menus when you move back into the
parent menu.  With
<I>HoldSubmenus</I>

the sub-menu remains visible.  You probably want to use
<I>HoldSubmenus</I>

if you are using the
<I>PopupDelayed</I>

style.
<I>RemoveSubmenus</I>

affects menu navigation with the keyboard.
<P>
<I>SelectOnRelease</I>

takes an optional key name as an argument.  If the given key is
release in a menu using this style, the current menu item is
selected.  This is intended for
<FONT SIZE="-1">Alt-Tab</FONT>
<B>WindowList</B>

navigation.  The key name is a standard X11 key name as defined in
<I>/usr/include/X11/keysymdef.h</I>,

with the leading &quot;XK_&quot; omitted.  To disable this behaviour, omit
the key name.
<P>
Note: Some X servers do not support KeyRelease events.
<I>SelectOnRelease</I>

does not work on such a machine.
<P>
<I>ItemFormat</I>

takes a special string as its argument that determines the layout
of the menu items.  Think of the format string as if it were a
menu item.  All you have to do is tell fvwm where to place the
different parts of the menu item (i.e. the labels, the triangle
denoting a sub menu, the mini icons and the side pic) in the blank
area.  The string consists of spaces,
<FONT SIZE="-1">Tab</FONT>
characters and formatting directives beginning with '%'. Any
illegal characters and formatting directives are silently ignored:
<P>
<blockquote>
<B>%l</B>, <B>%c</B> and <B>%r</B>

<blockquote>
Insert the next item label.  Up to three labels can be used. The
item column is left-aligned
(<B>%l</B>),

centered
(<B>%c</B>)

or right-aligned
(<B>%r</B>).

</blockquote>
<B>%i</B>

<blockquote>
Inserts the mini icon.
</blockquote>
<B>%&gt;</B> and <B>%&lt;</B>

<blockquote>
Insert the sub-menu triangle pointing either to the right
(<B>%&gt;</B>)

or to the left
(<B>%&lt;</B>)

</blockquote>
<B>%|</B>

<blockquote>
The first
<B>%|</B>

denotes the beginning of the area that is highlighted either with
a background color or a relief (or both).  The second
<B>%|</B>

marks the end of this area.
<B>%|</B>

can be used up to twice in the string.  If you don't add one or
both of them, fvwm sets the margins to the margins of the whole
item (not counting the side picture).
</blockquote>
<B>%s</B>

<blockquote>
Places the side picture either at the beginning or the end of the
menu. This directive may be used only once and only as the first
or last in the format string. If the
<B>%s</B>

is not at the beginning of the string, all characters to the right
of it are silently ignored.
</blockquote>
<B>Space</B>, <B>Tab</B>, <B>%Space</B> and <B>%Tab</B>

<blockquote>
Add a gap as large as one respectively eight spaces are with the
font used in the menu items.  The whole string must be quoted if
spaces or tabs are used.
</blockquote>
<B>%p</B>

<blockquote>
Like
<FONT SIZE="-1">Space</FONT>
and
<FONT SIZE="-1">Tab</FONT>
<B>%p</B>

inserts an empty area into the item, but with better control of
its size (see below).
</blockquote>
</blockquote>
<P>
You can define an additional space before and after each of the
objects like this:


<P>


<blockquote><PRE><B>%</B><I>left</I><B>.</B><I>right</I><B>p</B></PRE></blockquote>
<P>



This means: if the object is defined in the menu (e.g. if it is
<B>%s</B>

and you use a side picture, or it is
<B>%l</B>

for the third column and there are items defined that actually
have a third column), then add
<I>left</I>

pixels before the object and
<I>right</I>

pixels after it.  You may leave out the
<I>left</I>

or the
<I>.right</I>

parts if you don't need them.  All values up to the screen width
are allowed.  Even negative values can be used with care.  The
<B>p</B>

may be replaced with any other formatting directives described
above.
<P>
Note: Only items defined in the format string are visible in the
menus. So if you do not put a
<B>%s</B>

in there you do not see a side picture, even if one is specified.
<P>
Note: The
<I>SubmenusLeft</I>

style changes the default
<I>ItemFormat</I>

string, but if it was set manually it is not modified.
<P>
Note: If any unformatted title of the menu is wider than the
widest menu item, the spaces between the different parts of the
menu items are enlarged to match the width of the title.  Leading
left aligned objects in the format string
(<B>%l</B>, <B>%i</B>, %&lt;<B>, first </B>%|<B>)</B>

stick to the left edge of the menu and trailing right aligned
objects
(<B>%r</B>, <B>%i</B>, %&gt;<B>, second </B>%|<B>)</B>

stick to the right edge.  The gaps between the remaining items are
enlarged equally.
<P>
Examples:


<P>


<blockquote><PRE>MenuStyle * ItemFormat \
  &quot;%.4s%.1|%.5i%.5l%.5l%.5r%.5i%2.3&gt;%1|&quot;</PRE></blockquote>
<P>



Is the default string used by fvwm: (side picture + 4 pixels gap)
(beginning of the hilighted area + 1 pixel gap) (mini icon + 5p)
(first column left aligned + 5p) (second column left aligned + 5p)
(third column right aligned + 5p) (second mini icon + 5p) (2p +
sub-menu triangle + 3p) (1p + end of hilighted area).


<P>


<blockquote><PRE>MenuStyle * ItemFormat \
  &quot;%.1|%3.2&lt;%5i%5l%5l%5r%5i%1|%4s&quot;</PRE></blockquote>
<P>



Is used by fvwm with the
<I>SubmenusLeft</I>

option below.
<P>
<I>VerticalItemSpacing</I> and <I>VerticalTitleSpacing</I>

control the vertical spacing of menu items and titles like
<I>ItemFormat</I>

controls the horizontal spacing.  Both take two numeric arguments
that may range from -100 to +100.  The first is the gap in pixels
above a normal menu item (or a menu title), the second is the gap
in pixels below it.  Negative numbers do not make much sense and
may screw up the menu completely.  If no arguments are given or
the given arguments are invalid, the built in defaults are used:
one pixel above the item or title and two below.
<P>
<I>SubmenusLeft</I>

mirrors the menu layout and behavior.  Sub-menus pop up to the
left, the sub-menu triangle is drawn left and the mini icon and
side picture are drawn at the right side of the menu.  The default
is
<I>SubmenusRight</I>.

The position hints of a menu are also affected by this setting,
i.e. position hints using
<I>item</I> or <I>menu</I>

as context rectangle and position hints using
<I>m</I>

offsets.
<P>
<I>AutomaticHotkeys</I> and <I>AutomaticHotkeysOff</I>

control the menu's ability to automatically provide hot-keys on
the first character of each menu item's label.  This behavior is
always overridden if an explicit hot-key is assigned in the
<B>AddToMenu</B>

command.
<P>
Examples:


<P>


<blockquote><PRE>MenuStyle * Mwm
MenuStyle * Foreground Black, Background gray40
MenuStyle * Greyed gray70, ActiveFore White
MenuStyle * HilightBackOff, Hilight3DOff
MenuStyle * Font lucidasanstypewriter-14
MenuStyle * MenuFace DGradient 64 darkgray \
  MidnightBlue

MenuStyle red Mwm
MenuStyle red Foreground Yellow
MenuStyle red Background Maroon
MenuStyle red Greyed Red, ActiveFore Red
MenuStyle red HilightBackOff, Hilight3DOff
MenuStyle red Font lucidasanstypewriter-12
MenuStyle red MenuFace DGradient 64 Red Black</PRE></blockquote>
<P>



Note that all style options could be placed on a single line for
each style name.
<P>
<DT><B>MenuStyle </B><I>forecolor backcolor shadecolor font style</I><B> [</B><I>anim</I><B>]</B>

<DD>
This is the old syntax of the
<B>MenuStyle</B>

command.  It is obsolete and may be removed in the future.  Please
use the new syntax as described above.
<P>
Sets the menu style.  When using monochrome the colors are
ignored.  The
<I>shadecolor</I>

is the one used to draw a menu-selection which is prohibited (or
not recommended) by the Mwm hints which an application has
specified.  The style option is either
<I>Fvwm</I>, <I>Mwm</I> or <I>Win</I>,

which changes the appearance and operation of the menus.
<P>
<I>Mwm</I> and <I>Win</I>

style menus popup sub-menus automatically.
<I>win</I>

menus indicate the current menu item by changing the background to
black.
<I>fvwm</I>

sub-menus overlap the parent menu,
<I>Mwm</I> and <I>win</I>

style menus never overlap the parent menu.
<P>
When the
<I>anim</I>

option is given, sub-menus that don't fit on the screen cause the
parent menu to be shifted to the left so the sub-menu can be
seen. See also
<B>SetAnimation</B>

command.
<P>
<DT><B>Popup </B><I>PopupName</I><B> [</B><I>position</I><B>] [</B><I>default-action</I><B>]</B>

<DD>
This built-in has two purposes: to bind a menu to a key or mouse
button, and to bind a sub-menu into a menu.  The formats for the
two purposes differ slightly.  The
<I>position</I>

arguments are the same as for
<B>Menu</B>.

The command
<I>default-action</I>

is invoked if the user clicks a button to invoke the menu and
releases it immediately again (or hits the key rapidly twice if
the menu is bound to a key).  If the default action is not
specified, double clicking on the menu does nothing.  However, if
the menu begins with a menu item (i.e. not with a title or a
separator) and the default action is not given, double clicking
invokes the first item of the menu (but only if the pointer really
was over the item).
<P>
To bind a previously defined pop-up menu to a key or mouse button:
<P>
<blockquote>
The following example binds mouse buttons 2 and 3 to a pop-up
called &quot;Window Ops&quot;.  The menu pops up if the buttons 2 or 3 are
pressed in the window frame, side-bar, or title-bar, with no
modifiers (none of shift, control, or meta).


<P>


<blockquote><PRE>Mouse 2 FST N Popup &quot;Window Ops&quot;
Mouse 3 FST N Popup &quot;Window Ops&quot;</PRE></blockquote>
<P>



Pop-ups can be bound to keys through the use of the
<B>Key</B>

built-in.  Pop-ups can be operated without using the mouse by
binding to keys and operating via the up arrow, down arrow, and
enter keys.
</blockquote>
<P>
To bind a previously defined pop-up menu to another menu, for use
as a sub-menu:
<P>
<blockquote>
The following example defines a sub-menu &quot;Quit-Verify&quot; and binds
it into a main menu, called &quot;RootMenu&quot;:


<P>


<blockquote><PRE>AddToMenu Quit-Verify
 + &quot;Really Quit Fvwm?&quot; Title
 + &quot;Yes, Really Quit&quot;  Quit
 + &quot;Restart Fvwm&quot;      Restart
 + &quot;Restart Fvwm 1.xx&quot; Restart fvwm1 -s
 + &quot;&quot;                  Nop
 + &quot;No, Don't Quit&quot;    Nop

AddToMenu RootMenu &quot;Root Menu&quot; Title
 + &quot;Open XTerm Window&quot; Popup NewWindowMenu
 + &quot;Login as Root&quot;     Exec exec xterm \
                         -fg green -T Root \
                         -n Root -e su -
 + &quot;Login as Anyone&quot;   Popup AnyoneMenu
 + &quot;Remote Hosts&quot;      Popup HostMenu
 + &quot;&quot;                  Nop
 + &quot;X utilities&quot;       Popup Xutils
 + &quot;&quot;                  Nop
 + &quot;Fvwm Modules&quot;      Popup Module-Popup
 + &quot;Fvwm Window Ops&quot;   Popup Window-Ops
 + &quot;&quot;                  Nop
 + &quot;Previous Focus&quot;    Prev (AcceptsFocus) Focus
 + &quot;Next Focus&quot;        Next (AcceptsFocus) Focus
 + &quot;&quot;                  Nop
 + &quot;Refresh screen&quot;    Refresh
 + &quot;Recapture screen&quot;  Recapture
 + &quot;&quot;                  Nop
 + &quot;Reset X defaults&quot;  Exec xrdb -load \
                       $HOME/.Xdefaults
 + &quot;&quot;                  Nop
 + &quot;&quot;                  Nop
 + Quit                Popup Quit-Verify</PRE></blockquote>
<P>



</blockquote>
<P>
<B>Popup</B>

differs from
<B>Menu</B>

in that pop-ups do not stay up if the user simply clicks.  These
are popup-menus, which are a little hard on the wrist.
<B>Menu</B>

menus stay up on a click action.  See the
<B>Menu</B>

command for an explanation of the interactive behavior of menus. A
menu can be open up to ten times at once, so a menu may even use
itself or any of its predecessors as a sub-menu.
<P>
<DT><B>Title</B>

<DD>
Does nothing.  This is used to insert a title line in a popup or
menu.
<P>
</DL>
<A NAME="lbBF">&nbsp;</A>
<H3>MISCELLANEOUS COMMANDS</H3>

<P>
<DL COMPACT>
<DT><B>BugOpts [</B><I>option</I><B> [</B><I>bool</I><B>]], </B><I>...</I>

<DD>
This command controls several workarounds for bugs in third party
programs.  The individual options are separated by commas.  The
optional argument
<I>bool</I>

is a boolean argument and controls if the bug workaround is
enabled or not.  It can either be &quot;True&quot; or &quot;False&quot; to turn the
option on or off, or &quot;toggle&quot; to switch is back and forth.  If
<I>bool</I>

is omitted, the default setting is restored.
<P>
<I>FlickeringMoveWorkaround</I>

disables ConfigureNotify events that are usually sent to
an application while it is moved.  If some windows flicker
annoyingly while being moved, this option may help you.  Note that
if this problem occurs it is not an fvwm bug, it is a problem of the
application.
<P>
<I>MixedVisualWorkaround</I>

makes fvwm install the root colormap before it does some
operations using the root window visuals.  This is only useful
when the
<B>-visual</B>

option is used to start fvwm and then only with some
configurations of some servers (e.g. Exceed 6.0 with an 8 bit
PseudoColor root and fvwm using a 24 bit TrueColor visual).
<P>
The
<I>ModalityIsEvil</I>

option controls whether Motif applications have the ability to have
modal dialogs (dialogs that force you to close them first before
you can do anything else).  The default is to not allow
applications to have modal dialogs.  Use this option with care.
Once this option is turned on, you have to restart fvwm to turn it
off.
<P>
<I>RaiseOverNativeWindows</I>

makes fvwm try to raise the windows it manages over native windows
of the X servers host system.  This is needed for some X servers
running under Windows or Windows NT.  Fvwm tries to detect if it
is running under such an X server and initializes the flag
accordingly.
<P>
<I>RaiseOverUnmanaged</I>

makes fvwm try to raise the windows it manages over
override_redirect windows.  This is used to cope with ill-mannered
applications that use long-lived windows of this sort, contrary to
<FONT SIZE="-1">ICCCM</FONT>
conventions.
<P>
<I>FlickeringQtDialogsWorkaround</I>

suppresses flickering of the focused window in some modules when
using KDE or Qt applications with application modal dialog
windows.  By default this option is turned on.  This option may be
visually disturbing for other applications using windows not
managed by fvwm.  Since these applications are rare it is most
likely safe to leave this option at its default.
<P>
<DT><B>BusyCursor [</B><I>Option bool</I><B>], </B><I>...</I>

<DD>
This command controls the cursor during the execution of certain
commands.
<I>Option</I>

can be
<I>DynamicMenu</I>, <I>ModuleSynchronous</I>, <I>Read</I>, <I>Wait</I>, <I>*</I>.

An option must be followed by a boolean argument
<I>bool</I>.

You can use commas to separate individual options.  If you set an
option to &quot;True&quot;, then when the corresponding command is run, fvwm
displays the cursor of the
<I>WAIT</I>

context of the
<B>CursorStyle</B>

command.  &quot;False&quot; forces to not display the cursor.  The default is:


<P>


<blockquote><PRE>BusyCursor DynamicMenu False, \
  ModuleSynchronous False, Read False, \
  Recapture True, Wait False</PRE></blockquote>
<P>



The option
<I>*</I>

refers to all available options.
<P>
The
<I>Read</I>

option also controls the
<B>PipeRead</B>

command.
<P>
The
<I>DynamicMenu</I>

option affects the
<I>DynamicPopupAction</I>

and
<I>MissingSubmenuFunction</I>

options of the
<B>AddToMenu</B>

command.  If this option is set to &quot;False&quot;, then the busy cursor
is not displayed during a dynamic menu command even if this
command is a
<B>Read</B> or <B>PipeRead</B>

command and the
<I>Read</I>

option is set to &quot;True&quot;.
<P>
The
<I>Wait</I>

option affects only the root cursor.  During a wait pause the root
cursor is replaced by the busy cursor and fvwm is still fully
functional (you can escape from the pause, see the
<B>EscapeFunc</B>

command).  If you want to use this option and if you do not use
the default root cursor, you must set your root cursor with the
<B>CursorStyle</B>

command.
<P>
<DT><B>ClickTime [</B><I>delay</I><B>]</B>

<DD>
Specifies the maximum delay in milliseconds between a button press
and a button release for the
<B>Function</B>

built-in to consider the action a mouse click.  The default delay
is 150 milliseconds.  Omitting the delay value resets the
<B>ClickTime</B>

to the default.
<P>
<DT><B>ColorLimit </B><I>limit</I>

<DD>
Specifies a
<I>limit</I>

on the colors used in  pixmaps used  by fvwm. Zero (the default)
sets no limit.  Fvwm uses pixmaps for icons, mini-icons, and
pixmap borders, menu backgrounds and titles. This command limits
pixmap colors to a set of colors that starts out with common
colors.  The current list contains about 60 colors and starts with
white, black, grey, green, blue, red, cyan, yellow, and magenta.
The command


<P>


<blockquote><PRE>ColorLimit 9</PRE></blockquote>
<P>



would limit pixmaps to these 9 colors.
<P>
It makes the most sense to put this command at the front of the
<I>.fvwm2rc</I>

file.  This command should occur before any menu definitions that
contain mini-icons.
<P>
Solid frame and title colors (including shadows and gradients) are
not controlled by this command.
<P>
This command only makes sense on screens that display a limited
number of colors at once.  If your  display can display more than
2 million colors at once, this command is ignored.  Screens that
only display 256 colors at once are known as 8 bit displays. The 2
million color cutoff point corresponds to 21 bit color, the most
common screen that exceeds this limit would be 24 bit.
<P>
On 8 bit displays, the default color limit is set to the size of
the built in table (about 60).  We recommend that you start with
the default value, and not include this command in your
<I>.fvwm2rc</I>.

<P>
<DT><B>ColormapFocus </B><I>FollowsMouse</I><B>|</B><I>FollowsFocus</I>

<DD>
By default, fvwm installs the colormap of the window that the
cursor is in.  If you use


<P>


<blockquote><PRE>ColormapFocus FollowsFocus</PRE></blockquote>
<P>



then the installed colormap is the one for the window that
currently has the keyboard focus.
<P>
<DT><B>CursorStyle</B> <I>context</I> <B>[</B> <I>number</I> <B>|</B> <I>name</I> <B>|</B> <I>xpm</I> <B>|</B> <I>None</I> <B>|</B> <I>Tiny</I> <B>[</B> <I>fore back</I> <B>]]</B><DD>
Defines a new cursor for the specified context.  The various
contexts are:
<P>
<blockquote>
<B>POSITION </B>(top_left_corner)

<blockquote>
used when initially placing windows
</blockquote>
<P>
<B>TITLE </B>(top_left_arrow)

<blockquote>
used in a window title-bar
</blockquote>
<P>
<B>DEFAULT </B>(top_left_arrow)

<blockquote>
used in windows that don't set their cursor
</blockquote>
<P>
<B>SYS </B>(hand2)

<blockquote>
used in one of the title-bar buttons
</blockquote>
<P>
<B>MOVE </B>(fleur)

<blockquote>
used when moving or resizing windows
</blockquote>
<P>
<B>RESIZE </B>(sizing)

<blockquote>
used when moving or resizing windows
</blockquote>
<P>
<B>WAIT </B>(watch)

<blockquote>
used during certain fvwm commands (see
<B>BusyCursor</B>

for details).
</blockquote>
<P>
<B>MENU </B>(top_left_arrow)

<blockquote>
used in menus
</blockquote>
<P>
<B>SELECT </B>(crosshair)

<blockquote>
used when the user is required to select a window
</blockquote>
<P>
<B>DESTROY </B>(pirate)

<blockquote>
used for DESTROY, CLOSE, and DELETE built-ins
</blockquote>
<P>
<B>TOP </B>(top_side)

<blockquote>
used in the top side-bar of a window
</blockquote>
<P>
<B>RIGHT </B>(right_side)

<blockquote>
used in the right side-bar of a window
</blockquote>
<P>
<B>BOTTOM </B>(bottom_side)

<blockquote>
used in the bottom side-bar of a window
</blockquote>
<P>
<B>LEFT </B>(left_side)

<blockquote>
used in the left side-bar of a window
</blockquote>
<P>
<B>TOP_LEFT </B>(top_left_corner)

<blockquote>
used in the top left corner of a window
</blockquote>
<P>
<B>TOP_RIGHT </B>(top_right_corner)

<blockquote>
used in the top right corner of a window
</blockquote>
<P>
<B>BOTTOM_LEFT </B>(bottom_left_corner)

<blockquote>
used in the bottom left corner of a window
</blockquote>
<P>
<B>BOTTOM_RIGHT </B>(bottom_right_corner)

<blockquote>
used in the bottom right corner of a window
</blockquote>
<P>
<B>TOP_EDGE </B>(top_side)

<blockquote>
used at the top edge of the screen.
</blockquote>
<P>
<B>RIGHT_EDGE </B>(right_side)

<blockquote>
used at the right edge of the screen.
</blockquote>
<P>
<B>BOTTOM_EDGE </B>(bottom_side)

<blockquote>
used at the bottom edge of the screen.
</blockquote>
<P>
<B>LEFT_EDGE </B>(left_side)

<blockquote>
used at the left edge of the screen.
</blockquote>
<P>
<B>ROOT </B>(left_ptr)

<blockquote>
used as the root cursor.
</blockquote>
<P>
<B>STROKE </B>(plus)

<blockquote>
used during a
<B>StrokeFunc</B>

command.
</blockquote>
</blockquote>
<P>
The defaults are shown in parentheses above.  Is you ever want to
restore the default cursor for a specific context you can omit the
second argument.
<P>
The second is either the numeric value of the cursor as defined in
the include file
<I>X11/cursorfont.h</I>

or its name (without the XC_ prefix) or the name of an xpm file
containing a pixmap of depth 1 with a mask and an optional
hot-spot (if no hot-spot is defined, the hot-spot is placed in the
center of the image).  Furthermore the name can be
<I>None</I>

(no cursor) or
<I>Tiny</I>

(a single pixel as the cursor).  For example:


<P>


<blockquote><PRE># make the kill cursor be XC_gumby (both forms work):
CursorStyle DESTROY 56
CursorStyle DESTROY gumby

CursorStyle TOP_LEFT topl.xpm
CursorStyle ROOT hand1 yellow black</PRE></blockquote>
<P>



The optional
<I>fg</I> and <I>bg</I>

arguments specify the foreground and background colors for the
cursor, defaulting to black and white.
<P>
<DT><B>DefaultColors [</B><I>foreground background</I><B>]</B>

<DD>
<B>DefaultColors</B>

sets the default foreground and background colors used in
miscellaneous windows created by fvwm, for example in the geometry
feedback windows during a move or resize operation. If you don't
want to change one color or the other, use - as its color name.
To revert to the builtin default colors omit both color names.
Note that the default colors are not used in menus, window titles
or icon titles.
<P>
<DT><B>DefaultColorset [</B><I>num</I><B>]</B>

<DD>
<B>DefaultColorset</B>

sets the colorset used by the windows controlled by the
<B>DefaultColors</B>

command.  To revert back to the
<B>DefaultColors</B>

colors use


<P>


<blockquote><PRE>DefaultColorset -1</PRE></blockquote>
<P>



or any variant of the
<B>DefaultColors</B>

command.
<P>
<DT><B>DefaultFont [</B><I>fontname</I><B>]</B>

<DD>
<B>DefaultFont</B>

sets the default font to font
<I>fontname</I>.

The default font is used by fvwm whenever no other font has been
specified.  To reset the default font to the built in default,
omit the argument.  The default font is used for menus, window
titles, icon titles as well as the geometry feedback windows
during a move or resize operation.  To override the default font
in a specific context, use the
<B>Style * Font</B>, <B>Style * IconFont</B>, or <B>MenuStyle</B>

commands.
<P>
<DT><B>DefaultIcon </B><I>filename</I>

<DD>
sets the default icon which is used if a window has neither an
client-supplied icon nor an icon supplied via the
<I>Icon</I>

option of the
<B>Style</B>

command.
<P>
<DT><B>DefaultLayers </B><I>bottom put top</I>

<DD>
changes the layers that are used for the
<I>StaysOnBottom</I>, <I>StaysPut</I>, <I>StaysOnTop</I>

<B>Style</B>

options.  Initially, the layers 2, 4 and 6 are used.
<P>
<DT><B>Emulate </B><I>Fvwm</I><B>|</B><I>Mwm</I><B>|</B><I>Win</I>

<DD>
This command affects how miscellaneous things are done by
fvwm. For example where the move/resize feedback window appears
depends on this command.  To have more Mwm- or Win-like behavior
you can call
<B>Emulate</B>

with
<I>Mwm</I> or <I>Win</I>

as its argument.  With
<I>Mwm</I>

resize and move feedback windows are in the center of the screen,
instead of the upper left corner.
<P>
<DT><B>EscapeFunc</B>

<DD>
By default the key sequence
<FONT SIZE="-1">Ctrl-Alt-Escape</FONT>
allows to escape from a
<B>Wait</B>

pause and from a locked
<B>ModuleSynchronous</B>

command.  The
<B>EscapeFunc</B>

command used with the
<B>Key</B>

command allows to configure this key sequence.  An example:


<P>


<blockquote><PRE>Key Escape A MC -
Key Escape A  S EscapeFunc</PRE></blockquote>
<P>



replaces the
<FONT SIZE="-1">Ctrl-Alt-Escape</FONT>
key sequence with
<FONT SIZE="-1">Shift-Escape</FONT>
for aborting a
<B>Wait</B>

pause and
<B>ModuleSynchronous</B>

command.
<B>EscapeFunc</B>

used outside the
<B>Key</B>

command does nothing.
<P>
<DT><B>FakeClick [</B><I>command value</I><B>] ...</B>

<DD>
This command is mainly intended for debugging fvwm and no
guarantees are made that it works for you.
<B>FakeClick</B>

can simulate mouse button press and release events and pass them
to fvwm or the applications.  The parameters are a list of
commands which consist of pairs of
<I>command</I>

tokens and integer
<I>values,</I>

The
<I>press</I> and <I>release</I>

commands are followed by the appropriate mouse button number and
generate a button press or release event on the window below the
pointer.  The
<I>wait</I>

commands pauses fvwm for the given number of milliseconds.  The
<I>modifiers</I>

command simulates pressing or releasing modifier keys.  The values
1 to 5 are mapped to
<FONT SIZE="-1">Mod1</FONT>
to
<FONT SIZE="-1">Mod5</FONT>
while 6, 7 and 8 are mapped to
<FONT SIZE="-1">Shift,</FONT>
<FONT SIZE="-1">Lock</FONT>
and
<FONT SIZE="-1">Control.</FONT>
The modifier is set for any further button events.  To release a
modifier key, use the corresponding negative number.  The
<I>depth</I>

command determines to which window the button events are sent.
With a depth of 1, all events go to the root window, regardless of
the pointer's position.  With 2, the event is passed to the top
level window under the pointer which is usually the frame window.
With 3, events go to the client window. Higher numbers go to
successive sub windows.  Zero (0) goes to the smallest window that
contains the pointer. Note that events propagate upward.


<P>


<blockquote><PRE> FakeClick depth 2 press 1 wait 250 release 1</PRE></blockquote>
<P>



This simulates a click with button 1 in the parent window (depth
2) with a delay of 250 milliseconds between the press and the
release.
<P>
<DT><B>GlobalOpts [</B><I>options</I><B>]</B>

<DD>
As announced in the past, this command has been removed.  Please
replace the global options in your configuration file according to
the following table:


<P>


<blockquote><PRE>GlobalOpts WindowShadeShrinks
  --&gt;
Style * WindowShadeShrinks

GlobalOpts WindowShadeScrolls
  --&gt;
Style * WindowShadeScrolls

GlobalOpts SmartPlacementIsReallySmart
  --&gt;
Style * MinOverlapPlacement

GlobalOpts SmartPlacementIsNormal
  --&gt;
Style * TileCascadePlacement

GlobalOpts ClickToFocusDoesntPassClick
  --&gt;
Style * ClickToFocusPassesClickOff

GlobalOpts ClickToFocusPassesClick
  --&gt;
Style * ClickToFocusPassesClick

GlobalOpts ClickToFocusDoesntRaise
  --&gt;
Style * ClickToFocusRaisesOff

GlobalOpts ClickToFocusRaises
  --&gt;
Style * ClickToFocusRaises

GlobalOpts MouseFocusClickDoesntRaise
  --&gt;
Style * MouseFocusClickRaisesOff

GlobalOpts MouseFocusClickRaises
  --&gt;
Style * MouseFocusClickRaises

GlobalOpts NoStipledTitles
  --&gt;
Style * StippledTitleOff

GlobalOpts StipledTitles
  --&gt;
Style * StippledTitle

GlobalOpts CaptureHonorsStartsOnPage
  --&gt;
Style * CaptureHonorsStartsOnPage

GlobalOpts CaptureIgnoresStartsOnPage
  --&gt;
Style * CaptureIgnoresStartsOnPage

GlobalOpts RecaptureHonorsStartsOnPage
  --&gt;
Style * RecaptureHonorsStartsOnPage

GlobalOpts RecaptureIgnoresStartsOnPage
  --&gt;
Style * RecaptureIgnoresStartsOnPage

GlobalOpts ActivePlacementHonorsStartsOnPage
  --&gt;
Style * ManualPlacementHonorsStartsOnPage

GlobalOpts ActivePlacementIgnoresStartsOnPage
  --&gt;
Style * ManualPlacementIgnoresStartsOnPage

GlobalOpts RaiseOverNativeWindows
  --&gt;
BugOpts RaiseOverNativeWindows on

GlobalOpts IgnoreNativeWindows
  --&gt;
BugOpts RaiseOverNativeWindows off</PRE></blockquote>
<P>



<P>
<DT><B>HilightColor </B><I>textcolor backgroundcolor</I>

<DD>
This command is obsoleted by the
<B>Style</B>

options
<I>HilightFore</I> and <I>HilightBack</I>.

Please use


<P>


<blockquote><PRE>Style * HilightFore textcolor, \
        HilightBack backgroundcolor</PRE></blockquote>
<P>



instead.
<P>
<DT><B>HilightColorset [</B><I>num</I><B>]</B>

<DD>
This command is obsoleted by the
<B>Style</B>

option
<I>HilightColorset</I>.

Please use


<P>


<blockquote><PRE>Style * HilightColorset num</PRE></blockquote>
<P>



instead.
<P>
<DT><B>IconFont [</B><I>fontname</I><B>]</B>

<DD>
This command is obsoleted by the
<B>Style</B>

option
<I>IconFont</I>.

Please use


<P>


<blockquote><PRE>Style * IconFont fontname</PRE></blockquote>
<P>



instead.
<P>
<DT><B>IconPath </B><I>path</I>

<DD>
This command is obsolete.  Please use
<B>ImagePath</B>

instead.
<P>
<DT><B>ImagePath </B><I>path</I>

<DD>
Specifies a colon separated list of directories in which to search
for images (both monochrome and pixmap).  To find an image given
by a relative pathname, fvwm looks into each directory listed in
turn, and uses the first file found.
<P>
The
<I>path</I>

may contain environment variables such as
<I>$HOME</I> (or <I>${HOME}</I>).

Further, a '+' in the
<I>path</I>

is expanded to the previous value of the path, allowing appending
or prepending to the path easily.
<P>
For example:


<P>


<blockquote><PRE>ImagePath $HOME/icons:+:/usr/include/X11/bitmaps</PRE></blockquote>
<P>



Note: if the
<B>FvwmM4</B>

module is used to parse your
<I>.fvwm2rc</I>

files, then m4 may want to mangle the word &quot;include&quot; which
frequently shows up in the
<B>ImagePath</B>

command.  To fix this one may add


<P>


<blockquote><PRE>undefine(`include')</PRE></blockquote>
<P>



prior to the
<B>ImagePath</B>

command, or better: use the
<I>-m4-prefix</I>

option to force all
<B>m4</B>

directives to have a prefix of &quot;m4_&quot; (see the
<B>FvwmM4</B>

man page).
<P>
<DT><B>PixmapPath </B><I>path</I>

<DD>
This command is obsolete. Please use
<B>ImagePath</B>

instead.
<P>
<DT><B>WindowFont [</B><I>fontname</I><B>]</B>

<DD>
This command is obsoleted by the
<B>Style</B>

option
<I>Font</I>.

Please use


<P>


<blockquote><PRE>Style * Font fontname</PRE></blockquote>
<P>



instead.
<P>
<DT><B>WindowList [(</B> <I>conditions</I> <B>)] [</B> <I>position</I> <B>] [</B> <I>options</I> <B>] [</B> <I>double-click-action</I> <B>]</B><DD>
Generates a pop-up menu (and pops it up) in which the title and
geometry of each of the windows currently on the desktop are
shown.
<P>
The format of the geometry part is:
<I>desk</I>(<I>layer</I>): <I>x-geometry sticky</I>,

where
<I>desk</I> and <I>layer</I>

are the corresponding numbers and
<I>sticky</I>

is empty or a capital S.  The geometry of iconified windows is
shown in parentheses.  Selecting an item from the window list
pop-up menu causes the interpreted function &quot;WindowListFunc&quot; to be
run with the window id of that window passed in as $0. The default
&quot;WindowListFunc&quot; looks like this:


<P>


<blockquote><PRE>AddToFunc WindowListFunc
 + I WindowId $0 Iconify off
 + I WindowId $0 FlipFocus
 + I WindowId $0 Raise
 + I WindowId $0 WarpToWindow 5p 5p</PRE></blockquote>
<P>



You can destroy the builtin &quot;WindowListFunc&quot; and create your own
if these defaults do not suit you.
<P>
The window list menu uses the &quot;WindowList&quot; menu style if it is
defined (see
<B>MenuStyle</B>

command).  Otherwise the default menu style is used.  To switch
back to the default menu style, issue the command


<P>


<blockquote><PRE>DestroyMenuStyle WindowList</PRE></blockquote>
<P>



Example:


<P>


<blockquote><PRE>MenuStyle WindowList SelectOnRelease Meta_L</PRE></blockquote>
<P>



The
<I>conditions</I>

can be used to exclude certain windows from the window
list. Please refer to the
<B>Current</B>

command for details.  Only windows that match the given conditions
are displayed in the window list.  The
<I>options</I>

below work vice versa: windows that would otherwise not be
included in the window list can be selected with them.  The
<I>conditions</I>

always override the
<I>options</I>.

<P>
<P>
The
<I>position</I>

arguments are the same as for
<B>Menu</B>.

The command
<I>double-click-action</I>

is invoked if the user double-clicks (or hits the key rapidly
twice if the menu is bound to a key) when bringing the window
list.  The
<I>double-click-action</I>

must be quoted if it consists of more than one word.
<P>
The
<I>double-click-action</I>

is useful to define a default window if you have bound the window
list to a key (or button) like this:


<P>


<blockquote><PRE># Here we call an existing function, but it may be different
AddToFunc SwitchToWindow
+ I WindowListFunc $w

Key Tab A M WindowList &quot;Prev SwitchToWindow&quot;</PRE></blockquote>
<P>



Hitting
<FONT SIZE="-1">Alt-Tab</FONT>
once it brings up the window list, if you hit it twice the focus
is flipped between the current and the last focused window.  With
the proper
<I>SelectOnRelease</I>

menu style (see example above) a window is selected as soon as you
release the
<FONT SIZE="-1">Alt</FONT>
key.
<P>
The
<I>options</I>

passed to WindowList can be
<I>NoGeometry</I>,

<I>NoGeometryWithInfo</I>,

<I>Function funcname</I>,

<I>Desk desknum</I>,

<I>CurrentDesk</I>,

<I>NoIcons</I> / <I>Icons</I> / <I>OnlyIcons</I>,

<I>NoNormal</I> / <I>Normal</I> / <I>OnlyNormal</I>,

<I>NoSticky</I> / <I>Sticky</I> / <I>OnlySticky</I>,

<I>NoOnTop</I> / <I>OnTop</I> / <I>OnlyOnTop</I>,

<I>NoOnBottom</I> / <I>OnBottom</I> / <I>OnlyOnBottom</I>,

<I>Layer m [n]</I>,

<I>UseListSkip</I> / <I>OnlyListSkip</I>,

<I>NoDeskSort</I>,

<I>ReverseOrder</I>,

<I>UseIconName</I>,

<I>Alphabetic</I> / <I>NotAlphabetic</I>,

<I>NoHotkeys</I>,

<I>SelectOnRelease</I>.

<P>
(Note - normal means not iconic, sticky, or on top)
<P>
The
<I>SelectOnRelease</I>

option works exactly like the
<B>MenuStyle</B>

option with the same name, but overrides the option given in a
menu style.  By default, this option is set to the left
<FONT SIZE="-1">Alt</FONT>
key.  To switch it off, use
<I>SelectOnRelease</I>

without a key name.
<P>
If you pass in a function via
<I>Function funcname</I>,

$0 is the window id:


<P>


<blockquote><PRE>AddToFunc IFunc I WindowId $0 Iconify toggle
WindowList Function IFunc, NoSticky, \
  CurrentDesk, NoIcons</PRE></blockquote>
<P>



If you use the
<I>Layer m </I><B>[</B><I>n</I><B>]</B>

option, only windows in layers between m and n are displayed. n
defaults to m.  With the
<I>ReverseOrder</I>

option the order of the windows in the list is reversed.
<P>
If you wanted to use the
<B>WindowList</B>

as an icon manager, you could invoke the following:


<P>


<blockquote><PRE>WindowList OnlyIcons, Sticky, OnTop, Geometry</PRE></blockquote>
<P>



(Note - the
<I>Only</I>

options essentially wipe out all other ones... but the
<I>OnlyListSkip</I>

option which just causes
<B>WindowList</B>

to only consider the windows with
<I>WindowListSkip</I>

style.)
<P>
<DT><B>+</B>

<DD>
Used to continue adding to the last specified decor, function or
menu. See the discussion for
<B>AddToDecor</B>, <B>AddToFunc</B>, and <B>AddToMenu</B>.

<P>
<P>
</DL>
<A NAME="lbBG">&nbsp;</A>
<H3>COMMANDS AFFECTING WINDOW MOVEMENT AND PLACEMENT</H3>

<P>
<DL COMPACT>
<DT><B>AnimatedMove </B><I>x y</I><B> [</B><I>Warp</I><B>]</B>

<DD>
Move a window in an animated fashion.  Similar to
<B>Move</B>

command below. The options are the same, except they are required,
since it doesn't make sense to have a user move the window
interactively and animatedly.  If the optional argument
<I>Warp</I>

is specified the pointer is warped with the window.
<P>
<DT><B>HideGeometryWindow [</B><I>Never</I><B>|</B><I>Move</I><B>|</B><I>Resize</I><B>]</B>

<DD>
Hides the position or size window that is usually shown when a
window is moved or resized interactively.  To switch it off only
for move or resize operations the optional parameters
<I>Move</I> and <I>Resize</I>

can be used respectively.  To switch both on again use the
<I>Never</I>

option.
<P>
<DT><B>Layer [</B><I>arg1 arg2</I><B>] | [</B><I>default</I><B>]</B>

<DD>
Puts the current window in a new layer.  If
<I>arg1</I>

is non zero then the next layer is the current layer number plus
<I>arg1</I>.

If
<I>arg1</I>

is zero then the new layer is
<I>arg2</I>.

<P>
As a special case,
<I>default</I>

puts the window in its default layer, i.e. the layer it was
initially in.  The same happens if no or invalid arguments are
specified.
<P>
<DT><B>Lower</B>

<DD>
Allows the user to lower a window.  Note that this lowers a window
only in its layer.  To bring a window to the absolute bottom, use


<P>


<blockquote><PRE>AddToFunc lower-to-bottom
 + I Layer 0 0
 + I Lower</PRE></blockquote>
<P>



<P>
<DT><B>Move [[</B> <I>w</I> <B>|</B> <I>m</I> <B>]</B> <I>x</I> <B>[</B> <I>p</I> <B>] [</B> <I>w</I> <B>|</B> <I>m</I> <B>]</B> <I>y</I> <B>[</B> <I>p</I> <B>] [</B> <I>Warp</I> <B>]] | [</B> <I>pointer</I> <B>]</B><DD>
Allows the user to move a window.  If called from somewhere in a
window or its border, then that window is moved.  If called from
the root window then the user is allowed to select the target
window.  If the optional argument
<I>Warp</I>

is specified the pointer is warped with the window.  If the single
argument
<I>pointer</I>

is given, the top left corner of the window window is moved to the
pointer position before starting the operation; this is mainly
intended for internal use by modules like
<B>FvwmPager</B>.

<P>
The operation can be aborted with Escape or by pressing mouse
button 2. Pressing button 3 sets the
<I>PlacedByButton3</I>

condition (see
<B>Current</B>

command).
<P>
If the optional arguments
<I>x</I> and <I>y</I>

are provided, then the window is moved immediately without user
interaction.  Each argument can specify an absolute or relative
position from either the left/top or right/bottom of the screen.
By default, the numeric value given is interpreted as a percentage
of the screen width/height, but a trailing
'<I>p</I>'

changes the interpretation to mean pixels.  To move the window
relative to its current position, add the
'<I>w</I>'

(for &quot;window&quot;) prefix before the
<I>x</I> and/or <I>y</I>

value.  To move the window to a position relative to the current
location of the pointer, add the
'<I>m</I>'

(for &quot;mouse&quot;) prefix.  To leave either coordinate unchanged,
&quot;keep&quot; can be specified in place of
<I>x</I> or <I>y</I>.

<P>
Simple Examples:


<P>


<blockquote><PRE># Interactive move
Mouse 1 T A Move
# Move window so top left is at (10%,10%)
Mouse 2 T A Move 10 10
# Move top left to (10pixels,10pixels)
Mouse 3 T A Move 10p 10p</PRE></blockquote>
<P>



More complex examples (these can be bound as actions to
keystrokes, etc.; only the command is shown, though):


<P>


<blockquote><PRE># Move window so bottom right is at bottom
# right of screen
Move -0 -0

# Move window 5% to the right, and to the
# middle vertically
Move w+5 50

# Move window up 10 pixels, and so left edge
# is at x=40 pixels
Move 40p w-10p

# Move window to the mouse pointer location
#
Move m+0 m+0</PRE></blockquote>
<P>



See also the
<B>AnimatedMove</B>

command above.
<P>
<DT><B>MoveToDesk </B><I>prev</I><B> | </B><I>arg1</I><B> [</B><I>arg2</I><B>] [</B><I>min max</I><B>]</B>

<DD>
Moves the selected window to another desktop.  The arguments are
the same as for the
<B>GotoDesk</B>

command.
<B>MoveToDesk</B>

is a replacement for the old
<B>WindowsDesk</B>

command, which can no longer be used.
<P>
<DT><B>MoveThreshold [</B><I>pixels</I><B>]</B>

<DD>
When the user presses a mouse button upon an object fvwm waits to
see if the action is a click or a drag.  If the mouse moves by
more than
<I>pixels</I>

pixels it is assumed to be a drag.
<P>
Previous versions of fvwm hardwired
<I>pixels</I>

to 3, which is now the default value.  If
<I>pixels</I>

is negative or omitted the default value (which might be increased
when 16000x9000 pixel displays become affordable) is restored.
<P>
<DT><B>MoveToPage [</B> <I>x</I> <B>[</B> <I>p</I> <B>]</B> <I>y</I> <B>[</B> <I>p</I> <B>]] | [</B><I>prev</I> <B>]</B><DD>
Moves the selected window to another page (x,y).  The upper left
page is (0,0), the upper right is (M,0), where M is one less than
the current number of horizontal pages specified in the
<B>DeskTopSize</B>

command.  Similarly the lower left page is (0,N), and the lower
right page is (M,N).  Negative page numbers refer to pages from
the rightmost/lowest page.  If
<I>x</I> and <I>y</I>

are not given, the window is moved to the current page (a window
that has the focus but is off-screen can be retrieved with this).
Moving windows to a page relative to the current one can be
achieved by adding a trailing
'<I>p</I>'

after any or both numerical arguments.  To move a window to the
previous page use
<I>prev</I>

as the single argument.  Using MoveToPage on a sticky window makes
the window non-sticky (see
<B>Stick</B>

command).
<P>
Examples:


<P>


<blockquote><PRE># Move window to page (2,3)
MoveToPage 2 3

# Move window to lowest and rightmost page
MoveToPage -1 -1

# Move window to last page visited
MoveToPage prev

# Move window two pages to the right and one
# page up
MoveToPage +2p -1p</PRE></blockquote>
<P>



<P>
<DT><B>MoveToScreen [ </B><I>screen</I><B> ]</B>

<DD>
Moves the selected window to another Xinerama screen.  The
<I>screen</I>

argument can be 'p' for the primary screen, 'c' for the current
screen (containing the mouse pointer), 'g' for the global screen
or the screen number itself (counting from zero).
<P>
<DT><B>OpaqueMoveSize [</B><I>percentage</I><B>]</B>

<DD>
Tells fvwm the maximum size window with which opaque window
movement should be used.  The percentage is percent of the total
screen area (may be greater than 100).  With


<P>


<blockquote><PRE>OpaqueMoveSize 0</PRE></blockquote>
<P>



all windows are moved using the traditional rubber-band
outline. With


<P>


<blockquote><PRE>OpaqueMoveSize unlimited</PRE></blockquote>
<P>



or if a negative percentage is given
all windows are moved as solid windows.  The default is


<P>


<blockquote><PRE>OpaqueMoveSize 5</PRE></blockquote>
<P>



which allows small windows to be moved in an opaque manner but
large windows are moved as rubber-bands.  If
<I>percentage</I>

is omitted or invalid the default value is set.  To resize windows
in an opaque manner you can use the
<I>ResizeOpaque</I>

style.  See
<B>Style</B>

command.
<P>
<DT><B>PlaceAgain [</B><I>Anim</I><B>]</B>

<DD>
Causes the current window's position to be re-computed using the
initial window placement logic.  The window is moved to where it
would have been if it were a new window that had just appeared.
Most useful with
<I>Smart</I> or <I>Clever</I> (<I>ReallySmart</I>)

placement.  If the optional argument
<I>Anim</I>

is specified, an animated move is used to place the window in its
new position.
<P>
<DT><B>Raise</B>

<DD>
Allows the user to raise a window. Note that this raises a window
only in its layer. To bring a window to the absolute top, use


<P>


<blockquote><PRE>AddToFunc raise-to-top
 + I Layer 0 ontop
 + I Raise</PRE></blockquote>
<P>



where ontop is the highest layer used in your setup.
<P>
<DT><B>RaiseLower</B>

<DD>
Alternately raises and lowers a window.  The window is raised if
it is obscured by any window (except for its own transients when
<I>RaiseTransient</I>

style is used; see
<B>Style</B>

command) otherwise it is lowered.
<P>
<DT><B>Resize [</B> <I>width</I> <B>[</B> <I>p</I> <B>|</B> <I>c</I> <B>]</B> <I>height</I> <B>[</B> <I>p</I> <B>|</B> <I>c</I> <B>]] | [</B> <I>bottomright</I> <B>|</B> <I>br x y</I> <B>]</B><DD>
Allows to resize a window.  If called from somewhere in a window
or its border, then that window is resized.  If called from the
root window then the user is allowed to select the target window.
<P>
The operation can be aborted with Escape or by pressing any mouse
button (except button 1 which confirms it).
<P>
If the optional arguments
<I>width</I> and <I>height</I>

are provided, then the window is resized so that its dimensions
are
<I>width</I> by <I>height</I>.

The units of
<I>width</I> and <I>height</I>

are percent-of-screen, unless a letter
'<I>p</I>'

is appended to one or both coordinates, in which case the location
is specified in pixels.  With a
'<I>c</I>'

suffix the unit defined by the client application (hence the c) is
used.  So you can say


<P>


<blockquote><PRE>Resize 80c 24c</PRE></blockquote>
<P>



to make a terminal window just big enough for 80x24
characters. Both,
<I>width</I> and <I>height</I>

can be negative.  In this case the new size is the screen size
minus the given value.  If either value is &quot;keep&quot;, the
corresponding dimension of the window is left untouched.
<P>
An alternate syntax is used if the keyword
<I>bottomright</I> or in short <I>br</I>

follows the command name.  In this case, the arguments
<I>x</I> and <I>y</I>

specify the desired position of the bottom right corner of the
window.  They are interpreted exactly like the
<I>x</I> and <I>y</I>

arguments of the
<B>Move</B>

command.
<P>
<DT><B>ResizeMove </B><I>resize-arguments move-arguments</I>

<DD>
This command does the same as the
<B>Resize</B> and <B>Move</B>

commands, but in a single call which is less visually
disturbing. The
<I>resize-arguments</I>

are exactly the same arguments as for the
<B>Resize</B>

command and the
<I>move-arguments</I>

are exactly the same arguments as for the
<B>Move</B>

command except the
<I>pointer</I>

option which is not supported by the
<B>ResizeMove</B>

command.
<P>
Example:


<P>


<blockquote><PRE># Move the window to the top left corner
ResizeMove w+0 -10p 0 -20p</PRE></blockquote>
<P>



<P>
<DT><B>SetAnimation </B><I>milliseconds-delay</I><B> [</B><I>fractions-to-move-list</I><B>]</B>

<DD>
Sets the time between frames and the list of fractional offsets to
customize the animated moves of the
<B>AnimatedMove</B>

command and the animation of menus (if the menu style is set to
animated; see
<B>MenuStyle</B>

command).  If the
<I>fractions-to-move-list</I>

is omitted, only the time between frames is altered.  The
<I>fractions-to-move-list</I>

specifies how far the window should be offset at each successive
frame as a fraction of the difference between the starting
location and the ending location.  e.g.:


<P>


<blockquote><PRE>SetAnimation 10 -.01 0 .01 .03 .08 .18 .3 \
  .45 .6 .75 .85 .90 .94 .97 .99 1.0</PRE></blockquote>
<P>



Sets the delay between frames to 10 milliseconds, and sets the
positions of the 16 frames of the animation motion.  Negative
values are allowed, and in particular can be used to make the
motion appear more cartoonish, by briefly moving slightly in the
opposite direction of the main motion.  The above settings are the
default.
<P>
<DT><B>SnapAttraction [</B> <I>proximity</I> <B>[</B> <I>behavior</I> <B>] [</B> <I>Screen</I> <B>]]</B><DD>
If during an interactive move the window or icon comes within
<I>proximity</I>

pixels of another the window or icon, it is moved to make the
borders adjoin.  The default of 0 means that no snapping happens.
Calling this command without arguments turns off snap attraction
and restores the default behavior.  Please refer also to the
<B>SnapGrid</B>

command.
<P>
The
<I>behavior</I>

argument is optional and may be set to one of the four following
values:  With
<I>All</I>

both icons and windows snap to other windows and other icons.
<I>SameType</I>

lets snap windows only to other windows and icons only to other
icons. With
<I>Windows</I>

windows snap only to other windows.  Icons do not snap. Similarly
with
<I>Icons</I>

icons snap to only other icons and windows do not snap.
<P>
If the
<I>behavior</I>

option is not given, the snapping behavior is not changed.  The
default behavior is
<I>All</I>.

<P>
If the
<I>Screen</I>

option is present windows and or icons are snapped to the screen
edges too.
<P>
<DT><B>SnapGrid [</B><I>x-grid-size y-grid-size</I><B>]</B>

<DD>
During an interactive move a window or icon is positioned such
that its location (top left corner) is coincident with the nearest
grid point. The default
<I>x-grid-size</I> and <I>y-grid-size</I>

setting are both 1, which is effectively no grid all.  An
interactive move with both
<B>SnapGrid</B> and <B>SnapAttraction</B>

results in the window being moved to be adjacent to the nearest
window border (if within snap proximity) or grid position.  In
other words, the window moves the shortest distance possible to
satisfy both
<B>SnapGrid</B> and <B>SnapAttraction</B>.

Note that the x and y coordinates are not coupled.  For example, a
window may snap to another window on the x axis while snapping to
a grid point on the y axis.  Calling this command without
arguments reinstates the default settings.
<P>
<DT><B>WindowsDesk </B><I>arg1</I><B> [</B><I>arg2</I><B>]</B>

<DD>
Moves the selected window to another desktop.
<P>
This command has been removed and must be replaced by
<B>MoveToDesk</B>,

the arguments for which are the same as for the
<B>GotoDesk</B>

command.
<B>Important note:</B>

You cannot simply change the name of the command: the syntax has
changed.  If you used


<P>


<blockquote><PRE>WindowsDesk n</PRE></blockquote>
<P>



to move a window to desk n, you have to change it to


<P>


<blockquote><PRE>MoveToDesk 0 n</PRE></blockquote>
<P>



<P>
<DT><B>XorPixmap [</B><I>pixmap</I><B>]</B>

<DD>
Selects the pixmap with which bits are xor'ed when doing
rubber-band window moving or resizing.  This has a better chance
of making the rubber-band visible if
<B>XorValue</B>

does not give good results.  An example pixmap
<I>resize.rainbow.xpm</I>

is provided with the icon distribution.  To turn the
<B>XorPixmap</B>

off again use the
<B>XorValue</B>

command or omit the
<I>pixmap</I>

argument.
<P>
<DT><B>XorValue [</B><I>number</I><B>]</B>

<DD>
Changes the value with which bits are xor'ed when doing
rubber-band window moving or resizing.  Setting this value is a
trial-and-error process.  The default value 0 tries to find a
value that gives a good contrast to black and white.  It is set if
the given
<I>number</I>

is omitted or invalid.
<P>
<P>
</DL>
<A NAME="lbBH">&nbsp;</A>
<H3>COMMANDS FOR FOCUS AND MOUSE MOVEMENT</H3>

<P>
<DL COMPACT>
<DT><B>CursorMove </B><I>horizontal</I><B>[</B><I>p</I><B>] </B><I>vertical</I><B>[</B><I>p</I><B>]</B>

<DD>
Moves the mouse pointer by
<I>horizontal</I>

pages in the X direction and
<I>vertical</I>

pages in the Y direction.  Either or both entries may be
negative. Both horizontal and vertical values are expressed in
percent of pages, so


<P>


<blockquote><PRE>CursorMove 100 100</PRE></blockquote>
<P>



means to move down and right by one full page.


<P>


<blockquote><PRE>CursorMove 50 25</PRE></blockquote>
<P>



means to move right half a page and down a quarter of a
page. Alternatively, the distance can be specified in pixels by
appending a
'<I>p</I>'

to the horizontal and/or vertical specification.  For example


<P>


<blockquote><PRE>CursorMove -10p -10p</PRE></blockquote>
<P>



means move ten pixels up and ten pixels left.  The CursorMove
function should not be called from pop-up menus.
<P>
<DT><B>FlipFocus  [</B><I>NoWarp</I><B>]</B>

<DD>
Executes a
<B>Focus</B>

command as if the user had used the pointer to select the
window. This command alters the order of the WindowList in the
same way as clicking in a window to focus, i.e. the target window
is removed from the
<B>WindowList</B>

and placed at the start. This command is recommended for use with
the
<B>Direction</B>

command and in the function invoked from
<B>WindowList</B>.

<P>
<DT><B>Focus  [</B><I>NoWarp</I><B>]</B>

<DD>
Sets the keyboard focus to the selected window.  If the
<I>NoWarp</I>

argument is given, this is all it does.  Otherwise it also moves
the viewport or window as needed to make the selected window
visible. This command does not automatically raise the
window. Does not warp the pointer into the selected window (see
<B>WarpToWindow</B>

function).  Does not de-iconify.  This command does not alter the
order of the
<B>WindowList</B>,

it rotates the
<B>WindowList</B>

around so that the target window is at the start.
<P>
When the
<I>NoWarp</I>

argument is given, Focus cannot transfer the keyboard focus to
windows on other desks.
<P>
To raise and/or warp a pointer to a window together with
<B>Focus</B> or <B>FlipFocus</B>,

use a function, like:


<P>


<blockquote><PRE>AddToFunc SelectWindow
+ I Focus
+ I Iconify false
+ I Raise
+ I WarpToWindow 50 8p</PRE></blockquote>
<P>



<P>
<DT><B>WarpToWindow </B><I>x</I><B>[</B><I>p</I><B>] </B><I>y</I><B>[</B><I>p</I><B>]</B>

<DD>
Warps the cursor to the associated window.  The parameters
<I>x</I> and <I>y</I>

default to percentage of window down and in from the upper left
hand corner (or number of pixels down and in if
'<I>p</I>'

is appended to the numbers).  If a number is negative the opposite
edge is used and the direction reversed.  This command works also
with windows that are not managed by fvwm.  In this case fvwm does
not bring the window onto the screen if it is not visible.  For
example it is possible to warp the pointer to the center of the
root window on screen 1:


<P>


<blockquote><PRE>WindowId root 1 WarpToWindow 50 50</PRE></blockquote>
<P>



<P>
<P>
</DL>
<A NAME="lbBI">&nbsp;</A>
<H3>COMMANDS CONTROLLING WINDOW STATE</H3>

<P>
<DL COMPACT>
<DT><B>Close</B>

<DD>
If the window accepts the delete window protocol a message is sent
to the window asking it to gracefully remove itself.  If the
window does not understand the delete window protocol then the
window is destroyed as with the
<B>Destroy</B>

command.  Note: if the window accepts the delete window protocol
but does not close itself in response, the window is not deleted.
<P>
<DT><B>Delete</B>

<DD>
Sends a message to a window asking that it remove itself,
frequently causing the application to exit.
<P>
<DT><B>Destroy</B>

<DD>
Destroys an application window, which usually causes the
application to crash and burn.
<P>
<DT><B>Iconify [</B><I>bool</I><B>]</B>

<DD>
Iconifies a window if it is not already iconified or de-iconifies
it if it is already iconified.  The optional argument
<I>bool</I>

is a boolean argument.  &quot;True&quot; means only iconification is
allowed, while &quot;False&quot; forces de-iconification.  Using &quot;toggle&quot;
switches between iconified and de-iconified states.
<P>
There are a number of
<B>Style</B>

options which influence the appearance and behavior of icons (e.g.
<I>StickyIcon</I>, <I>NoIcon</I>).

<P>
For backwards compatibility, the optional argument may also be a
positive number instead of &quot;True&quot;, or a negative number instead of
&quot;False&quot;.  Note that this syntax is obsolete, and will be removed
in the future.
<P>
<DT><B>Maximize [</B> <I>screen screen-spec</I> <B>] [</B> <I>horizontal</I> <B>] [</B> <I>bool</I> <B>[</B> <I>p</I> <B>]</B> <I>vertical</I> <B>[</B> <I>p</I> <B>]]</B><DD>
Without its optional arguments (or if the
<I>bool</I>

bit has the value &quot;toggle&quot;)
<B>Maximize</B>

causes the window to alternately switch from a full-screen size to
its normal size.  To force a window into maximized (normal) state
you can use a &quot;True&quot; or &quot;False&quot; value for the
<I>bool</I>

argument.
<P>
With the optional arguments
<I>horizontal</I> and <I>vertical</I>,

which are expressed as percentage of a full screen, the user can
control the new size of the window.  An optional suffix
'<I>p</I>'

can be used to indicate pixels instead of percents of the screen
size.  If horizontal is greater than 0 then the horizontal
dimension of the window is set to
<I>horizontal</I>*screen_width/100.

If the value is smaller than 0 the size is subtracted from the
screen width, i.e. -25 is the same as 75.  If
<I>horizontal</I>

is &quot;grow&quot;, it is maximized to current available space until
finding any obstacle.  The vertical resizing is similar.  If both
horizontal and vertical values are &quot;grow&quot;, it expands vertically
first, then horizontally to find space.  Instead of the horizontal
&quot;grow&quot; argument, &quot;growleft&quot; or &quot;growright&quot; can be used
respectively &quot;growup&quot; and &quot;growdown&quot;.  For example, the following
adds a title-bar button to switch a window to the full vertical
size of the screen:


<P>


<blockquote><PRE>Mouse 0 4 A Maximize 0 100</PRE></blockquote>
<P>



The following causes windows to be stretched to the full width:


<P>


<blockquote><PRE>Mouse 0 4 A Maximize 100 0</PRE></blockquote>
<P>



This makes a window that is half the screen size in each
direction:


<P>


<blockquote><PRE>Mouse 0 4 A Maximize 50 50</PRE></blockquote>
<P>



To expand a window horizontally until any other window is found:


<P>


<blockquote><PRE>Mouse 0 4 A Maximize 0 grow</PRE></blockquote>
<P>



To expand a window but leave the lower 60 pixels of the screen
unoccupied


<P>


<blockquote><PRE>Mouse 0 4 A Maximize 100 -60p</PRE></blockquote>
<P>



Values larger than 100 can be used with caution.
<P>
If the first argument is the word
<I>screen</I>,

the
<I>screen-spec</I>

argument specifies the Xinerama screen on which to operate.
It can be 'p' for the primary screen, 'c' for the current
screen (containing the mouse pointer), 'g' for the global screen
or the screen number itself (counting from zero).  This option is
only useful with multiple Xinerama screens.
<P>
<DT><B>Recapture</B>

<DD>
Causes fvwm to recapture all of its windows.  This ensures that
the latest style parameters are used.  The recapture operation is
visually disturbing.
<P>
Since fvwm version 2.4 only a very few
<B>Style</B>

options need a
<B>Recapture</B>

to take effect (e.g.
<I>UseStyle</I>).

<P>
<DT><B>RecaptureWindow</B>

<DD>
Causes fvwm to recapture the chosen window.  See
<B>Recapture</B>

command above.
<P>
<DT><B>Refresh</B>

<DD>
Causes all windows on the screen to redraw themselves. All pending
updates of all windows' styles and looks are applied immediately.
E.g. if
<B>Style</B> or <B>TitleStyle</B>

commands were issued inside a fvwm function.
<P>
<DT><B>RefreshWindow</B>

<DD>
Causes the chosen window to redraw itself. All pending updates of
the window's style and looks are applied immediately.  E.g. if
<B>Style</B> or <B>TitleStyle</B>

commands were issued inside a fvwm function.
<P>
<DT><B>Stick [</B><I>bool</I><B>]</B>

<DD>
If the
<I>bool</I>

argument is empty or &quot;toggle&quot;, the
<B>Stick</B>

command makes a window sticky if it is not already sticky, or
non-sticky if it is already sticky.  To make a window sticky
regardless of its current state the
<I>bool</I>

argument must be &quot;True&quot;.  To make it non-sticky use &quot;False&quot;.
<P>
<DT><B>WindowShade [</B><I>bool</I><B>]</B>

<DD>
Toggles the window shade feature for titled windows.  Windows in
the shaded state only display a title-bar.  If
<I>bool</I>

is not given or &quot;toggle&quot;, the window shade state is toggled.  If
<I>bool</I>

is &quot;True&quot;, the window is forced to the shaded state. If
<I>bool</I>

is &quot;False&quot;, then the window is forced to the non-shaded
state. Windows without titles can be shaded too.  See also
<I>WindowShadeSteps</I>

option of the
<B>Style</B>

command.
<P>
For backwards compatibility, the optional argument may also be 1
to signify &quot;on&quot;, and 2 to signify &quot;off&quot;. Note that this syntax is
obsolete, and will be removed in the future.
<P>
<DT><B>WindowShadeAnimate  [</B><I>steps</I><B>[</B><I>p</I><B>]]</B>

<DD>
This command is obsolete.  Please use the
<I>WindowShadeSteps</I>

option of the
<B>Style</B>

command instead.
<P>
<P>
</DL>
<A NAME="lbBJ">&nbsp;</A>
<H3>COMMANDS FOR MOUSE, KEY AND STROKE BINDINGS</H3>

<P>
<DL COMPACT>
<DT><B>IgnoreModifiers [</B><I>Modifiers</I><B>]</B>

<DD>
Tells fvwm which modifiers to ignore when matching Mouse or Key
bindings.
<B>IgnoreModifiers</B>

affects the
<I>ClickToFocus</I>

style too.  This command belongs into your
<I>.fvwm2rc</I>.

If you issue it when your fvwm session is already up and running
the results are unpredictable.  The should appear before any
applications or modules are started in your
<I>.fvwm2rc</I>

file (e.g. with the
<B>Exec</B>

command).
<P>
<I>Modifiers</I>

has the same syntax as in the
<B>Mouse</B> or <B>Key</B>

bindings, with the addition of 'L' meaning the
<FONT SIZE="-1">caps lock</FONT>
key.  The default is &quot;L&quot;.
<I>Modifiers</I>

can be omitted, meaning no modifiers are ignored.  This command
comes in handy if the
<FONT SIZE="-1">num-lock</FONT>
and
<FONT SIZE="-1">scroll-lock</FONT>
keys interfere with your shortcuts.  With XFree86 '2' usually is
the
<FONT SIZE="-1">num-lock</FONT>
modifier and '5' refers to the
<FONT SIZE="-1">scroll-lock</FONT>
key. To turn all these pesky modifiers off you can use this
command:


<P>


<blockquote><PRE>IgnoreModifiers L25</PRE></blockquote>
<P>



<I>Important Note:</I>

This command creates a lot of extra network traffic, depending on
your CPU, network connection, the number of
<B>Key</B> or <B>Mouse</B>

commands in you configuration file and the number of modifiers you
want to ignore.  If you do not have a lightning fast machine or
very few bindings you should not ignore more than two modifiers.
I.e. do not ignore
<FONT SIZE="-1">scroll-lock</FONT>
if you have no problem with it.  In the
<I>FAQ</I>

you can find a better solution of this problem.
<P>
<DT><B>GnomeButton</B>

<DD>
Used in conjunction with
<B>Mouse</B>

to pass mouse button presses on the root window to a
<FONT SIZE="-1">GNOME</FONT>
program (such as GMC).  The following example passes presses of
mouse buttons 1 and 3 to such a program.


<P>


<blockquote><PRE>Mouse 1 R A GnomeButton
Mouse 3 R A GnomeButton</PRE></blockquote>
<P>



<P>
<DT><B>Key </B><I>Keyname Context Modifiers Function</I>

<DD>
Binds a keyboard key to a specified fvwm built-in function, or
removes the binding if
<I>Function</I>

is '-'.  The syntax is the same as for a
<B>Mouse</B>

binding except that the mouse button number is replaced with a
<I>Keyname</I>.

The
<I>Keyname</I>

is one of the entries from
<I>/usr/include/X11/keysymdef.h</I>,

with the leading XK_ omitted.  The
<I>Context</I> and <I>Modifiers</I>

fields are defined as in the
<B>Mouse</B>

binding.  However, when you press a key the context window is the
window that has the keyboard focus.  That is not necessarily the
same as the window the pointer is over (with
<I>SloppyFocus</I> or <I>ClickToFocus</I>).

Note that key bindings with the 'R' (root window) context do not
work properly with
<I>SloppyFocus</I> and <I>ClickToFocus</I>.

If you encounter problems, use the
<B>PointerKey</B>

command instead.  If you want to bind keys to a window with
<I>SloppyFocus</I> or <I>ClickToFocus</I>

that are supposed to work when the pointer is not over the window,
fvwm assumes the pointer is over the client window (i.e. you have
to use the 'W' modifier).
<P>
The following example binds the built in window list to pop up
when
<FONT SIZE="-1">Alt-Ctrl-Shift-F11</FONT>
is hit, no matter where the mouse pointer is:


<P>


<blockquote><PRE>Key F11 A SCM WindowList</PRE></blockquote>
<P>



Binding a key to a title-bar button causes that button to appear.
Please refer to the
<B>Mouse</B>

command for details.
<P>
<DT><B>Mouse </B><I>Button Context Modifiers Function</I>

<DD>
Defines a mouse binding, or removes the binding if
<I>Function</I>

is '-'.
<I>Button</I>

is the mouse button number.  If
<I>Button</I>

is zero then any button performs the specified function.
<I>Context</I>

describes where the binding applies.  Valid contexts are 'R' for
the root window, 'W' for an application window, 'T' for a window
title-bar, 'S' for a window side, top, or bottom bar, 'F' for a
window frame (the corners), 'I' for an Icon window, or '0' through


instance, a context of &quot;FST&quot; applies when the mouse is anywhere in
a window's border except the title-bar buttons.  Only 'S' and 'W'
are valid for an undecorated window.
<P>
<I>Modifiers</I>

is any combination of 'N' for no modifiers, 'C' for control, 'S'
for shift, 'M' for Meta, 'L' for Caps-Lock or 'A' for any
modifier. For example, a modifier of &quot;SM&quot; applies when both the
<FONT SIZE="-1">Meta</FONT>
and
<FONT SIZE="-1">Shift</FONT>
keys are down.  X11 modifiers mod1 through mod5 are represented as
the digits '1' through '5'.  The modifier 'L' is ignored by
default.  To turn it on, use the
<B>IgnoreModifiers</B>

command.
<P>
<I>Function</I>

is one of fvwm's built-in functions.
<P>
The title-bar buttons are numbered with odd numbered buttons on
the left side of the title-bar and even numbers on the
right. Smaller-numbered buttons are displayed toward the outside
of the window while larger-numbered buttons appear toward the
middle of the window (0 is short for 10).  In summary, the buttons
are numbered:


<P>


<blockquote><PRE>1 3 5 7 9    0 8 6 4 2</PRE></blockquote>
<P>



The highest odd numbered button which has an action bound to it
determines the number of buttons drawn on the left side of the
title bar.  The highest even number determines the number or right
side buttons which are drawn.  Actions can be bound to either
mouse buttons or keyboard keys.
<P>
<DT><B>PointerKey </B><I>Keyname Context Modifiers Function</I>

<DD>
This command works exactly like the
<B>Key</B>

command.  The only difference is that the binding operates on the
window under the pointer.  Normal key bindings operate on the
focused window instead.  The
<B>PointerKey</B>

command can for example be used to bind keys to the root window if
you are using
<I>SloppyFocus</I> or <I>ClickToFocus</I>.

However, some applications (xterm is one example) are unable to
handle this key anymore, even if the pointer is over the xterm
window.  It is recommended to use the
<B>PointerKey</B>

command only for key combinations that are not needed in any
application window.
<P>
Example:


<P>


<blockquote><PRE>Style * SloppyFocus
PointerKey f1 a m Menu MainMenu</PRE></blockquote>
<P>



<P>
<DT><B>Stroke </B><I>Sequence Button Context Modifiers Function</I>

<DD>
Binds a mouse stroke sequence to a specified fvwm built-in
function, or removes the binding if
<I>Function</I>

is '-'.  The syntax is the same as for a
<B>Mouse</B>

binding except that
<I>Sequence</I>

is inserted in front of the button number and a value of 0 for
<I>Button</I>

concerns the
<B>StrokeFunc</B>

command.  The
<I>Context</I> and <I>Modifiers</I>

fields are defined as in the
<B>Mouse</B>

binding.  However, only the 'R' Context really works (if you want
to use other contexts you need to use the
<B>StrokeFunc</B>

below).
<P>
Strokes sequences are defined in a telephone grid like this:


<P>


<blockquote><PRE> 1  2  3

 4  5  6

 7  8  9</PRE></blockquote>
<P>



or in a numeric pad grid like this:


<P>


<blockquote><PRE> 7  8  9

 4  5  6

 1  2  3</PRE></blockquote>
<P>



The telephone grid is used by default, to use the numeric pad grid
you should begin the sequence with a 'N'.  Note that a complex
motion may gives several different sequences (see the &quot;netscape&quot;
example below to handle such motion).  Moreover, sequence are
limited to 20 elements (with the present version of
<B>libstroke</B>),

however, in practice it is preferable to use sequence with less
than 12 elements.
<P>
Because of the default button menu in fvwm, you may need to remove
a mouse button binding (using an empty action) before using the
stroke


<P>


<blockquote><PRE>Mouse 3 R N</PRE></blockquote>
<P>



Also, you can still use the stroke &quot;sequence 0&quot; to simulate a
click:


<P>


<blockquote><PRE>Stroke 0 3 R N Menu WindowList Nop</PRE></blockquote>
<P>



The following example starts xterm when the mouse drags an 'I' on
the root window with button 3 pressed down:


<P>


<blockquote><PRE>Stroke 258  3  R  N  Exec exec xterm</PRE></blockquote>
<P>



An example for Netscape:


<P>


<blockquote><PRE>Stroke 7415963    3  R  N  Exec exec netscape
Stroke 74148963   3  R  N  Exec exec netscape
Stroke 74158963   3  R  N  Exec exec netscape
Stroke 7418963    3  R  N  Exec exec netscape
Stroke 415963     3  R  N  Exec exec netscape</PRE></blockquote>
<P>



You may prefer to use the numeric pad grid since you have such a
grid on your machine. Here an example:


<P>


<blockquote><PRE>Stroke N78963314   3  R  N  FvwmForm FvwmForm-QuitVerify
Stroke N789633147  3  R  N  FvwmForm FvwmForm-QuitVerify</PRE></blockquote>
<P>



This example starts the &quot;QuitVerify&quot; form if you draw a box that
begins in the top left corner.
<P>
Note: You need
<B>libstroke</B>

installed and fvwm compiled with stroke support.
<B>libstroke</B>

can be obtained at


<P>


<blockquote><PRE><B><A HREF="http://www.etla.net/~willey/projects/libstroke/">http://www.etla.net/~willey/projects/libstroke/</A></B></PRE></blockquote>
<P>



<P>
<DT><B>StrokeFunc [</B><I>Options</I><B>]</B>

<DD>
Causes fvwm to record a mouse stroke sequence and to execute the
corresponding action as defined in a
<B>Stroke</B>

command.  The cursor is modified to the
<I>STROKE</I>

context of the
<B>CursorStyle</B>

command during recording.  When the stroke is finished
<B>StrokeFunc</B>

looks for a stroke binding of the form


<P>


<blockquote><PRE>Stroke sequence 0 Context Modifiers action</PRE></blockquote>
<P>



and executes the corresponding action (Note the 0).  Normal use of this
function is via a
<B>Mouse</B> or <B>Key</B>

command.  Examples:


<P>


<blockquote><PRE>Mouse 3 A M StrokeFunc
Key x R N StrokeFunc</PRE></blockquote>
<P>



If you press mouse button 3 and
<FONT SIZE="-1">Alt</FONT>
anywhere (respectively, press the key x when the cursor is on the
root window), then fvwm records the mouse motions until the mouse
button 3 (respectively, the x key) is released and then check if
the recorded
<I>sequence</I>

corresponds to a stroke binding of the form


<P>


<blockquote><PRE>Stroke <I>sequence</I> 0 A M <I>action</I> 
Stroke <I>sequence</I> 0 R N <I>action</I> </PRE></blockquote>
<P>



Note that the
<I>Context</I> and <I>Modifiers</I>

are taken at the beginning of the execution of the
<B>StrokeFunc</B>

command (so you can release the modifiers before the end of the
stroke recording in the case of a mouse binding and if you used,
say, a title-bar context the mouse motion can go through an
application window).  The keys
<FONT SIZE="-1">Escape</FONT>
and
<FONT SIZE="-1">Delete</FONT>
allow you to abort the command.
<P>
The
<B>StrokeFunc</B>

command has five options:
<I>NotStayPressed</I>, <I>EchoSequence</I>, <I>DrawMotion</I>, <I>FeedBack</I> and <I>StrokeWidth.</I>

These options are disabled by default.
<I>EchoSequence</I>

causes fvwm to Echo the recorded stroke sequence.
<I>DrawMotion</I>

causes fvwm to draw the mouse motion on the screen.
<I>FeedBack</I>

causes fvwm to display during a fraction of second the cursor of the
<I>WAIT</I>

context of the
<B>CursorStyle</B>

command if the recorded stroke sequence corresponds to a stroke
binding.
<I>StrokeWidth</I>

takes an integer argument, which must be  &gt;= 0 and &lt;= 100 and
which defines the width of the line for the
<I>DrawMotion option.</I>

<P>
<I>NotStayPressed</I>

works only if
<B>StrokeFunc</B>

is used via a
<B>Mouse</B>

or a
<B>Key</B>

command.  This option removes the need to have a button or the key
pressed during the stroke, but you have to do a mouse click or
press the
<FONT SIZE="-1">Return</FONT>
or
<FONT SIZE="-1">Space</FONT>
key to finish the mouse motion recording (these keys also work
without the
<I>NotStayPressed</I>

option).
<P>
You can use the
<B>StrokeFunc</B>

&quot;alone&quot;.  In this case it works as above with the
<I>NotStayPressed</I>

option enabled.  However,
<I>Modifiers,</I>

in general, may not work as expected (i.e., in this case use 'A'
or 'N' as
<I>Modifiers</I>

in the stroke bindings).
<P>
Note that some computers do not support key release events. If
that is the case the
<B>StrokeFunc</B>

used via a
<B>Key</B>

command works as if the
<I>NotStayPressed</I>

option is enabled.
<P>
<P>
</DL>
<A NAME="lbBK">&nbsp;</A>
<H3>THE STYLE COMMAND (CONTROLLING WINDOW STYLES)</H3>

<P>
<DL COMPACT>
<DT><B>UpdateStyles</B>

<DD>
All pending updates of all windows' styles and looks are applied
immediately.  E.g. if
<B>Style</B> or <B>TitleStyle</B>

commands were issued inside a fvwm function.
<P>
<DT><B>Style </B><I>stylename options</I>

<DD>
This command is intended to replace the old fvwm 1.xx global
commands NoBorder, NoTitle, StartsOnDesk, Sticky, StaysOnTop,
Icon, WindowListSkip, CirculateSkip, SuppressIcons, BoundaryWidth,
NoBoundaryWidth, StdForeColor, and StdBackColor with a single
flexible and comprehensive window specific command.  This command
is used to set attributes of a window to values other than the
default or to set the window manager default styles.
<P>
<I>stylename</I>

can be a window's name, class, or resource string.  It may contain
the wildcards '*' and '?', which are matched in the usual Unix
filename manner.  They are searched in the reverse order
stated. When two conflicting styles apply to the same window, the
style that was changed last wins.
<P>
Note: windows that have no name (WM_NAME) are given a name of
&quot;Untitled&quot;, and windows that don't have a class (WM_CLASS,
res_class) are given class &quot;NoClass&quot; and those that don't have a
resource (WM_CLASS, res_name) are given resource &quot;NoResource&quot;.
<P>
<I>options</I>

is a comma separated list containing one or more of the keywords
<I>BorderWidth</I>, <I>HandleWidth</I>,

<I>NoIcon</I> / <I>Icon</I>, <I>MiniIcon</I>,

<I>IconBox</I>, <I>IconGrid</I>, <I>IconFill</I>,

<I>NoTitle</I> / <I>Title</I>,

<I>TitleAtBottom</I> / <I>TitleAtTop</I>,

<I>StippledTitle</I> / <I>StippledTitleOff</I>,

<I>NoHandles</I> / <I>Handles</I>,

<I>WindowListSkip</I> / <I>WindowListHit</I>,

<I>CirculateSkip</I> / <I>CirculateHit</I>,

<I>CirculateSkipShaded</I> / <I>CirculateHitShaded</I>,

<I>Layer</I>,

<I>StaysOnTop</I> / <I>StaysOnBottom</I> / <I>StaysPut</I>,

<I>Sticky</I> / <I>Slippery</I>,

<I>StartIconic</I> / <I>StartNormal</I>,

<I>Color</I>, <I>ForeColor</I>, <I>BackColor</I>, <I>Colorset</I>,

<I>HilightFore</I>, <I>HilightBack</I>, <I>HilightColorset</I>,

<I>BorderColorset</I>, <I>HilightBorderColorset</I>,

<I>Font</I>,

<I>IconFont</I>,

<I>StartsOnDesk</I> / <I>StartsOnPage</I> / <I>StartsAnyWhere</I>,

<I>StartsOnScreen</I>,

<I>ManualPlacementHonorsStartsOnPage</I> / <I>ManualPlacementIgnoresStartsOnPage</I>,

<I>CaptureHonorsStartsOnPage</I> / <I>CaptureIgnoresStartsOnPage</I>,

<I>RecaptureHonorsStartsOnPage</I> / <I>RecaptureIgnoresStartsOnPage</I>,

<I>StartsOnPageIncludesTransients</I> / <I>StartsOnPageIgnoresTransients</I>,

<I>IconTitle</I> / <I>NoIconTitle</I>,

<I>MwmButtons</I> / <I>FvwmButtons</I>,

<I>MwmBorder</I> / <I>FvwmBorder</I>,

<I>MwmDecor</I> / <I>NoDecorHint</I>,

<I>MwmFunctions</I> / <I>NoFuncHint</I>,

<I>HintOverride</I> / <I>NoOverride</I>,

<I>NoButton</I> / <I>Button</I>,

<I>ResizeHintOverride</I> / <I>NoResizeOverride</I>,

<I>OLDecor</I> / <I>NoOLDecor</I>,

<I>GNOMEUseHints</I> / <I>GNOMEIgnoreHints</I>,

<I>StickyIcon</I> / <I>SlipperyIcon</I>,

<I>ManualPlacement</I> / <I>CascadePlacement</I> / <I>MinOverlapPlacement</I> / 

<I>MinOverlapPercentPlacement</I> / <I>TileManualPlacement</I> / 

<I>TileCascadePlacement</I>,

<I>DecorateTransient</I> / <I>NakedTransient</I>,

<I>RaiseTransient</I> / <I>DontRaiseTransient</I>,

<I>LowerTransient</I> / <I>DontLowerTransient</I>,

<I>StackTransientParent</I> / <I>DontStackTransientParent</I>,

<I>SkipMapping</I> / <I>ShowMapping</I>,

<I>ScatterWindowGroups</I> / <I>KeepWindowGroupsOnDesk</I>,

<I>UseDecor</I>,

<I>UseStyle</I>,

<I>NoPPosition</I> / <I>UsePPosition</I>,

<I>NoUSPosition</I> / <I>UseUSPosition</I>,

<I>NoTransientPPosition</I> / <I>UseTransientPPosition</I>,

<I>NoTransientUSPosition</I> / <I>UseTransientUSPosition</I>,

<I>UseIconPosition</I> / <I>NoIconPosition</I>,

<I>Lenience</I> / <I>NoLenience</I>,

<I>ClickToFocus</I> / <I>SloppyFocus</I> /

<I>MouseFocus</I>|<I>FocusFollowsMouse</I> / <I>NeverFocus</I>,

<I>ClickToFocusPassesClickOff</I> / <I>ClickToFocusPassesClick</I>,

<I>ClickToFocusRaisesOff</I> / <I>ClickToFocusRaises</I>,

<I>MouseFocusClickRaises</I> / <I>MouseFocusClickRaisesOff</I>,

<I>StartsLowered</I> / <I>StartsRaised</I>,

<I>GrabFocus</I> / <I>GrabFocusOff</I>,

<I>GrabFocusTransient</I> / <I>GrabFocusTransientOff</I>,

<I>IgnoreRestack</I> / <I>AllowRestack</I>,

<I>FixedPosition</I> / <I>VariablePosition</I>,

<I>IconOverride</I> / <I>NoIconOverride</I> / <I>NoActiveIconOverride</I>,

<I>DepressableBorder</I> / <I>FirmBorder</I>,

<I>MaxWindowSize</I>,

<I>IconifyWindowGroups</I> / <I>IconifyWindowGroupsOff</I>,

<I>ResizeOpaque</I> / <I>ResizeOutline</I>,

<I>BackingStore</I> / <I>BackingStoreOff</I>,

<I>Opacity</I> / <I>ParentalRelativity</I>,

<I>SaveUnder</I> / <I>SaveUnderOff</I>,

<I>WindowShadeShrinks</I> / <I>WindowShadeScrolls</I>,

<I>WindowShadeSteps.</I>

<P>

In the above list some options are listed as
style-option/opposite-style-option.  The opposite-style-option for
entries that have them describes the fvwm default behavior and can
be used if you want to change the fvwm default behavior.
<P>

<DT><B>Focus policy</B>

<DD>
<I>ClickToFocus</I>

instructs fvwm to give the focus to the window when it is clicked
in.  The default
<I>MouseFocus</I>

(or its alias
<I>FocusFollowsMouse</I>)

tells fvwm to give the window the focus as soon as the pointer
enters the window, and take it away when the pointer leaves the
window.
<I>SloppyFocus</I>

is similar, but doesn't give up the focus if the pointer leaves
the window to pass over the root window or a ClickToFocus window
(unless you click on it, that is), which makes it possible to move
the mouse out of the way without losing focus.  A window with the
style
<I>NeverFocus</I>

never receives the focus.  This is useful for modules like
<B>FvwmButtons</B>,

for example.
<P>
The focus model can be augmented with several additional options.
<I>ClickToFocusPassesClickOff</I> and <I>ClickToFocusPassesClick</I>

controls if a mouse click to focus a window using the
<I>ClickToFocus</I>

model is sent to the application or not.  Similarly,
<I>ClickToFocusRaisesOff</I> and <I>ClickToFocusRaises</I>

control if the window is raised, while
<I>MouseFocusClickRaises</I> and <I>MouseFocusClickRaisesOff</I>

are equivalent but apply only to windows using
<I>SloppyFocus</I>, <I>MouseFocus</I> and <I>NeverFocus</I>.

The defaults are
<I>ClickToFocusPassesClick</I>,

<I>ClickToFocusRaises</I> and <I>MouseFocusClickRaisesOff</I>.

<P>
<I>GrabFocus</I>

causes a newly mapped window to grab the focus, while
<I>GrabFocusOff</I>

turns this off.
<I>GrabFocus</I>

is the default for
<I>ClickToFocus</I>

windows and
<I>GrabFocusOff</I>

is the default for
<I>MouseFocus</I> and <I>SloppyFocus</I>

windows.  Note that this option is switched back to the default
every time you change the focus policy.  You have to use it after
the initial
<I>ClickToFocus</I>/<I>MouseFocus</I>/<I>SloppyFocus</I>.

This style does not apply to transient windows.  The
<I>GrabFocusTransient</I> and <I>GrabFocusTransientOff</I>

styles are responsible for this behavior.  By default,
<I>GrabFocusTransient</I>

is turned on.
<P>
<I>Lenience</I>

instructs fvwm to ignore the convention in the
<FONT SIZE="-1">ICCCM</FONT>
which states that if an application sets the input field of the
wm_hints structure to False, then it never wants the window
manager to give it the input focus.  The only application that we
know of which needs this is sxpm, and that is a silly bug with a
trivial fix and has no overall effect on the program anyway.
Rumor is that some older applications have problems too.
<P>

<DT><B>Window title</B>

<DD>
The
<I>Title</I> and <I>NoTitle</I>

options determine if the window has a title-bar or not.  By
default all windows have a title-bar.
<P>
Windows with the
<I>TitleAtBottom</I>

style have a title-bar below the window instead of above as
usual. The
<I>TitleAtTop</I>

style restores the default placement.  Even if the window has the
<I>NoTitle</I>

style set, this affects the
<I>WindowShade</I>

command.
<P>
With the
<I>StippledTitle</I>

style, are drawn with the same effect that is usually reserved for
windows with the
<I>Sticky</I>

style.
<I>StippledTitleOff</I>

reverts back to normal titles.
<P>
<I>Color</I>

takes two arguments.  The first is the window-label text color and
the second is the window decoration's normal background color. The
two colors are separated with a slash.  If the use of a slash
causes problems then the separate
<I>ForeColor</I> and <I>BackColor</I>

options can be used.
<P>
<I>Colorset</I>

takes the colorset number as its sole argument and overrides the
colors set by
<I>Color</I>.

Instead, the corresponding colors from the given colorset are
used.  Note that all other features of a colorset are unsupported
yet. To stop using the colorset, the colorset number can be
omitted.
<P>
The
<I>HilightFore</I>, <I>HilightBack</I> and <I>HilightColorset</I>

style options work exactly like
<I>ForeColor</I>, <I>BackColor</I> and <I>Colorset</I>

but are used only if the window has the focus.  These styles
replace the old commands
<B>HilightColor</B> and <B>HilightColorset</B>.

<P>
<I>BorderColorset</I>

takes the colorset number as its sole argument and overrides the
colors set by
<I>Color</I> or <I>Colorset</I>.

for the window border.  To stop using a colorset, the argument can
be omitted.
<P>
The
<I>HilightBorderColorset</I>

style option works similarly to
<I>BorderColorset</I>

but is used when the window has the focus.
<P>
The
<I>Font</I> and <I>IconFont</I>

options take the name of a font as their sole argument. This font
is used in the window or icon title.  By default the font given in
the
<B>DefaultFont</B>

command is used.  To revert back to the default, use the style
without the name argument.  These styles replace the older
<B>WindowFont</B> and <B>IconFont</B>

commands.
<P>

<DT><B>Title buttons</B>

<DD>
<I>Button</I> and <I>NoButton</I>

take a numeric argument which is the number of the title-bar
button which is to be included/omitted.
<P>
<I>MwmButtons</I>

makes the
<B>Maximize</B>

button look pressed-in when the window is maximized.  See the
<I>MwmDecorMax</I>

flag in
<B>ButtonStyle</B>

for more information.  To switch this style off again, use the
<I>FvwmButtons</I>

style.
<P>

<DT><B>Borders</B>

<DD>
<I>MwmBorder</I>

makes the 3-D bevel more closely match Mwm's.
<I>FvwmBorder</I>

turns off the previous option.
<P>
<I>HandleWidth</I>

takes a numeric argument which is the width of the border to place
the window if it does have resize-handles.
<P>
<I>BorderWidth</I>

takes a numeric argument which is the width of the border to place
the window if it does not have resize-handles.
<P>
<I>DepressableBorder</I>

makes the border parts of the window decoration look sunken in
when a button is pressed over them.  This can be disabled again
with the
<I>FirmBorder</I>

style.
<P>

<DT><B>Icons, shading, maximizing, movement, resizing</B>

<DD>
<I>Icon</I>

takes an (optional) unquoted string argument which is the icon
bitmap or pixmap to use.  Icons specified this way override pixmap
icons, but not icon windows, provided by the client in the
application (with the WM_HINTS property).  The
<I>IconOverride</I>

style changes the behavior to override any client-provided icons;
the
<I>NoIconOverride</I>

style changes the behavior to not override any client-provided
icons; the default overriding behavior can be activated with the
<I>NoActiveIconOverride</I>

style.  With this style, fvwm uses application provided icons if
the icon is changed but uses the icon provided in the
configuration file until then.
<P>
There is one exception to these rules, namely


<P>


<blockquote><PRE>Style * Icon unknown.xpm</PRE></blockquote>
<P>



doesn't force the unknown.xpm icon on every window, it just sets
the default icon like the DefaultIcon command. If you really want
all windows to have the same icon, you can use


<P>


<blockquote><PRE>Style ** Icon unknown.xpm</PRE></blockquote>
<P>



If the
<I>NoIcon</I>

attribute is set then the specified window simply disappears when
it is iconified.  The window can be recovered through the
window-list.  If
<I>Icon</I>

is set without an argument then the
<I>NoIcon</I>

attribute is cleared but no icon is specified.  An example which
allows only the
<B>FvwmPager</B>

module icon to exist:


<P>


<blockquote><PRE>Style * NoIcon
Style FvwmPager Icon</PRE></blockquote>
<P>



<P>
<I>IconBox</I>

takes no argument, four numeric arguments (plus optionally a
screen specification), an X11 geometry string or the string
&quot;none&quot;:


<P>


<blockquote><PRE>IconBox<I> [</I>screen scr-spec<I>] </I>l t r b</PRE></blockquote>
<P>



or


<P>


<blockquote><PRE>IconBox geometry</PRE></blockquote>
<P>



Where
<I>l</I>

is the left coordinate,
<I>t</I>

is the top,
<I>r</I>

is right and
<I>b</I>

is bottom.  Negative coordinates indicate distance from the right
or bottom of the screen.
If the first argument is the word
<I>screen</I>,

the
<I>scr-spec</I>

argument specifies the Xinerama screen on which the IconBox is
defined.  It can be the usual screen Xinerama specification, 'p',

where the window center is located.  This is only useful with
multiple Xinerama screens.  Perhaps easier to use is an X11
geometry string:


<P>


<blockquote><PRE>IconBox -80x200-1-1</PRE></blockquote>
<P>



Which would place an 80 by 240 pixel icon box in the lower right
hand corner of the screen.  The icon box is a region of the screen
where fvwm attempts to put icons for any matching window, as long
as they do not overlap other icons. Multiple icon boxes can be
defined as overflow areas.  When the first icon box is full, the
second one is filled.  All the icon boxes for one style must be
defined in one
<B>Style</B>

command.  For example:


<P>


<blockquote><PRE>Style * IconBox -80x200-1-1, \
        IconBox 1000x70-1-1</PRE></blockquote>
<P>



A Style command with the IconBox option replaces any icon box
previously defined for the same style.  Thats why the backslash in
the previous example is required.
<P>
Note: The geometry for the icon box command takes the additional
screen specifier &quot;@w&quot; in case a Xinerama setup is used.  This
designates the screen where the window center is located.  The
additional screen specifier is not allowed anywhere else.
<P>
If you never define an icon box, or you fill all the icon boxes,
fvwm has a default icon box that covers the screen, it fills top
to bottom, then left to right, and has an 80x80 pixel grid.  To
disable all but the default icon box you can use IconBox without
arguments in a separate
<B>Style</B>

command.  To disable all icon boxes including the default icon
box, the argument &quot;none&quot; can be specified.
<P>
Hint: You can auto arrange your icons in the icon box with a
simple fvwm function.  Put the &quot;DeiconifyAndRearrange&quot; function
below in your configuration file:


<P>


<blockquote><PRE>AddToFunc DeiconifyAndRearrange
 + C Iconify off
 + C All (CurrentPage Iconic) RecaptureWindow</PRE></blockquote>
<P>



And then replace all places where you call the
<B>Iconify</B>

builtin function to de-iconify an icon with a call to the new
function.  For example replace


<P>


<blockquote><PRE>AddToFunc IconFunc
 + C Iconify off
 + M Raise
 + M Move
 + D Iconify off

Mouse 1 I A Iconify off</PRE></blockquote>
<P>



with


<P>


<blockquote><PRE>AddToFunc IconFunc
 + C DeiconifyAndRearrange
 + M Raise
 + M Move
 + D DeiconifyAndRearrange

Mouse 1 I A DeiconifyAndRearrange</PRE></blockquote>
<P>



<I>IconGrid</I>

takes 2 numeric arguments greater than zero.


<P>


<blockquote><PRE><I>IconGrid x y</I></PRE></blockquote>
<P>



Icons are placed in an icon box by stepping through the icon box
using the
<I>x</I> and <I>y</I>

values for the icon grid, looking for a free space. The default
grid is 3 by 3 pixels which gives a tightly packed appearance. To
get a more regular appearance use a grid larger than your largest
icon. Currently there is no way to clip an icon to a maximum
size. An
<I>IconGrid</I>

definition must follow the
<B>IconBox</B>

definition that it applies to:


<P>


<blockquote><PRE>Style * IconBox -80x240-1-1, IconGrid 90 90</PRE></blockquote>
<P>



<I>IconFill</I>

takes 2 arguments.


<P>


<blockquote><PRE>IconFill <I>Bottom Right</I></PRE></blockquote>
<P>



Icons are placed in an icon box by stepping through the icon box
using these arguments to control the direction the box is filled
in. By default the direction is left to right, then top to bottom.
This would be expressed as:


<P>


<blockquote><PRE>IconFill left top</PRE></blockquote>
<P>



To fill an icon box in columns instead of rows, specify the
vertical direction (top or bottom) first. The directions can be
abbreviated or spelled out as follows: &quot;t&quot;, &quot;top&quot;, &quot;b&quot;, &quot;bot&quot;,
&quot;bottom&quot;, &quot;l&quot;, &quot;lft&quot;, &quot;left&quot;, &quot;r&quot;, &quot;rgt&quot;, &quot;right&quot;. An
<B>IconFill</B>

definition must follow the
<B>IconBox</B>

definition that it applies to:


<P>


<blockquote><PRE>Style * IconBox -80x240-1-1, IconFill b r</PRE></blockquote>
<P>



<I>MiniIcon</I>

specifies a pixmap to use as the miniature icon for the
window. This miniature icon can be drawn in a title-bar button
(see
<B>ButtonStyle</B>),

and can be used by various fvwm modules
(<B>FvwmWinList</B>, <B>FvwmIconMan</B> and <B>FvwmTaskBar</B>).

It takes the name of a pixmap as an argument.
<P>
<I>WindowShadeShrinks  and  WindowShadeScrolls</I>

control if the contents of a window that is being shaded with the
<B>WindowShade</B>

command are scrolled (default) or if they stay in place.
<P>
The
<I>WindowShadeSteps</I>

option selects the number of steps for animation when shading a
window with
<B>WindowShade</B>.

It takes one number as its argument.  If the number has a trailing
'<I>p</I>'

it sets the number of pixels to use as the step size instead of
a fixed number of steps.  0 disables the animation.  This happens
too if the argument is omitted or invalid.
<P>
<I>ResizeOpaque</I>

instructs fvwm to resize the corresponding windows with their
contents visible instead of using an outline.  Since this causes
the application to redraw frequently it can be quite slow and make
the window flicker excessively, depending on the amount of
graphics the application redraws.  The
<I>ResizeOutline</I>

style (default) negates the
<I>ResizeOpaque</I>

style.  Many applications do not like their windows being resized
opaque, e.g. XEmacs, Netscape or terminals with a pixmap
background. If you do not like the result, don't use the
<I>ResizeOpaque</I>

style for these windows.  To exempt certain windows from opaque
resizing you could use these lines in your configuration file:


<P>


<blockquote><PRE>Style * ResizeOpaque
Style rxvt ResizeOutline
Style emacs ResizeOutline</PRE></blockquote>
<P>



<I>Sticky</I>

makes the window sticky, i.e. it is always visible on each page
and each desk.  The opposite style,
<I>Slippery</I>

reverts back to the default.
<P>
<I>StickyIcon</I>

makes the window sticky when its iconified.  It de-iconifies on
top the active desktop.
<I>SlipperIcon</I>

reverts back to the default.
<P>
<I>IgnoreRestack</I>

makes fvwm ignore attempts of clients to raise or lower their own
windows.  By default, the opposite style,
<I>AllowRestack</I>

is active.
<P>
<I>FixedPosition</I>

makes fvwm ignore attempts of the user to move the window.  To
allow user movement of windows, use the
<I>VariablePosition</I>

style.
<P>
<I>ResizeHintOverride</I>

instructs fvwm to ignore the program supplied minimum and maximum
size.  This can be handy for broken applications that refuse to be
resized.  Don't use it if you don't need it.  The default
(opposite) style is
<I>NoResizeOverride.</I>

<P>
<I>MaxWindowSize  [ width [ p ]  height [ p ] ]</I>

Tells fvwm the maximum width and height of a window.  The values
are the percentage of the total screen area.  If the letter
'<I>p</I>'

is appended to either of the values, the numbers are interpreted
as pixels. This command is useful to force large application
windows to be fully visible.  Neither
<I>height</I> or <I>width</I>

may be less than 100 pixels.  If you omit the parameters or their
values are invalid, both limits are set to 32767 pixels (which is
the default).
<P>
With
<I>IconifyWindowGroups</I>

all windows in the same window group are iconified at once when
group leader is iconified.  The default is
<I>IconifyWindowGroupsOff</I>,

which disables this behaviour.  Although a number of applications
use the window group hint, it is rarely used in a proper way, so
it is probably best to use
<I>IconifyWindowGroups</I>

only for selected applications.
<P>

<DT><B>Window Manager placement</B>

<DD>
Applications can place windows at a particular spot on the screen
either by window manager hints or a geometry specification.  When
they do neither, then the window manager steps in to find a place
for the window.  Fvwm knows six ways to deal with this
situation. The default is
<I>TileCascadePlacement</I>.

<P>
<I>CascadePlacement</I>

automatically place new windows in a cascading fashion.
<P>
<I>TileCascadePlacement</I>

automatically places new windows in a smart location - a location
in which they do not overlap any other windows on the screen.  If
no such position can be found
<I>CascadePlacement</I>

is used as a fall-back method.
<P>
<I>TileManualPlacement</I>

This is the same as
<I>TileCascadePlacement</I>,

but uses
<I>ManualPlacement</I>

as the fall-back method.
<P>
<I>MinOverlapPlacement</I>

automatically places new windows in a location in which the
overlapping area in pixels of other windows is minimal.  This
placement policy especially tries to avoid overlapping icons and
windows on higher layers.
<P>
<I>MinOverlapPercentPlacement</I>

is similar to
<I>MinOverlapPlacement</I>

but tries to minimize the overlapped percentages of other windows
instead of the overlapped area in pixels.  This placement policy
tries to avoid covering other windows completely and tries even
harder not to cover small windows.
<P>
<I>ManualPlacement</I>

(aka active placement). The user is required to place every new
window manually.  The window only shows as a rubber band until a
place is selected manually. The window is placed when a mouse
button or any key except
<FONT SIZE="-1">Escape</FONT>
is pressed.  Escape aborts manual placement which places the
window in the top left corner of the screen. If mouse button 2 is
pressed during the initial placement of a window (respectively
<FONT SIZE="-1">Shift</FONT>
and mouse button 1 in case Mwm emulation has been enabled with the
<B>Emulate</B>

command), the user is asked to resize the window too.  Pressing
button 3 sets the
<I>PlacedByButton3</I>

condition (see
<B>Current</B>

command).
<P>
Example:


<P>


<blockquote><PRE>Style * ManualPlacement

*FvwmEvent: PassID
*FvwmEvent: add_window GrowDownFunc
AddToFunc StartFunction
+ I FvwmEvent

AddToFunc GrowDownFunc
+ I windowid $0 (PlacedByButton3) \
  Resize bottomright keep -0p</PRE></blockquote>
<P>



<P>
Now, whenever a window is created and the user presses button 3 to
finish initial placement, the window is automatically enlarged
until it hits the bottom screen border.
<P>
<I>Old placement styles</I>

DumbPlacement / SmartPlacement / SmartPlacementOff,
ActivePlacement / RandomPlacement,
ActivePlacementsHonorsStartsOnPage / ActivePlacementsHonorsStartsOnPageOff,
GlobalOpts SmartPlacementIsReallySmart / GlobalOpts SmartPlacementIsNormal
are still supported but will be removed in the future. The old and
new styles can be translated according to the following table:


<P>


<blockquote><PRE>GlobalOpts SmartPlacementIsReallySmart
Style * SmartPlacement
  --&gt;
Style * SmartPlacement, CleverPlacement

Global SmartPlacementIsNormal
Style * SmartPlacement
  --&gt;
Style * SmartPlacement, CleverPlacementOff

Style * DumbPlacement, RandomPlacement
  --&gt;
Style * CascadePlacement

Style * DumbPlacement, ActivePlacement
  --&gt;
Style * ManualPlacement

Style * SmartPlacement + RandomPlacement + CleverPlacementOff
  --&gt;
Style * TileCascadePlacement

Style * SmartPlacement + ActivePlacement + CleverPlacementOff
  --&gt;
Style * TileManualPlacement

Style * SmartPlacement + CleverPlacement
  --&gt;
Style * MinOverlapPlacement

Style * SmartPlacement, ActivePlacement, CleverPlacement
  --&gt;
Style * MinOverlapPercentPlacement

Style * ActivePlacementsHonorsStartsOnPage
  --&gt;
Style * ManualPlacementsHonorsStartsOnPage

Style * ActivePlacementsHonorsStartsOnPageOff
  --&gt;
Style * ManualPlacementsHonorsStartsOnPageOff</PRE></blockquote>
<P>



<P>

<DT><B>Placement policy options and window stacking</B>

<DD>
<I>NoPPosition</I>

instructs fvwm to ignore the program specified position (PPosition
hint) when adding new windows.  Using PPosition is required for
some applications, but if you don't have one of those its a real
headache.  Many programs set PPosition to something obnoxious like
0,0 (upper left corner).
<P>
<I>NoUSPosition</I>

works like
<I>NoPPosition</I>

but applies suppresses using the user specified position indicated
by the program (USPosition hint).  It is generally a bad thing to
override the user's choice, but some applications misuse the
USPosition hint to force their windows to a certain spot on the
screen without the user's consent.
<P>
<I>NoTransientPPosition</I> and <I>UseTransientPPosition</I>

work like
<I>NoPPosition</I> and <I>UsePPosition</I>

but apply only to transient windows.
<P>
<I>NoIconPosition</I>

instructs fvwm to ignore the program specified icon position
(IconPosition hint) when iconifying the window.
<P>
<I>StartsOnDesk</I>

takes a numeric argument which is the desktop number on which the
window should be initially placed.  Note that standard Xt programs
can also specify this via a resource (e.g. &quot;-xrm '*Desk: 1'&quot;).
<P>
<I>StartsOnPage</I>

takes 1, 2, or 3 numeric arguments.  If one or three arguments are
given, the first (or only) argument is the desktop number. If
three arguments are given, the 2nd and 3rd arguments identify the
x,y page position on the virtual window.  If two arguments are
given, they specify the page position, and indicate no desk
preference.  If only one argument is given,
<I>StartsOnPage</I>

functions exactly like
<I>StartsOnDesk</I>.

For those standard Xt programs which understand this usage, the
starting desk/page can also be specified via a resource (e.g.,
&quot;-xrm '*page: 1 0 2'&quot;).
<I>StartsOnPage</I>

in conjunction with
<I>SkipMapping</I>

is a useful technique when you want to start an app on some other
page and continue with what you were doing, rather than waiting
for it to appear.
<P>
<I>StartsOnScreen</I>

takes one argument.  It can be 'p' for the primary screen, 'c' for
the current screen (containing the mouse pointer), 'g' for the
global screen or the screen number itself (counting from zero).
A new window is placed on the specified Xinerama screen.  The
default is to place windows on the screen that contains the mouse
pointer at the time the window is created.
However, those windows which are not placed by FVWM (i.e., those with
a USPosition hint from a user specified geometry) are normally placed
in a position relative to the global screen.  The
<I>StartsOnScreen</I>

style is also useful to cause these windows to be placed relative
to a specific Xinerama screen.  For example:


<P>


<blockquote><PRE>Style * StartsOnScreen c</PRE></blockquote>
<P>



Would cause all windows, including those with their own geometry
to be placed relative to the current Xinerama screen rather than
the global screen.
For those standard Xt programs which understand this usage, the
starting desk/page can also be specified via a resource (e.g.,
&quot;-xrm '*fvwmscreen: c'&quot;).  ('fvwmscreen' was chosen
because some applications already use '.screen' for other
purposes.)
<P>
<I>StartsOnPageIncludesTransients</I>

causes the
<I>StartsOnPage</I>

style to be applied even for transient windows.  This is not
usually useful, since transients are usually pop ups that you want
to appear in your visible viewport; but occasionally an
application uses a transient for something like a startup window
that needs to be coerced into place.
<P>
<I>ManualPlacementIgnoresStartsOnPage</I>

suppresses
<I>StartsOnPage</I> or <I>StartsOnDesk</I>

placement in the event that both
<I>ManualPlacement</I> and <I>SkipMapping</I>

are in effect when a window is created.  This prevents you from
interactively placing a window and then wondering where it
disappeared to, because it got placed on a different desk or page.
<I>ManualPlacementHonorsStartsOnPage</I>

allows this to happen anyway.  The option has no effect if
<I>SkipMapping</I>

is not in effect, because fvwm switches to the proper desk/page to
perform interactive placement.  The default is
<I>ManualPlacementIgnoresStartsOnPage</I>; 

<I>ManualPlacementHonorsStartsOnPage</I>

matches the way the old
<I>StartsOnDesk</I>

style used to handle the situation.
<P>
<I>CaptureHonorsStartsOnPage</I>

causes the initial capture (of an already existing window) at
startup to place the window according to the
<I>StartsOnPage</I> and <I>StartsOnScreen</I>

desk, page and Xinerama screen specification.
<I>CaptureIgnoresStartsOnPage</I>

causes fvwm to ignore these settings (including
<I>StartsOnDesk</I>)

on initial capture.  The default is
<I>CaptureHonorsStartsOnPage</I>.

<P>
<I>RecaptureHonorsStartsOnPage</I>

causes a window to be placed according to, or revert to, the
<I>StartsOnPage</I> and <I>StartsOnScreen</I>

desk, page and Xinerama screen specification on
<B>Restart</B> or <B>Recapture</B>.

<I>RecaptureIgnoresStartsOnPage</I>

causes fvwm to respect the current window position on
<B>Restart</B> or <B>Recapture</B>.

The default is
<I>RecaptureIgnoresStartsOnPage</I>.

<P>
<I>Layer</I>

accepts one optional argument: a non-negative integer.  This is
the layer the window is put in.  If no argument is given, any
previously set value is deleted and the default layer is implied.
<P>
<I>StaysOnTop</I>

puts the window in the top layer.  This layer can be changed by
the built-in command
<B>DefaultLayers</B>;

the default is 6.
<P>
<I>StaysPut</I>

puts the window in the put layer.  This layer can be changed by
the built-in command
<B>DefaultLayers</B>;

the default is 4.
<P>
<I>StaysOnBottom</I>

puts the window in the bottom layer.  This layer can be changed by
the built-in command
<B>DefaultLayers</B>;

the default is 2.
<P>
<I>StartsLowered</I>

instructs fvwm to put the window initially at the bottom of its
layer rather than the default
<I>StartsRaised</I>.

<P>
<I>SkipMapping</I>

tells fvwm not to switch to the desk the window is on when it gets
mapped initially (useful with
<I>StartsOnDesk</I> or <I>StartsOnPage</I>).

<P>
<I>KeepWindowGroupsOnDesk</I>

makes new windows that have the window group hint set appear on
the same desk as the other windows of the same group.  Since this
bevhaviour may be confusing, the default setting is
<I>ScatterWindowGroups</I>.

The window group hint is ignored when placing windows in this
case.
<P>

<DT><B>Transient windows</B>

<DD>
<I>DecorateTransient</I>

causes transient windows, which are normally left undecorated, to
be given the usual fvwm decorations (title bar, buttons,
etc.). Note that some pop-up windows, such as the xterm menus, are
not managed by the window manager and still do not receive
decorations.
<I>NakedTransient</I>

(the default) causes transient windows not to be given the
standard decorations. You can only bind keys or mouse buttons to
the sides and the client window of an undecorated window ('S'
and 'W' contexts in bindings, see
<B>Mouse</B> and <B>Key</B>

commands).
<P>
A window with the
<I>RaiseTransient</I>

style that has transient windows raises all its transients when it
is raised.  The
<I>DontRaiseTransient</I>

style disables this behavior.  All windows are then treated as if
they had no transients.
<P>
A window with the
<I>LowerTransient</I>

style that has transient windows lowers all its transients when it
is lowered.  The
<I>DontLowerTransient</I>

style disables this behavior.  All windows are then treated as if
they had no transients.
<P>
The
<I>StackTransientParent</I>

style augments
<I>RaiseTransient</I> and <I>LowerTransient</I>

styles.  Raising a window with
<I>StackTransientParent</I>

style transfers the raise action to the main window if the window
being raised is a transient and its main window has
<I>RaiseTransient</I>

style; this effect makes raise on a transient act just like raise
on its main - the whole group is raised.  Similar behavior holds
for lowering a whole group of transients when the main has
<I>LowerTransient</I>

style.
<I>DontStackTransientParent</I>

turns this behavior off.
<I>(Dont)StackTransientParent</I>

has no effect if
<I>RaiseTransient</I> and <I>LowerTransient</I>

are not used.
<P>
A reasonable emulation of Motif raise/lower on transients is
possible like this


<P>


<blockquote><PRE>Style * RaiseTransient
Style * LowerTransient
Style * StackTransientParent</PRE></blockquote>
<P>



<P>

<DT><B>Miscellaneous</B>

<DD>
The
<I>BackingStore</I> and <I>SaveUnder</I>

styles enable the corresponding window attributes in the X server.
<I>BackingStore</I>

means that the X server tries to keep the obscured parts of a
window in memory while windows with
<I>SaveUnder</I>

store the graphics below them.  Either option can speed up fvwm if
the connection to the X server is slow (e.g. over a modem link).
By default both styles are turned off.  To switch them off
explicitly you can use the
<I>BackingStoreOff</I> and <I>SaveUnderOff</I>

styles.
<P>
<I>ParentalRelativity</I>

enables clients that use a background pixmap of type
<I>ParentRelative</I>

to achieve transparency. Fvwm modules that support transparent
colorsets require this setting.
<I>Opacity</I>

is the default and should be used for all non-transparent clients
for better performance.
<P>
<I>MwmDecor</I>

makes fvwm attempt to recognize and respect the mwm decoration
hints that applications occasionally use.  To switch this style
off, use the
<I>NoDecorHint</I>

style.
<P>
<I>MwmFunctions</I>

makes fvwm attempt to recognize and respect the mwm prohibited
operations hints that applications occasionally use.
<I>HintOverride</I>

makes fvwm shade out operations that mwm would prohibit, but it
lets you perform the operation anyway.
<I>NoFuncHint</I>

allows turns off the mwm hints completely.
<P>
<I>OLDecor</I>

makes fvwm attempt to recognize and respect the olwm and olvwm
hints that many older XView and OLIT applications use.  Switch
this option off with
<I>NoOLDecor</I>.

<P>
With
<I>GNOMEIgnoreHints</I>

fvwm ignores all GNOME hints for the window, even if GNOME
compliance is compiled in.  This is useful for those pesky
applications that try to be more clever than the user and use
GNOME hints to force the window manager to ignore the user's
preferences.  The
<I>GNOMEUseHints</I>

style switches back to the default behaviour.
<P>
<I>UseDecor</I>

accepts one argument: the name of a decor created with
<B>AddToDecor</B>.

If no decor name is specified, the &quot;Default&quot; decor is
used. Windows do not actually contain decors, but are always
assigned to one.  If the decor is later modified with
<B>AddToDecor</B>,

the changes are visible for all windows which are assigned to it.
The decor for a window can be reassigned with
<B>ChangeDecor</B>.

<P>
<I>UseStyle</I>

takes one arg, which is the name of another style.  That way you
can have unrelated window names easily inherit similar traits
without retyping.  For example:


<P>


<blockquote><PRE>  Style rxvt UseStyle XTerm</PRE></blockquote>
<P>



Warning:  If a style is built from one or more parent styles and
the parent styles are changed, the derived style is not
modified. To achieve this you have to issue the
<I>UseStyle</I>

line again.
<P>

<DT><B>Examples</B>

<DD>


<P>


<blockquote><PRE># Change default fvwm behavior to no title-
# bars on windows! Also define a default icon.
Style *             NoTitle,               \
                    Icon unknown1.xpm,     \
                    BorderWidth 4,         \
                    HandleWidth 5

# now, window specific changes:
Style Fvwm*       NoHandles, Sticky,       \
                  WindowListSkip,          \
                  BorderWidth 0
Style FvwmPager   StaysOnTop, BorderWidth 0
Style *lock       NoHandles, Sticky,       \
                  StaysOnTop, WindowListSkip
Style xbiff       Sticky, WindowListSkip
Style FvwmButtons NoHandles, Sticky,       \
                  WindowListSkip
Style sxpm        NoHandles

# Put title-bars back on xterms only!
Style xterm     Title, Color black/grey

Style rxvt        Icon term.xpm
Style xterm       Icon rterm.xpm
Style xcalc       Icon xcalc.xpm
Style xbiff       Icon mail1.xpm
Style xmh         Icon mail1.xpm,         \
                    StartsOnDesk 2
Style xman        Icon xman.xpm
Style matlab      Icon math4.xpm,         \
                    StartsOnDesk 3
Style xmag        Icon magnifying_glass2.xpm
Style xgraph      Icon graphs.xpm
Style FvwmButtons Icon toolbox.xpm
Style Maker       StartsOnDesk 1
Style signal      StartsOnDesk 3

# Fire up Netscape on the second desk, in the
# middle of my 3x3 virtual desktop, and don't
# bother me with it...
Style Netscape* SkipMapping,              \
                StartsOnPage 1 1 1</PRE></blockquote>
<P>



Note that all properties for a window are or'ed together.  In the
above example &quot;FvwmPager&quot; gets the property
<I>StaysOnTop</I>

via an exact window name match but also gets
<I>NoHandles</I>, <I>Sticky</I> and <I>WindowListSkip</I>

by a match to &quot;Fvwm*&quot;.  It gets
<I>NoTitle</I>

by virtue of a match to &quot;*&quot;.  If conflicting styles are specified
for a window, then the last style specified are used.
<P>
If the
<I>NoIcon</I>

attribute is set then the specified window simply disappears when
it is iconified.  The window can be recovered through the
window-list.  If
<I>Icon</I>

is set without an argument then the
<I>NoIcon</I>

attribute is cleared but no icon is specified.  An example which
allows only the FvwmPager module icon to exist:


<P>


<blockquote><PRE>Style * NoIcon
Style FvwmPager Icon</PRE></blockquote>
<P>



<P>
<DT><B>DestroyStyle </B><I>style</I>

<DD>
Deletes the style named
<I>style</I>.

The changes take effect immediately.  Note that
<I>style</I>

is not a wild-carded search string, but rather a case-sensitive
string that should exactly match the original
<B>Style</B>

command.
<P>
Destroying style &quot;*&quot; can be done, but isn't really to be
recommended. For example:


<P>


<blockquote><PRE>DestroyStyle Application*</PRE></blockquote>
<P>



This removes all settings for the style named &quot;Application*&quot;, NOT
all styles starting with &quot;Application&quot;.
<P>
</DL>
<A NAME="lbBL">&nbsp;</A>
<H3>OTHER COMMANDS CONTROLLING WINDOW STYLES</H3>

<P>
<DL COMPACT>
<DT><B>AddButtonStyle</B> <I>button</I> <B>[</B> <I>state</I> <B>] [</B> <I>style</I> <B>] [-- [!]</B> <I>flag</I> <B>...]</B><DD>
<P>
Adds a button style to
<I>button</I>.

<I>button</I>

can be a button number, or one of &quot;All&quot;, &quot;Left&quot; or &quot;Right&quot;.
<I>state</I>

can be &quot;ActiveUp,&quot; &quot;ActiveDown&quot; or &quot;Inactive&quot; or any of these
three with &quot;Toggled&quot; prepended.  &quot;ActiveUp&quot; selects the style of
the button when the window has the focus and the button is not
pressed. &quot;ActiveDown&quot; is similar but applies when the button is
pressed while the &quot;Inactive&quot; style is used for windows without the
focus.  The &quot;Toggled&quot; prefix refers to maximized, shaded or sticky
windows that have the corresponding
<I>MwmDecor...</I>

button style set.  If
<I>state</I>

is omitted, then the style is added to every state.  If the
<I>style</I> and <I>flags</I>

are enclosed in parentheses, then multiple
<I>state</I>

definitions can be placed on a single line.
<I>Flags</I>

for additional button styles cannot be changed after definition.
<P>
Buttons are drawn in the order of definition, beginning with the
most recent button style, followed by those added with
<B>AddButtonStyle</B>.

To clear the button style stack, change style flags, or for
descriptions of available styles and flags, see the
<B>ButtonStyle</B>

command.  Examples:


<P>


<blockquote><PRE>ButtonStyle 1 Pixmap led.xpm -- Top Left
ButtonStyle 1 ActiveDown HGradient 8 grey \
  black
ButtonStyle All --  UseTitleStyle
AddButtonStyle 1 ActiveUp (Pixmap a.xpm)  \
  ActiveDown (Pixmap b.xpm -- Top)
AddButtonStyle 1 Vector 4 50x30@1 70x70@0 \
  30x70@0 50x30@1</PRE></blockquote>
<P>



Initially for this example all button states are set to a pixmap.
The second line replaces the &quot;ActiveDown&quot; state with a gradient
(it overrides the pixmap assigned to it in the line before, which
assigned the same style to every state).  Then, the
<I>UseTitleStyle</I>

flag is set for all buttons, which causes fvwm to draw any styles
set with
<B>TitleStyle</B>

before drawing the buttons.  Finally,
<B>AddButtonStyle</B>

is used to place additional pixmaps for both &quot;ActiveUp&quot; and
&quot;ActiveDown&quot; states and a vector button style is drawn on top of
all state.
<P>
<DT><B>AddTitleStyle [</B> <I>state</I> <B>] [</B> <I>style</I> <B>] [-- [!]</B> <I>flag</I> <B>...]</B><DD>
Adds a title style to the title-bar.
<I>state</I>

can be one of &quot;ActiveUp,&quot; &quot;ActiveDown&quot; or &quot;Inactive&quot; or any of
these with &quot;Toggled&quot; prepended.  If
<I>state</I>

is omitted, then the style is added to every state.  If the
<I>style</I> and <I>flags</I>

are enclosed in parentheses, then multiple
<I>state</I>

definitions can be placed on a single line.  This command is quite
similar to the
<B>AddButtonStyle</B>

command (see above).
<P>
Title-bars are drawn in the order of definition, beginning with
the most recent
<B>TitleStyle</B>,

followed by those added with
<B>AddTitleStyle</B>.

To clear the title style stack, change style flags, or for the
descriptions of available styles and flags, see the
<B>TitleStyle</B> and <B>ButtonStyle</B>

commands.
<P>
<DT><B>AddToDecor </B><I>decor</I>

<DD>
Add or divert commands to the decor named
<I>decor</I>.

A decor is a name given to the set of commands which affect button
styles, title-bar styles and border styles.  If
<I>decor</I>

does not exist it is created; otherwise the existing
<I>decor</I>

is modified.  Note: Earlier versions allowed to use the
<B>HilightColor</B>, <B>HilightColorset</B> and <B>WindowFont</B>

commands in decors.  This is no longer possible.  Please use the
<I>Style</I>

command with the
<I>Hilight...</I> and <I>Font</I>

options.
<P>
New decors start out exactly like the &quot;default&quot; decor without any
style definitions.  A given decor may be applied to a set of
windows with the
<I>UseDecor</I>

option of the
<B>Style</B>

command.  Modifying an existing decor affects all windows which
are currently assigned to it.
<P>
<B>AddToDecor</B>

is similar in usage to the
<B>AddToMenu</B> and <B>AddToFunc</B>

commands, except that menus and functions are replaced by
<B>ButtonStyle</B>, <B>AddButtonStyle</B>, <B>TitleStyle</B>, <B>AddTitleStyle</B> and 

<B>BorderStyle</B>

commands.  Decors created with
<B>AddToDecor</B>

can be manipulated with
<B>ChangeDecor</B>, <B>DestroyDecor</B>, <B>UpdateDecor</B>

and the
<I>UseDecor </I><B>Style</B>

option.
<P>
The following example creates a decor &quot;FlatDecor&quot; and style
&quot;FlatStyle&quot;.  They are distinct entities:


<P>


<blockquote><PRE>AddToDecor FlatDecor
 + ButtonStyle All ActiveUp (-- flat) \
   Inactive (-- flat)
 + TitleStyle -- flat
 + BorderStyle -- HiddenHandles NoInset

Style FlatStyle UseDecor FlatDecor, \
     Color white/grey40,HandleWidth 4

Style xterm UseStyle FlatStyle</PRE></blockquote>
<P>



An existing window's decor may be reassigned with
<B>ChangeDecor</B>.

A decor can be destroyed with
<B>DestroyDecor</B>.



<P>


<blockquote><PRE>DestroyDecor FlatDecor
AddToDecor FlatDecor ...

Style FlatStyle UseDecor FlatDecor, \
     Color white/grey40,HandleWidth 4</PRE></blockquote>
<P>



and now apply the style again:


<P>


<blockquote><PRE>Style xterm UseStyle FlatStyle</PRE></blockquote>
<P>



<P>
<DT><B>BorderStyle [</B> <I>state</I> <B>] [</B> <I>style</I> <B>] [-- [!]</B> <I>flag</I> <B>...]</B><DD>
Defines a border style for windows.
<I>state</I>

can be either &quot;Active&quot; or &quot;Inactive&quot;.  If
<I>state</I>

is omitted, then the style is set for both states.  If the
<I>style</I> and <I>flags</I>

are enclosed in parentheses, then multiple
<I>state</I>

definitions can be specified per line.
<P>
<I>style</I>

is a subset of the available button styles, and can only be
<I>TiledPixmap</I>

(uniform pixmaps which match the bevel colors work best this
way). If a
'<I>!</I>'

is prefixed to any
<I>flag</I>,

the behavior is negated.  If
<I>style</I>

is not specified, then one can change flags without resetting the
style.
<P>
The
<I>HiddenHandles</I>

flag hides the corner handle dividing lines on windows with
handles (this option has no effect for NoHandle windows).  By
default,
<I>HiddenHandles</I>

is disabled.
<P>
The
<I>NoInset</I>

flag supplements
<I>HiddenHandles</I>.

If given, the inner bevel around the window frame is not drawn.
If
<I>HiddenHandles</I>

is not specified, the frame looks a little strange.
<P>
<I>Raised</I>

causes a raised relief pattern to be drawn (default).
<I>Sunk</I>

causes a sunken relief pattern to be drawn.
<I>Flat</I>

inhibits the relief pattern from being drawn.
<P>
To decorate the active and inactive window borders with a textured
pixmap, one might specify:


<P>


<blockquote><PRE>BorderStyle Active TiledPixmap marble.xpm
BorderStyle Inactive TiledPixmap granite.xpm
BorderStyle Active -- HiddenHandles NoInset</PRE></blockquote>
<P>



To clear the style for both states:


<P>


<blockquote><PRE>BorderStyle Simple</PRE></blockquote>
<P>



To clear for a single state:


<P>


<blockquote><PRE>BorderStyle Active Simple</PRE></blockquote>
<P>



To unset a flag for a given state:


<P>


<blockquote><PRE>BorderStyle Inactive -- !NoInset</PRE></blockquote>
<P>



title-bar buttons can inherit the border style with the
<I>UseBorderStyle</I>

flag (see
<B>ButtonStyle</B>).

<P>
<DT><B>ButtonState [</B><I>ActiveDown bool</I><B>] [</B><I>inactive bool</I><B>]</B>

<DD>
The
<B>ButtonState</B>

command controls which states of the window titles and title
buttons are used.  The default is to use all three states:
&quot;ActiveUp&quot;, &quot;ActiveDown&quot; and &quot;Inactive&quot; (see
<B>ButtonStyle</B> and <B>TitleStyle</B>

commands).  The
<I>bool</I>

argument after the key word controls if the designated state is
used (&quot;True&quot;) or not (&quot;False&quot;).  The &quot;ActiveUp&quot; state cannot be
deactivated. If no arguments are provided or the given arguments
are illegal, the default is restored.
<P>
The &quot;ActiveDown&quot; state allows different button styles for pressed
down buttons and titles on active windows.  Otherwise the
&quot;ActiveUp&quot; state is used instead.  The &quot;Inactive&quot; state allows
different button and title styles for inactive windows.  Otherwise
the &quot;ActiveUp&quot; state is used instead.
<P>
<DT><B>ButtonStyle</B> <I>button</I> <B>[</B> <I>state</I> <B>] [</B> <I>style</I> <B>] [-- [!]</B> <I>flag</I> <B>...]</B><DD>
Sets the button style for a title-bar button.
<I>button</I>

is the title-bar button number between 0 and 9, or one of &quot;All&quot;,
&quot;Left&quot;, &quot;Right&quot;, or &quot;Reset&quot;.  Button numbering is described in the
<B>Mouse</B>

command section.  If the
<I>style</I> and <I>flags</I>

are enclosed in parentheses, then multiple
<I>state</I>

definitions can be specified per line.
<P>
<I>state</I>

refers to which button state should be set.  Button states are
defined as follows: &quot;ActiveUp&quot; and &quot;ActiveDown&quot; refer to the
un-pressed and pressed states for buttons on active windows; while
the &quot;Inactive&quot; state denotes buttons on inactive windows.  The
&quot;ToggledActiveUp&quot;, &quot;ToggledActiveDown&quot; and &quot;ToggledInactive&quot;
states are used instead for buttons which have one of the
<I>MwmDecorMax</I>, <I>MwmDecorShade</I> or <I>MwmDecorStick</I>

hints, if the window is maximized, shaded or sticky, respectively.


<P>


<blockquote><PRE>AddToDecor Default
 + ButtonStyle 6                   \
   Vector 4 50x25@1 85x75@0 15x75@0 50x25@1
 + ButtonStyle 6 ToggledActiveUp   \
   Vector 4 50x75@0 85x25@1 15x25@0 50x75@0
 + ButtonStyle 6 ToggledActiveDown \
   Vector 4 50x75@0 85x25@1 15x25@0 50x75@0
 + ButtonStyle 6 ToggledInactive   \
   Vector 4 50x75@0 85x25@1 15x25@0 50x75@0
 + ButtonStyle 6 - MwmDecorShade
Mouse 0 6 N WindowShade</PRE></blockquote>
<P>



If
<I>state</I>

is &quot;ActiveUp&quot;, &quot;ActiveDown&quot;, &quot;Inactive&quot;, or a &quot;Toggled&quot; variant,
that particular button state is set.  If
<I>state</I>

is omitted, every state is set.  Specifying a style destroys the
current style (use
<B>AddButtonStyle</B>

to avoid this).
<P>
If
<I>style</I>

is omitted, then state-dependent flags can be set for the primary
button style without destroying the current style.  Examples (each
line should be considered independent):


<P>


<blockquote><PRE>ButtonStyle Left -- flat
ButtonStyle All ActiveUp (-- flat) \
  Inactive (-- flat)</PRE></blockquote>
<P>



The first line sets every state of the left buttons to flat, while
the second sets only the &quot;ActiveUp&quot; and &quot;Inactive&quot; states of every
button to flat (only flags are changed; the buttons' individual
styles are not changed).
<P>
If you want to reset all buttons to their defaults:


<P>


<blockquote><PRE>ButtonStyle Reset</PRE></blockquote>
<P>



To reset the &quot;ActiveUp&quot; button state of button 1 to the default:


<P>


<blockquote><PRE>ButtonStyle 1 ActiveUp Default</PRE></blockquote>
<P>



To reset all button states of button 1 to the default of
button number 2:


<P>


<blockquote><PRE>ButtonStyle 1 Default 2</PRE></blockquote>
<P>



For any button, multiple
<I>state</I>

definitions can be given on one line by enclosing the
<I>style</I> and <I>flags</I>

in parentheses.  If only one definition per line is given the
parentheses can be omitted.
<P>
<I>flags</I>

affect the specified
<I>state</I>.

If a
'<I>!</I>'

is prefixed to any
<I>flag</I>,

its behavior is negated.  The available state-dependent flags for
all styles are described here (the
<B>ButtonStyle</B>

entry deals with state-independent flags).
<P>
<I>Raised</I>

causes a raised relief pattern to be drawn.
<P>
<I>Sunk</I>

causes a sunken relief pattern to be drawn.
<P>
<I>Flat</I>

inhibits the relief pattern from being drawn.
<P>
<I>UseTitleStyle</I>

causes the given button state to render the current title style
before rendering the button's own styles.  The
<I>Raised</I>, <I>Flat</I> and <I>Sunk</I>

<B>TitleStyle</B>

flags are ignored since they are redundant in this context.
<P>
<I>UseBorderStyle</I>

causes the button to inherit the decorated
<B>BorderStyle</B>

options.
<P>
<I>Raised</I>, <I>Sunk</I> and <I>Flat</I>

are mutually exclusive, and can be specified for the initial
<B>ButtonStyle</B>

only.
<I>UseTitleStyle</I> and <I>UseBorderStyle</I>

are also mutually exclusive (both can be off however).  The default is
<I>Raised</I>

with both
<I>UseBorderStyle  and  UseTitleStyle</I>

left unset.
<P>
<I>Important note</I>

for the &quot;ActiveDown&quot; state:  When a button is pressed, the relief
is inverted.  Because of this, to obtain a sunken &quot;ActiveDown&quot;
state you must specify the opposite of the desired relief (i.e. to
obtain a pressed-in look which is raised, specify
<I>Sunk</I>

for &quot;ActiveDown&quot;).  This behavior is consistent, but may seem
confusing at first.  The same applies to the &quot;Toggled&quot; state.
<P>
Button styles are classified as non-destructive, partially
destructive, or fully destructive.  Non-destructive styles do not
affect the image. Partially destructive styles can obscure some or
all parts of the underlying image (i.e.
<I>Pixmap</I>).

Fully destructive styles obscure the entire underlying image (i.e.
<I>Solid</I>

or one of the
<I>gradient</I>

styles).  Thus, if stacking styles with
<B>AddButtonStyle</B> (or <B>AddTitleStyle</B>

for title-bars), use care in sequencing styles to minimize redraw.
<P>
The available styles and their arguments now follow.
<P>
The
<I>Simple</I>

style does nothing.  There are no arguments, and this style is an
example of a non-destructive button style.
<P>
The
<I>Default</I>

style conditionally accepts one argument: a number which specifies
the default button number to load.  If the style command given is
<B>ButtonStyle</B> or <B>AddButtonStyle</B>,

the argument is optional (if given, overrides the current button).
If a command other than
<B>ButtonStyle</B> or <B>AddButtonStyle</B>

is used, the number must be specified.
<P>
The
<I>Solid</I>

style fills the button with a solid color.  The relief border
color is not affected.  The color should be specified as a single
argument.  This style is fully destructive.
<P>
The
<I>Vector num</I>

<I>X</I>x<I>Y</I>@<I>C</I> ...

style draws a line pattern.  Since this is a standard button style,
the keyword
<I>Vector</I>

is optional,
<I>num</I>

is a number of point specifications of the form
<I>X</I>x<I>Y</I>@<I>C</I>.

<I>X</I> and <I>Y</I>

are point coordinates inside the button, given in percents
(from 0 to 100).
<I>C</I>

specifies a line color (0 - the shadow color, 1 - the highlight color,
2 - the background color, 3 - the foreground color).
The first point color is not used.
You can use up to 32 points in a line pattern.
This style is partially destructive.
<P>
The specification is a little cumbersome:


<P>


<blockquote><PRE>ButtonStyle 2 Vector 4 50x30@1 70x70@0 \
  30x70@0 50x30@1</PRE></blockquote>
<P>



then the button 2 decoration uses a 4-point pattern consisting of
a line from (x=50,y=30) to (70,70) in the shadow color (@0), and
then to (30,70) in the shadow color, and finally to (50,30) in the
highlight color (@1).  Is that too confusing?  See the fvwm web
pages for some examples with screenshots.
<P>
A more complex example of
<I>Vector</I>:



<P>


<blockquote><PRE>ButtonStyle 8 Vector 10 45x65@2 45x75@3 20x75@3 20x50@3 \
  35x50@3 35x65@1 35x25@1 75x25@1 75x65@0 35x65@0
ButtonStyle 0 Vector 10 45x65@2 45x75@0 20x75@0 20x50@1 \
  45x50@1 45x65@0 75x65@3 75x25@3 35x25@3 35x47@3</PRE></blockquote>
<P>



The
<I>?Gradient</I>

styles denote color gradients.  Fill in the question mark with any
one of the defined gradient types.  Please refer to the
<B>COLOR GRADIENTS</B>

section for a description of the gradient syntax.  The gradient
styles are fully destructive.
<P>
The
<I>Pixmap</I>

style displays a pixmap.  A pixmap should be specified as an
argument.  For example, the following would give button 2 the same
pixmap for both states, and button 4 different pixmaps for the up,
down and inactive states.


<P>


<blockquote><PRE>ButtonStyle 2 Pixmap my_pixmap.xpm
ButtonStyle 4 ActiveUp (Pixmap up.xpm) \
  ActiveDown (Pixmap down.xpm)
ButtonStyle 4 Inactive Pixmap inactive.xpm</PRE></blockquote>
<P>



The pixmap specification can be given as an absolute or relative
pathname (see
<B>ImagePath</B>).

If the pixmap cannot be found, the button style reverts to
<I>Simple</I>.

Flags specific to the
<I>Pixmap</I>

style are
<I>Left</I>, <I>Right</I>, 

<I>Top</I>, and <I>Bottom</I>.

These can be used to justify the pixmap (default is centered for
both directions).  Pixmap transparency is used for the color
&quot;None.&quot;  This style is partially destructive.
<P>
The
<I>MiniIcon</I>

style draws the window's miniature icon in the button, which is
specified with the
<I>MiniIcon</I>

option of the
<B>Style</B>

command.  This button style accepts no arguments.  Example:


<P>


<blockquote><PRE>Style *     MiniIcon mini-bx2.xpm
Style xterm MiniIcon mini-term.xpm
Style Emacs MiniIcon mini-doc.xpm

ButtonStyle 1 MiniIcon</PRE></blockquote>
<P>



The
<I>TiledPixmap</I>

style accepts a pixmap to be tiled as the button background. One
pixmap is specified as an argument.  Pixmap transparency is not
used.  This style is fully destructive.
<P>
<DT><B>ButtonStyle </B><I>button</I><B> - [!]</B><I>flag</I><B> ...</B>

<DD>
Sets state-independent flags for the specified
<I>button</I>.

State-independent flags affect button behavior.  Each
<I>flag</I>

is separated by a space.  If a
'<I>!</I>'

is prefixed to the flag then the behavior is negated.  The special
flag
<I>Clear</I>

clears any existing flags.
<P>
The following flags are usually used to tell fvwm which buttons
should be affected by mwm function hints (see
<I>MwmFunctions</I>

option of the
<B>Style</B>

command.  This is not done automatically since you might have
buttons bound to complex functions, for instance.
<P>
<I>MwmDecorMenu</I>

should be assigned to title-bar buttons which display a menu.  The
default assignment is the leftmost button.  When a window with the
<I>MwmFunctions</I>

<B>Style</B>

option requests not to show this button, it is hidden.
<P>
<I>MwmDecorMin</I>

should be assigned to title-bar buttons which minimize or iconify
the window.  The default assignment is the second button over from
the rightmost button.  When a window with the
<I>MwmFunctions</I>

<B>Style</B>

option requests not to show this button, it is hidden.
<P>
<I>MwmDecorMax</I>

should be assigned to title-bar buttons which maximize the
window. The default assignment is the rightmost button.  When a
window with the
<I>MwmFunctions</I>

<B>Style</B>

option requests not to show this button, it is hidden.  When the
window is maximized, the vector pattern on the button looks
pressed in.
<P>
<I>MwmDecorShade</I>

should be assigned to title-bar buttons which shade the window
(see
<B>WindowShade</B>

command).  When the window is shaded, the vector pattern on the
button looks pressed in.
<P>
<I>MwmDecorStick</I>

should be assigned to title-bar buttons which make the window
sticky. When the window is sticky, the vector pattern on the
button looks pressed in.
<P>
<DT><B>ChangeDecor </B><I>decor</I>

<DD>
Changes the decor of a window to
<I>decor</I>.

<I>decor</I>

is &quot;Default&quot; or the name of a decor defined with
<B>AddToDecor</B>.

If
<I>decor</I>

is invalid, nothing occurs.  If called from somewhere in a window
or its border, then that window is affected.  If called from the
root window the user is allowed to select the target window.
<B>ChangeDecor</B>

only affects attributes which can be set using the
<B>AddToDecor</B>

command.


<P>


<blockquote><PRE>ChangeDecor CustomDecor1</PRE></blockquote>
<P>



<P>
<DT><B>DestroyDecor [</B><I>recreate</I><B>] </B><I>decor</I>

<DD>
Deletes the
<I>decor</I>

defined with
<B>AddToDecor</B>,

so that subsequent references to it are no longer valid.  Windows
using this
<I>decor</I>

revert to the &quot;Default&quot; decor. The optional parameter
<I>recreate</I>

tells fvwm not to throw away the decor completely but to throw
away only its contents. If the decor is created again later,
windows do not use it before the
<I>UseDecor</I>

style is applied again unless the decor was destroyed with the
<I>recreate</I>

option.  The decor named &quot;Default&quot; cannot be destroyed.


<P>


<blockquote><PRE>DestroyDecor CustomDecor1</PRE></blockquote>
<P>



<P>
<DT><B>TitleStyle [</B><I>justification</I><B>] [</B><I>height</I><B> [</B><I>num</I><B>]]</B>

<DD>
Sets attributes for the title-bar.  Justifications can be
<I>Centered ,  RightJustified  or  LeftJustified .</I>

<I>height</I>

sets the title bar's height to an amount in pixels.  Defaults are
<I>Centered</I>

and the window's font height.  To reset the font height to the
default value, omit the
<I>num</I>

argument after the
<I>height</I>

keyword.  Example:


<P>


<blockquote><PRE>TitleStyle LeftJustified Height 24</PRE></blockquote>
<P>



<P>
<DT><B>TitleStyle [</B> <I>state</I> <B>] [</B> <I>style</I> <B>] [-- [!]</B> <I>flag</I> <B>...]</B><DD>
Sets the style for the title-bar.
<I>state</I>

can be one of  &quot;ActiveUp&quot;, &quot;ActiveDown&quot;, or &quot;Inactive&quot;.  If
<I>state</I>

is omitted, then the
<I>style</I>

is added to every state.  If parentheses are placed around the
<I>style</I> and <I>flags</I>,

then multiple state definitions can be given per line.
<I>style</I>

can be omitted so that flags can be set while not destroying the
current style.
<P>
If a
'<I>!</I>'

is prefixed to any
<I>flag</I>,

its behavior is negated.  Valid flags for each state include
<I>Raised</I>, <I>Flat</I> and <I>Sunk</I>

(these are mutually exclusive).  The default is
<I>Raised</I>.

See the note in
<B>ButtonStyle</B>

regarding the &quot;ActiveDown&quot; state.  Examples:


<P>


<blockquote><PRE>TitleStyle ActiveUp HGradient 16 navy black
TitleStyle ActiveDown (Solid red -- flat) \
  Inactive (TiledPixmap wood.xpm)
TitleStyle ActiveUp (-- Flat) ActiveDown  \
  (-- Raised) Inactive (-- Flat)</PRE></blockquote>
<P>



This sets the &quot;ActiveUp&quot; state to a horizontal gradient, the
&quot;ActiveDown&quot; state to solid red, and the &quot;Inactive&quot; state to a
tiled wood pixmap. Finally, &quot;ActiveUp&quot; is set to look flat, while
&quot;ActiveDown&quot; set to be sunk (the
<I>Raised</I>

flag for the &quot;ActiveDown&quot; state causes it to appear sunk due to
relief inversion), and &quot;Inactive&quot; is set to flat as well. An
example which sets flags for all states:


<P>


<blockquote><PRE>TitleStyle -- flat</PRE></blockquote>
<P>



For a flattened look:


<P>


<blockquote><PRE>TitleStyle -- flat
ButtonStyle All ActiveUp (-- flat) Inactive \
  (-- flat)</PRE></blockquote>
<P>



<P>
<DT><B>UpdateDecor [</B><I>decor</I><B>]</B>

<DD>
This command is kept mainly for backwards compatibility.  Since
all elements of a decor are updated immediately when they are
changed, this command is mostly useless.
<P>
Updates window decorations.
<I>decor</I>

is an optional argument which specifies the
<I>decor</I>

to update.  If given, only windows which are assigned to that
particular
<I>decor</I>

are updated.  This command is useful, for instance, after a
<B>ButtonStyle</B>, <B>TitleStyle</B> or <B>BorderStyle</B>

(possibly used in conjunction with
<B>AddToDecor</B>).

Specifying an invalid decor results in all windows being
updated. This command is less disturbing than
<B>Recapture</B>,

but does not affect window style options as
<B>Recapture</B>

does.
<P>
<P>
</DL>
<A NAME="lbBM">&nbsp;</A>
<H3>COMMANDS CONTROLLING THE VIRTUAL DESKTOP</H3>

<P>
<DL COMPACT>
<DT><B>Desk</B> <I>arg1</I> <B>[</B> <I>arg2</I> <B>] [</B> <I>min max</I> <B>]</B><DD>
This command has been renamed.  Please see
<B>GotoDesk</B>

command.
<P>
<DT><B>DeskTopSize </B><I>Horizontal</I><B>x</B><I>Vertical</I>

<DD>
Defines the virtual desktop size in units of the physical screen
size.
<P>
<DT><B>EdgeResistance </B><I>scrolling moving </I><B>[</B><I>xinerama-moving</I><B>]</B>

<DD>
Tells how hard it should be to change the desktop viewport by
moving the mouse over the edge of the screen and how hard it
should be to move a window over the edge of the screen.
<P>
The first parameter tells how many milliseconds the pointer must
spend on the screen edge before fvwm moves the viewport.  This is
intended for people who use


<P>


<blockquote><PRE>EdgeScroll 100 100</PRE></blockquote>
<P>



but find themselves accidentally flipping pages when they don't
want to.
<P>
The second parameter tells how many pixels over the edge of the
screen a window's edge must move before it actually moves
partially off the screen.  By default the viewport is moved a full
page in the requested direction, but if you used
<B>EdgeScroll</B>

and set any values other than zero they is used instead.
<P>
Note that, with


<P>


<blockquote><PRE>EdgeScroll 0 0</PRE></blockquote>
<P>



it is still possible to move or resize windows across the edge of
the current screen.  By making the first parameter to
<B>EdgeResistance</B>

10000 this type of motion is impossible.  With
<B>EdgeResistance</B>

less than 10000 but greater than 0 moving over pages becomes
difficult but not impossible.  See also
<B>EdgeThickness</B>.

<P>
The optional third parameter does the same as the second, but for
individual Xinerama screens.  If omitted,
<I>xinerama-moving</I>

will be set to the value of
<I>moving</I>.

Set
<I>xinerama-moving</I>

to zero to ignore individual screen edges.
<P>
<DT><B>EdgeScroll </B><I>horizontal</I><B>[</B><I>p</I><B>] </B><I>vertical</I><B>[</B><I>p</I><B>]</B>

<DD>
Specifies the percentage of a page to scroll when the cursor hits
the edge of a page.  A trailing
'<I>p</I>'

changes the interpretation to mean pixels.  If you don't want any
paging or scrolling when you hit the edge of a page include


<P>


<blockquote><PRE>EdgeScroll 0 0</PRE></blockquote>
<P>



in your
<I>.fvwm2rc</I>

file, or possibly better, set the
<B>EdgeThickness</B>

to zero.  See the
<B>EdgeThickness</B>

command. If you want whole pages, use


<P>


<blockquote><PRE>EdgeScroll 100 100</PRE></blockquote>
<P>



Both
<I>horizontal</I> and <I>vertical</I>

should be positive numbers.
<P>
If the
<I>horizontal</I> and <I>vertical</I>

percentages are multiplied by 1000 then scrolling wraps around at
the edge of the desktop.  If


<P>


<blockquote><PRE>EdgeScroll 100000 100000</PRE></blockquote>
<P>



is used fvwm scrolls by whole pages, wrapping around at the edge
of the desktop.
<P>
<DT><B>EdgeThickness </B><I>0</I><B>|</B><I>1</I><B>|</B><I>2</I>

<DD>
This is the width or height of the invisible window that fvwm
creates on the edges of the screen that are used for the edge
scrolling feature.
<P>
In order to enable page scrolling via the mouse, four windows
called the &quot;pan frames&quot; are placed at the very edge of the
screen. This is how fvwm detects the mouse's presence at the
window edge. Because of the way this works, they need to be at the
top of the stack and eat mouse events, so if you have any kind of
error along the lines of: &quot;mouse clicks at the edge of the screen
do the wrong thing&quot; you're having trouble with the pan frames and
(assuming you don't use the mouse to flip between pages) should
set the EdgeThickness to 0.
<P>
A value of
<I>0</I>

completely disables mouse edge scrolling, even while dragging a
window.
<I>1</I>

gives the smallest pan frames, which seem to work best except on
some servers.
<P>
<I>2</I>

is the default.
<P>
Pan frames of
<I>1</I> or <I>2</I>

pixels can sometimes be confusing, for example, if you drag a
window over the edge of the screen, so that it straddles a pan
frame, clicks on the window, near the edge of the screen are
treated as clicks on the root window.
<P>
<DT><B>GotoDesk</B> <I>prev</I> <B>|</B> <I>arg1</I> <B>[</B> <I>arg2</I> <B>] [</B> <I>min max</I> <B>]</B><DD>
Switches the current viewport to another desktop (workspace,
room).
<P>
The command takes 1, 2, 3, or 4 arguments.  A single argument is
interpreted as a relative desk number.  Two arguments are
understood as a relative and an absolute desk number.  Three
arguments specify a relative desk and the minimum and maximum of
the allowable range. Four arguments specify the relative,
absolute, minimum and maximum values.  (Desktop numbers can be
negative).  If a literal
<I>prev</I>

is given as the single argument, the last visited desk number is
used.
<P>
If
<I>arg1</I>

is non zero then the next desktop number is the current desktop
number plus
<I>arg1</I>.

<P>
If
<I>arg1</I>

is zero then the new desktop number is
<I>arg2</I>.

(If
<I>arg2</I>

is not present, then the command has no effect.)
<P>
If
<I>min</I> and <I>max</I>

are given, the new desktop number is no smaller than
<I>min</I>

and no bigger than
<I>max</I>.

Values out of this range are truncated (if you gave an absolute
desk number) or wrapped around (if you gave a relative desk
number).
<P>
The syntax is the same as for
<B>MoveToDesk</B>,

which moves a window to a different desktop.
<P>
The number of active desktops is determined dynamically.  Only
desktops which contain windows or are currently being displayed
are active.  Desktop numbers must be between 2147483647 and
-2147483648 (is that enough?).
<P>
<DT><B>GotoDeskAndPage </B><I>prev</I><B> | </B><I>desk xpage ypage</I>

<DD>
Switches the current viewport to another desktop and page, similar
to the
<B>GotoDesk</B> and <B>GotoPage</B>

commands.  The new desk is
<I>desk</I>

and the new page is
(<I>xpage</I>,<I>ypage</I>).

<P>
<DT><B>GotoPage</B> <I>prev</I> <B>|</B> <I>x</I> <B>[</B> <I>p</I> <B>]</B> <I>y</I> <B>[</B> <I>p</I> <B>]</B><DD>
Moves the desktop viewport to page (x,y).  The upper left page is
(0,0), the upper right is (M,0), where M is one less than the
current number of horizontal pages specified in the
<B>DeskTopSize</B>

command.  The lower left page is (0,N), and the lower right page
is (M,N), where N is the desktop's vertical size as specified in
the
<B>DeskTopSize</B>

command.  To switch to a page relative to the current one add a
trailing
'<I>p</I>'

after any or both numerical arguments.  To go to last visited page
use
<I>prev</I>

as the first argument.  The
<B>GotoPage</B>

function should not be used in a pop-up menu.
<P>
Examples:


<P>


<blockquote><PRE># Go to page (2,3)
GotoPage 2 3

# Go to lowest and rightmost page
GotoPage -1 -1

# Go to last page visited
GotoPage prev

# Go two pages to the right and one page up
GotoPage +2p -1p</PRE></blockquote>
<P>



<P>
<DT><B>Scroll</B> <I>horizonal</I> <B>[</B> <I>p</I> <B>]</B> <I>vertical</I> <B>[</B> <I>p</I> <B>]</B><DD>
Scrolls the virtual desktop's viewport by
<I>horizontal</I>

pages in the x-direction and
<I>vertical</I>

pages in the y-direction.  Either or both entries may be negative.
Both
<I>horizontal</I> and <I>vertical</I>

values are expressed in percent of pages, so


<P>


<blockquote><PRE>Scroll 100 100</PRE></blockquote>
<P>



means to scroll down and left by one full page.


<P>


<blockquote><PRE>Scroll 50 25</PRE></blockquote>
<P>



means to scroll left half a page and down a quarter of a page.
The
<B>Scroll</B>

function should not be called from pop-up menus.  Normally,
scrolling stops at the edge of the desktop.
<P>
If the
<I>horizontal</I> and <I>vertical</I>

percentages are multiplied by 1000 then scrolling wraps around at
the edge of the desktop.  If


<P>


<blockquote><PRE>Scroll 100000 0</PRE></blockquote>
<P>



is executed over and over fvwm moves to the next desktop page on
each execution and wraps around at the edge of the desktop, so
that every page is hit in turn.
<P>
If the letter
'<I>p</I>'

is appended to each coordinate
(<I>horizontal</I> and/or <I>vertical</I>),

then the scroll amount is measured in pixels.
<P>
<DT><B>Xinerama </B><I>bool</I>

<DD>
Enables Xinerama support if the boolean argument is true and
disables it if the argument is false.  Calling this command
without arguments turns on Xinerama support it was disabled before
and turns it off if it was enabled.  For example:


<P>


<blockquote><PRE># Turn Xinerama support on, use primary screen 2
XineramaPrimaryScreen 2
Xinerama on
#Turn it off again
Xinerama off</PRE></blockquote>
<P>



<P>
<DT><B>XineramaPrimaryScreen [</B><I>primary-screen</I><B>]</B>

<DD>
Takes an integer number or 'g' or 'c' as its argument.  A number
is taken as the number of the Xinerama screen that is to be used
as the primary screen.  The primary screen is the preferred screen
to place windows.  Any number that is zero or more is taken as the
primary screen's number.  Instead, the letter 'c' indicates to use
the curent screen (containing the pointer) whenaver the primary
screen is used.  This may be very confusing under some
circumstances.  With 'g', the global screen is used as the primary
screen, effectively disabling the primary screen.  Calling this
function with any other argument (including none) resets the
primary screen to 0.  For Example
<P>
<DT><B>XineramaSls [</B><I>bool</I><B>]</B>

<DD>
For multi-screen implementations other than Xinerama, such as
Single Logical Screen, it is possible to simulate a Xinerama
configuration if the total screen seen by FVWM is made up of
equal sized monitors in a rectangular grid.  The
<B>XineramaSls</B>

command turns SLS support on or off or toggles it to the opposite
state, depending on if the boolean argument is &quot;True&quot;, &quot;False&quot; or
&quot;toggle&quot;.  If no argument is given, this is treated like &quot;toggle&quot;.
The default layout uses 1 by one screens.  To configure the
layout, use the
<B>XineramaSlsSize</B>

command.
<P>
<DT><B>XineramaSlsSize </B><I>Horizontal</I><B>x</B><I>Vertical</I>

<DD>
This command configures the layout of the Single Logical screen
feature.  It takes two arguments,
<I>Horizontal</I> and <I>Vertical</I>

which must be an integer value dividing evenly into the total
desktop width, and height height.  For an example with two
monitors side by side which appear as one screen through the
X-Server with the right screen as the primary screen, use:


<P>


<blockquote><PRE>XineramaSlsSize 2x1
XineramaSlsOn
XineramaPrimaryScreen 1
XineramaOn</PRE></blockquote>
<P>



<P>
<P>
</DL>
<A NAME="lbBN">&nbsp;</A>
<H3>COMMANDS FOR USER FUNCTIONS AND SHELL COMMANDS</H3>

<P>
<DL COMPACT>
<DT><B>AddToFunc [</B> <I>name</I> <B>[</B> <I>I</I> <B>|</B> <I>M</I> <B>|</B> <I>C</I> <B>|</B> <I>H</I> <B>|</B> <I>D action</I> <B>]]</B><DD>
Begins or adds to a function definition.  Here is an example:


<P>


<blockquote><PRE>AddToFunc Move-or-Raise I Raise
 + M Move
 + D Lower</PRE></blockquote>
<P>



The function name is &quot;Move-or-Raise&quot;, and could be invoked from a menu
or a mouse binding or key binding:


<P>


<blockquote><PRE>Mouse 1 TS A Move-or-Raise</PRE></blockquote>
<P>



The
<I>name</I>

must not contain embedded whitespace.  No guarantees are made
whether function names with embedded whitespace work or not.  This
behaviour may also change in the future without further notice.
The letter before the
<I>action</I>

tells what kind of action triggers the command which follows it.
'<I>I</I>'

stands for &quot;Immediate&quot;, and is executed as soon as the function is
invoked.
'<I>M</I>'

stands for &quot;Motion&quot;, i.e. if the user starts moving the mouse.
'<I>C</I>'

stands for &quot;Click&quot;, i.e., if the user presses and releases the
mouse.
'<I>H</I>'

stands for &quot;Hold&quot;, i.e. if the user presses a mouse button and
holds it down for more than
<B>ClickTime</B>

milliseconds.
'<I>D</I>'

stands for &quot;Double-click&quot;. The action
'<I>I</I>'

causes an action to be performed on the button-press, if the
function is invoked with prior knowledge of which window to act
on.
<P>
There is a number of predefined symbols that are replaced by
certain values if they appear on the command line.  Please refer
to the
<B>COMMAND EXPANSION</B>

section for details.
<P>
Examples:
<P>
If you call


<P>


<blockquote><PRE>Key F10 R A Function MailFunction \
  xmh &quot;-font fixed&quot;</PRE></blockquote>
<P>



and &quot;MailFunction&quot; is


<P>


<blockquote><PRE>AddToFunc MailFunction
 + I Next ($0) Iconify off
 + I Next (AcceptsFocus, $0) focus
 + I None ($0) Exec exec $0 $1</PRE></blockquote>
<P>



Then the last line of the function becomes


<P>


<blockquote><PRE> + I None (xmh) Exec exec xmh -font fixed</PRE></blockquote>
<P>



The expansion is performed as the function is executed, so you can
use the same function with all sorts of different arguments.  You
could use


<P>


<blockquote><PRE>Key F11 R A Function MailFunction \
  zmail &quot;-bg pink&quot;</PRE></blockquote>
<P>



in the same
<I>.fvwm2rc</I>,

if you wanted.  An example of using &quot;$w&quot; is:


<P>


<blockquote><PRE>AddToFunc PrintFunction
 + I Raise
 + I Exec xdpr -id $w</PRE></blockquote>
<P>



Note that &quot;$$&quot; is expanded to '$'.
<P>
Another example: bind right mouse button within the window button
number 6 (this is a minimize button for the win95 theme) to
iconify all windows of the same resource:


<P>


<blockquote><PRE>AddToFunc FuncIconifySameResource &quot;I&quot; \
  All ($r) Iconify on
Mouse 3 6 A FuncIconifySameResource</PRE></blockquote>
<P>



<P>
<DT><B>Beep</B>

<DD>
As might be expected, this makes the terminal beep.
<P>
<DT><B>DestroyFunc </B><I>function</I>

<DD>
Deletes a function, so that subsequent references to it are no
longer valid.  You can use this to change the contents of a
function during a fvwm session.  The function can be rebuilt using
<B>AddToFunc</B>.



<P>


<blockquote><PRE>DestroyFunc PrintFunction</PRE></blockquote>
<P>



<P>
<DT><B>Echo </B><I>string</I>

<DD>
Prints a message to
<I>stderr</I>.

Potentially useful for debugging things in your
<I>.fvwm2rc</I>.



<P>


<blockquote><PRE>Echo Beginning style definitions...</PRE></blockquote>
<P>



<P>
<DT><B>Exec </B><I>command</I>

<DD>
Executes
<I>command</I>.

You should not use an ampersand '&amp;' at the end of the command. You
probably want to use an additional &quot;exec&quot; at the beginning of
<I>command</I>.

Without that, the shell that fvwm invokes to run your command
stays until the command exits.  In effect, you'll have twice as
many processes running as you need.  Note that some shells are
smart enough to avoid this, but it never hurts to include the
&quot;exec&quot; anyway.
<P>
The following example binds function key
<FONT SIZE="-1">F1</FONT>
in the root window, with no modifiers, to the exec function. The
program rxvt is started with an assortment of options.
<P>


<P>


<blockquote><PRE>Key F1 R N Exec exec rxvt -fg yellow -bg blue \
  -e /bin/tcsh</PRE></blockquote>
<P>



Note that this function doesn't wait for
<I>command</I>

to complete, so things like:


<P>


<blockquote><PRE>Exec &quot;echo AddToMenu ... &gt; /tmp/file&quot;
Read /tmp/file</PRE></blockquote>
<P>



do not work reliably.
<P>
<DT><B>ExecUseShell [</B><I>shell</I><B>]</B>

<DD>
Makes the
<B>Exec</B>

command use the specified shell, or the value of the
<I>$SHELL</I>

environment variable if no shell is specified, instead of the
default Bourne shell
(<I>/bin/sh</I>).



<P>


<blockquote><PRE>ExecUseShell
ExecUseShell /usr/local/bin/tcsh</PRE></blockquote>
<P>



<P>
<DT><B>Function </B><I>FunctionName</I>

<DD>
Used to bind a previously defined function to a key or mouse
button. The following example binds mouse button 1 to a function
called &quot;Move-or-Raise&quot;, whose definition was provided as an
example earlier in this man page.  After performing this binding
fvwm executes the &quot;move-or-raise&quot; function whenever button 1 is
pressed in a window's title-bar.


<P>


<blockquote><PRE>Mouse 1 T A Function Move-or-Raise</PRE></blockquote>
<P>



The keyword
<B>Function</B>

may be omitted if
<I>FunctionName</I>

does not coincide with a fvwm built-in function name
<P>
<DT><B>Nop</B>

<DD>
Does nothing.  This is used to insert a blank line or separator in a
menu.  If the menu item specification is


<P>


<blockquote><PRE>Nop &quot; &quot;</PRE></blockquote>
<P>



then a blank line is inserted.  If it looks like


<P>


<blockquote><PRE>Nop &quot;&quot;</PRE></blockquote>
<P>



then a separator line is inserted.  Can also be used as the
double-click action for
<B>Menu</B> or <B>Popup</B>.

<P>
<DT><B>PipeRead </B><I>command</I><B> [</B><I>quiet</I><B>]</B>

<DD>
Causes fvwm to read commands from the output of the
<I>command</I>.

This
<I>command</I>

is executed by
<I>/bin/sh</I>

as if you typed it on the command line.  If the command consists
of more than one word it must be quoted.  Useful for building up
dynamic menu entries based on a directories contents, for
example. If the keyword
<I>Quiet</I>

follows the command no message is produced if the
<I>command</I>

is not found.
<P>
Example:


<P>


<blockquote><PRE>AddToMenu HomeDirMenu
PipeRead 'for i in $HOME/*; \
  do echo &quot;+ $i Exec xterm -e vi $i&quot;; done'</PRE></blockquote>
<P>



<P>
<DT><B>Read </B><I>filename</I><B> [</B><I>quiet</I><B>]</B>

<DD>
Causes fvwm to read commands from the file named
<I>filename</I>.

If the keyword
<I>Quiet</I>

follows the command no message is produced if the file is not
found.  If the file name does not begin with a slash ('/'), fvwm
looks in the user's data directory, then the system data
directory.  The user's data directory is by default
<I>$HOME/.fvwm</I>.

It can be overridden by exporting
<I>FVWM_USERDIR</I>

set to any other directory.
<P>
<DT><B>SetEnv </B><I>variable [value]</I>

<DD>
Set an environment variable to a new value, similar to the shell's
export or setenv command.  The
<I>variable</I>

and its
<I>value</I>

are inherited by processes started directly by fvwm.  This can be
especially useful in conjunction with the
<B>FvwmM4</B>

module.  For example:


<P>


<blockquote><PRE>SetEnv height HEIGHT</PRE></blockquote>
<P>



makes the FvwmM4-set variable
<I>HEIGHT</I>

usable by processes started by fvwm as the environment variable
<I>$height</I>.

If
<I>value</I>

includes whitespace, you should enclose it in quotes.  If no
<I>value</I>

is given, the
<I>variable</I>

is deleted from the environment as if
<B>UnsetEnv</B>

had been called.
<P>
<DT><B>Silent </B><I>command</I>

<DD>
A number of built in functions require a window to operate on.  If
no window was selected when such a function is invoked the user is
asked to select a window.  Sometimes this behavior is unwanted,
for example if the function was called by a module and the window
that was selected at first does not exist anymore.  You can
prevent this by putting
<B>Silent</B>

in front of the fvwm
<I>command</I>.

If a function that needs a window is called with
<B>Silent</B>

without a window selected, it simply returns without doing
anything. If
<B>Silent</B>

is used on a user defined function it affects all function and sub
function calls until the original function exits.
<P>
Examples:


<P>


<blockquote><PRE>Silent Move 0 0
Silent User_defined_function</PRE></blockquote>
<P>



<P>
<DT><B>UnsetEnv </B><I>variable</I>

<DD>
Unset an environment variable, similar to shell's export or
unsetenv command. The
<I>variable</I>

then is removed from the environment array inherited by processes
started directly by fvwm.
<P>
<DT><B>Wait </B><I>windowname</I>

<DD>
This built-in is intended to be used in fvwm functions only.  It
causes execution of a function to pause until a new window with
the title
<I>windowname</I>

appears.  Fvwm remains partially functional during a wait.  This
is particularly useful in the &quot;InitFunction&quot; if you are trying to
start windows on specific desktops:


<P>


<blockquote><PRE>AddToFunc InitFunction
 + I exec xterm -geometry 80x64+0+0
 + I Wait xterm
 + I Desk 0 2
 + I Exec exec xmh -font fixed -geometry \
       507x750+0+0
 + I Wait xmh
 + I Desk 0 0</PRE></blockquote>
<P>



The above function starts an xterm on the current desk, waits for
it to map itself, then switches to desk 2 and starts an xmh.
After the xmh window appears control moves to desk 0.
<P>
You can escape from a
<B>Wait</B>

pause by pressing
<FONT SIZE="-1">Ctrl-Alt-Escape</FONT>
(where
<FONT SIZE="-1">Alt</FONT>
is the first modifier).  To redefine this key sequence see the
<B>EscapeFunc</B>

command.
<P>
<P>
</DL>
<A NAME="lbBO">&nbsp;</A>
<H3>CONDITIONAL COMMANDS</H3>

<P>
<DL COMPACT>
<DT><B>All [(</B><I>conditions</I><B>)] </B><I>command</I>

<DD>
Execute.
<I>command</I>

on all windows meeting the conditions.
<I>Conditions</I>

are used exactly as with the
<B>Current</B>

command.
<P>
<DT><B>Current [(</B><I>condition</I><B>...</B><I>)] </I><B>command</B>

<DD>
Performs
<I>command</I>

on the currently focused window if it satisfies all
<I>conditions</I>.

The
<I>conditions</I>

are a list of keywords from the list below and are separated by
commas or whitespace.  Conditions include
&quot;AcceptsFocus&quot;, &quot;!AcceptsFocus&quot;
&quot;Iconic&quot;, &quot;!Iconic&quot;,
&quot;Visible&quot;, &quot;!Visible&quot;,
&quot;Raised&quot;, &quot;!Raised&quot;,
&quot;Layer [n]&quot;,
&quot;Sticky&quot;, &quot;!Sticky&quot;,
&quot;Maximized&quot;, &quot;!Maximized&quot;,
&quot;Shaded&quot;, &quot;!Shaded&quot;,
&quot;Transient&quot;, &quot;!Transient&quot;,
&quot;PlacedByButton3&quot;, &quot;!PlacedByButton3&quot;,
&quot;PlacedByFvwm&quot;, &quot;!PlacedByFvwm&quot;,
&quot;CurrentDesk&quot;, &quot;CurrentPage&quot;, &quot;CurrentScreen&quot;
&quot;CurrentGlobalPage&quot;, &quot;CurrentPageAnyDesk&quot; and &quot;CurrentGlobalPageAnyDesk&quot;.
In addition, the
<I>condition</I>

may include one window name to match to.  The window name may
include the wildcards '*' and '?'.  The window name, icon name,
class, and resource are considered when attempting to find a
match.  The window name can begin with '!' which prevents
<I>command</I>

if any of the window name, icon name, class or resource match.
<P>
The &quot;AcceptsFocus&quot; condition excludes all windows that do not want
the input focus (the application has set the &quot;Input hints&quot; for the
window to False) and do not use the
<I>Lenience</I>

option of the
<B>Style</B>

command.  Also, all windows using the
<I>NoFocus</I>

style are ignored.
<P>
The &quot;CurrentDesk&quot; condition excludes all window that are not on
the current desk.
<P>
The &quot;CurrentPage&quot; condition excludes all window that are not on
the current desk or not on the current page. If Xinerama support
is enabled, only windows on the screen that contains the mouse
pointer are considered to match.
<P>
The &quot;CurrentGlobalPage&quot; condition excludes all window that are not
on the current desk or not on the current page. The screen does
not matter if Xinerama support is enabled.
<P>
The &quot;CurrentScreen&quot; and &quot;CurrentPageAnyDesk&quot; conditions exclude
all window that are not on the current page but that may be on any
desk.
<P>
The &quot;CurrentGlobalPage&quot; condition excludes all window that are not
on the current desk or not on the current page. If Xinerama
support is enabled, only windows on the screen that contains the
mouse pointer are considered to match.
<P>
The &quot;CurrentGlobalPageAnyDesk&quot; condition excludes all window that
are not on the current page but that may be on any desk.  The
screen does not matter if Xinerama support is enabled.
<P>
The argument of the &quot;Layer&quot; condition defaults to the layer of the
focus window.
<P>
The &quot;PlacedByButton3&quot; condition is fulfilled if the last
interactive motion of the window (with the
<B>Move</B>

command) was ended by pressing mouse button 3.  This is especially
useful with the
<I>ManualPlacement</I>

option of the
<B>Style</B>

command.
<P>
The &quot;PlacedByFvwm&quot; condition excludes all windows that have been placed
manually or by using the user or program position hint.
<P>
Note that earlier versions of fvwm required the conditions to be
enclosed in brackets instead of parentheses (this is still
supported for backwards compatibility).
<P>
<DT><B>Direction </B><I>direction</I><B> [(</B><I>conditions</I><B>)] </B><I>command</I>

<DD>
Performs
<I>command</I>

(typically
<B>Focus</B>)

on a window in the given direction which satisfies all
<I>conditions</I>.

Conditions are the same as for
<B>Current</B>.

The
<I>direction</I>

may be one of &quot;North&quot;, &quot;Northeast&quot;, &quot;East&quot;, &quot;Southeast&quot;, &quot;South&quot;,
&quot;Southwest&quot;, &quot;West&quot; and &quot;Northwest&quot;.  Which window
<B>Direction</B>

selects depends on angle and distance between the center points of
the windows.  Closer windows are considered a better match than
those farther away.
<P>
<DT><B>Next [(</B><I>conditions</I><B>)] </B><I>command</I>

<DD>
Performs
<I>command</I>

(typically
<B>Focus</B>)

on the next window which satisfies all
<I>conditions</I>.

Conditions are the same as for
<B>Current</B>

with the addition of &quot;CirculateHit&quot; which overrides the
<I>CirculateSkip </I><B>Style</B>

attribute, &quot;CirculateHitIcon&quot; which overrides the
<I>CirculateSkipIcon </I><B>Style</B>

attribute for iconified windows and &quot;CirculateHitShaded&quot; which
does the same for shaded windows.
<P>
<DT><B>None [(</B><I>conditions</I><B>)] </B><I>command</I>

<DD>
Performs
<I>command</I>

if no window which satisfies all
<I>conditions</I>

exists.  Conditions are the same as for
<B>Next</B>.

<P>
<DT><B>Pick [(</B><I>conditions</I><B>)] </B><I>command</I>

<DD>
<B>Pick</B>

works like
<B>Function</B>

if invoked in the context of a window.  If invoked in the root
window, it first asks the user to pick a window and then executes the
<I>command</I>

in the context of that window.  This avoids annoying multiple
selections with complex functions.  The command is executed only
if the given
<I>conditions</I>

are met.  The conditions are the same as for
<B>Next</B>.

<P>
<DT><B>Prev [(</B><I>conditions</I><B>)] </B><I>command</I>

<DD>
Performs
<I>command</I>

(typically
<B>Focus</B>)

on the previous window which satisfies all
<I>conditions</I>.

Conditions are the same as for
<B>Next</B>.

<P>
<DT><B>WindowId [</B> <I>id</I> <B>] [(</B> <I>conditions</I> <B>)] | [</B> <I>root</I> <B>[</B> <I>screen</I> <B>]]</B> <I>command<DD>
The
</I><B>WindowId</B>

function is similar to the
<B>Next</B> and <B>Prev</B>

functions, except that it looks for a specific window
<I>id</I>

and runs the specified
<I>command</I>

on it.  The optional
<I>conditions</I>

are the same as for
<B>Current</B>.

The second form of syntax retrieves the window id of the root
window of the given
<I>screen</I>.

If no
<I>screen</I>

is given, the current screen is assumed.  The window indicated by
<I>id</I>

may belong to a window not managed by fvwm or even a window on a
different screen.  Although most commands can not operate on such
windows, there are some exceptions, for example the
<B>WarpToWindow</B>

command.


<P>


<blockquote><PRE>WindowId 0x34567890 Raise
WindowId root 1 WarpToWindow 50 50
WindowId $0 (Silly_Popup) Delete</PRE></blockquote>
<P>



Mostly this is useful for functions used with the
<B>WindowList</B>

built-in, or for selective processing of
<B>FvwmEvent</B>

calls (as in the last example).
<P>
<P>
</DL>
<A NAME="lbBP">&nbsp;</A>
<H3>MODULE COMMANDS</H3>

<P>
Fvwm maintains a database of module configuration lines in a form


<P>


<blockquote><PRE><B>*</B><I>&lt;ModuleName&gt;</I><B>: </B><I>&lt;Config-Resource&gt;</I></PRE></blockquote>
<P>



where
<I>&lt;ModuleName&gt;</I>

is either a real module name or an alias.
<P>
This database is initially filled from config file (or from
output of
<B>-cmd</B>

config command), and can be later modified either by user (via
<B>FvwmCommand</B>)

or by modules.
<P>
When modules are run, they read appropriate portion of database.
(The concept of this database is similar to one used in X resource
database).
<P>
Commands for manipulating module configuration database are
described below.
<P>
<DL COMPACT>
<DT><B>*</B><I>module_config_line</I>

<DD>
Defines a module configuration.
<I>module_config_line</I>

consists of a module name (or a module alias) and a module
resource line. The new syntax allows a delimiter, a colon and
optional spaces, between the module name and the rest of the line,
this is recommended to avoid conflicts.


<P>


<blockquote><PRE>*FvwmIconBox: MaxIconSize 48x48
*FvwmPager: WindowBorderWidth 1
*FvwmButtons-TopRight: Geometry 100x100-0+0
*FvwmButtons-Bottom: Geometry +0-0</PRE></blockquote>
<P>



<P>
<DT><B>DestroyModuleConfig </B><I>module_config</I>

<DD>
Deletes module configuration entries, so that new configuration
lines may be entered instead.  This also sometimes the only way to
turn back some module settings, previously defined.  This changes
the way a module runs during a fvwm session without
restarting.  Wildcards can be used for portions of the name as
well.
<P>
The new non-conflicting syntax allows a delimiter, a colon and
optional spaces between the module name and the rest of the line.
In this case a module name (or alias) can't have wildcards.


<P>


<blockquote><PRE>DestroyModuleConfig FvwmButtons*
DestroyModuleConfig FvwmForm: Fore
DestroyModuleConfig FvwmIconBox: Max*</PRE></blockquote>
<P>



<P>
<DT><B>KillModule </B><I>modulename</I><B> [</B><I>modulealias</I><B>]</B>

<DD>
Causes the module which was invoked with name
<I>modulename</I>

to be killed.  The name may include wildcards. If
<I>modulealias</I>

is given, only modules started with the given alias are killed.


<P>


<blockquote><PRE>KillModule FvwmPager  # kill all pagers

Module FvwmEvent SoundEvent
KillModule FvwmEvent SoundEvent</PRE></blockquote>
<P>



<P>
<DT><B>Module </B><I>modulename</I><B> [</B><I>moduleparams</I><B>]</B>

<DD>
Specifies a module with its optional parameters which should be
spawned. Currently several modules, including
<B>FvwmButtons</B>, <B>FvwmEvent</B>, <B>FvwmForm</B>, <B>FvwmGtk</B>, 

<B>FvwmPager</B>, <B>FvwmScript</B>

support aliases.  Aliases are useful if more than one instance of
the module should be spawned.  Aliases may be configured
separately using
<B>*</B>

syntax described above.  To start a module
<B>FvwmForm</B>

using an alias
<I>MyForm</I>,

the following syntax may be used:


<P>


<blockquote><PRE>Module FvwmForm MyForm</PRE></blockquote>
<P>



<P>
At the current time the available modules (included with fvwm) are
<B>FvwmAnimate</B>

(produces animation effects when a window is iconified or
de-iconifed),
<B>FvwmAudio</B>

(makes sounds to go with window manager actions),
<B>FvwmAuto</B>

(an auto raise module),
<B>FvwmBacker</B>

(to change the background when you change desktops),
<B>FvwmBanner</B>

(to display a spiffy XPM),
<B>FvwmButtons</B>

(brings up a customizable tool bar),
<B>FvwmCommandS</B>

(a command server to use with shell's FvwmCommand client),
<B>FvwmConsole</B>

(to execute fvwm commands directly),
<B>FvwmCpp</B>

(to preprocess your
<I>.fvwm2rc</I>

with cpp),
<B>FvwmDebug</B>

(to help debug fvwm),
<B>FvwmDragWell</B>

(the place to drag&amp;drop to),
<B>FvwmEvent</B>

(trigger various actions by events),
<B>FvwmForm</B>

(to bring up dialogs),
<B>FvwmGtk</B>

(to bring up GTK menus and dialogs),
<B>FvwmIconBox</B>

(like the mwm IconBox),
<B>FvwmIconMan</B>

(a flexible icon manager),
<B>FvwmIdent</B>

(to get window info),
<B>FvwmM4</B>

(to preprocess your
<I>.fvwm2rc</I>

with m4),
<B>FvwmPager</B>

(a mini version of the desktop),
<B>FvwmSave</B>

(saves the desktop state in .xinitrc style),
<B>FvwmSaveDesk</B>

(saves the desktop state in fvwm commands),
<B>FvwmScript</B>

(another powerful dialog toolkit),
<B>FvwmScroll</B>

(puts scrollbars on any window),
<B>FvwmTaskBar</B>

(a Windows like task bar),
<B>FvwmTheme</B>

(manages colorsets, see below),
<B>FvwmWinList</B>

(a window list),
<B>FvwmWharf</B>

(an AfterStep like button bar).
These modules have their own man pages.  There may be other
modules out on there as well.
<P>
Note,
<B>FvwmTheme</B>

is a special module which manages colorsets. Most of other modules
and fvwm itself support colorsets and changing colors
dynamically. Colorsets will probably be the only method to specify
colors in the next stable fvwm release, and then the functionality
of FvwmTheme will be moved to the core fvwm.
<P>
<P>
Modules can be short lived transient programs or, like
<B>FvwmButtons</B>,

can remain for the duration of the X session.  Modules are
terminated by the window manager prior to restarts and quits, if
possible.  See the introductory section on modules.  The keyword
<B>Module</B>

may be omitted if
<I>modulename</I>

is distinct from all built-in and function names.
<P>
<DT><B>ModulePath </B><I>path</I>

<DD>
Specifies a colon separated list of directories in which to search
for modules.  To find a module, fvwm searches each directory in
turn and uses the first file found.  Directory names on the list
do not need trailing slashes.
<P>
The
<B>ModulePath</B>

may contain environment variables such as
<I>$HOME</I> (or <I>${HOME}</I>).

Further, a '+' in the
<I>path</I>

is expanded to the previous value of the
<I>path</I>,

allowing easy appending or prepending to the
<I>path</I>.

<P>
For example:


<P>


<blockquote><PRE>ModulePath ${HOME}/lib/fvwm/modules:+</PRE></blockquote>
<P>



The directory containing the standard modules is available via the
environment variable
<I>$FVWM_MODULEDIR</I>.

<P>
<DT><B>ModuleSynchronous  [</B><I>Expect string</I><B>] [</B><I>Timeout secs</I><B>] </B><I>modulename</I>

<DD>
The
<B>ModuleSynchronous</B>

command is very similar to
<B>Module</B><I>.</I>

Fvwm stops processing any commands and user input until the module
sends a string beginning with &quot;NOP FINISHED STARTUP&quot; back to fvwm.
If the optional
<I>Timeout</I>

is given fvwm gives up if the module sent no input back to fvwm
for
<I>secs</I>

seconds.  If the
<I>Expect</I>

option is given, fvwm waits for the given
<I>string</I>

instead.
<B>ModuleSynchronous</B>

should only be used during fvwm startup to enforce the order in
which modules are started.  This command is intended for use with
the
<B>FvwmTheme</B>

module since the configuration must be in place before any other
modules are started.
<P>
Warning: It is quite easy to hang fvwm with this command, even if
a timeout is given.  Be extra careful choosing the string to wait
for. Although all modules in the fvwm distribution send back the
&quot;NOP FINISHED STARTUP&quot; string once they have properly started up,
this may not be the case for third party modules.  Moreover, you
can try to escape from a locked
<B>ModuleSynchronous</B>

command by using the key sequence
<FONT SIZE="-1">Ctrl-Alt-Escape</FONT>
(see the
<B>EscapeFunc</B>).

<P>
<DT><B>ModuleTimeout </B><I>timeout</I>

<DD>
Specifies how many seconds fvwm waits for a module to respond. If
the module does not respond within the time limit then fvwm kills
it.
<I>timeout</I>

must be greater than zero, or it is reset to the default value of
30 seconds.
<P>
<DT><B>SendToModule </B><I>modulename string</I>

<DD>
Sends an arbitrary string (no quotes required) to all modules,
whose alias or name matching
<I>modulename</I>,

which may contain wildcards.  This only makes sense if the module
is set up to understand and deal with these strings though. Can be
used for module to module communication, or implementation of more
complex commands in modules.
<P>
<P>
</DL>
<A NAME="lbBQ">&nbsp;</A>
<H3>QUIT, RESTART AND SESSION MANAGEMENT COMMANDS</H3>

<P>
<DL COMPACT>
<DT><B>Quit</B>

<DD>
Exits fvwm, generally causing X to exit too.
<P>
<DT><B>QuitScreen</B>

<DD>
Causes fvwm to stop managing the screen on which the command was
issued.
<P>
<DT><B>QuitSession</B>

<DD>
Causes a session manager (if any) to shutdown the session.  This
command does not work for xsm, it seems that xsm does not
implement this functionality.  Use Unix signals to manage xsm
remotely.
<P>
<DT><B>Restart [</B><I>window_manager</I><B> [</B><I>params</I><B>]]</B>

<DD>
Causes fvwm to restart itself if
<I>window_manager</I>

is left blank, or to switch to an alternate window manager (or
other fvwm version) if
<I>window_manager</I>

is specified.  If the window manager is not in your default search
path, then you should use the full path name for
<I>window_manager</I>.

<P>
This command should not have a trailing ampersand.  The command
can have optional parameters with simple shell-like syntax.  You
can use
<I>~</I>

(is expanded to the user home directory) and environmental
variables .IR $VAR &quot; or &quot; ${VAR} . Here are several examples:


<P>


<blockquote><PRE>Key F1 R N Restart
Key F1 R N Restart fvwm2 -s
Key F1 R N Restart ~/bin/fvwm2 -f $HOME/.fvwm/main
Key F1 R N Restart fvwm1 -s -f .fvwm1rc
Key F1 R N Restart xterm -n '&quot;X console&quot;' \
  -T \&quot;X\ console\&quot; -e fvwm1 -s</PRE></blockquote>
<P>



If you need a native restart, we suggest only to use
<B>Restart</B>

command without parameters unless there is a reason not to. If you
use 'Restart fvwm2', all current command line arguments are lost,
while on Restart without parameters or with --pass-args, they are
preserved. Here are some cases when 'Restart fvwm2' causes
troubles:


<P>


<blockquote><PRE>* running fvwm under a session manager
* running fvwm with multi headed displays
* having command line arguments, like -f themes-rc or -cmd
* if the first fvwm2 in the $PATH is a different one</PRE></blockquote>
<P>



This is why we are issuing a warning on an old usage. If you
really want to restart to fvwm2 with no additional arguments, you
may get rid of this warning by using &quot;Restart fvwm2 -s&quot; or
&quot;Restart /full/path/fvwm2&quot;.
<P>
Note, currently with multi headed displays, restart of fvwms on
different screens works independently.
<P>
<DT><B>Restart </B><I>--pass-args window_manager</I>

<DD>
The same as
<B>Restart</B>

without parameters but the name for the current window manager is
replaced with the specified
<I>window_manager</I>

and original arguments are preserved.
<P>
This command is useful if you use initial arguments like


<P>


<blockquote><PRE>-cmd FvwmCpp</PRE></blockquote>
<P>



and want to switch to another fvwm version without losing the
initial arguments.
<P>
<DT><B>Restart </B><I>--dont-preserve-state</I><B> [</B><I>other-params</I><B>]</B>

<DD>
The same as


<P>


<blockquote><PRE><B>Restart [</B><I>other-params</I><B>]</B></PRE></blockquote>
<P>



but it does not save any window states over the restart.
<P>
Without this option,
<B>Restart</B>

preserves most per-window state by writing it to a file named
<I>.fs-restart-$HOSTDISPLAY</I>

in the user's home directory.
<P>
<DT><B>SaveSession</B>

<DD>
Causes a session manager (if any) to save the session.  This
command does not work for xsm, it seems that xsm does not
implement this functionality.  Use Unix signals to manage xsm
remotely.
<P>
<DT><B>SaveQuitSession</B>

<DD>
Causes a session manager (if any) to save and then shutdown the
session. This command does not work for xsm, it seems that xsm
does not implement this functionality.  Use Unix signals to manage
xsm remotely.
<P>
<P>
</DL>
<A NAME="lbBR">&nbsp;</A>
<H3>COLOR GRADIENTS</H3>

<P>
A color gradient is a background that changes its color gradually
from one hue to a different one.  Color gradients can be used by
various commands and modules of fvwm.  There are eight types of
gradients:
<B>HGradient</B>

is a horizontal gradient,
<B>VGradient</B>

is vertical,
<B>DGradient</B>

is diagonal from top left to bottom right,
<B>BGradient</B>

is backwards diagonal from bottom left to top right,
<B>SGradient</B>

is concentric squares,
<B>CGradient</B>

is concentric circles,
<B>RGradient</B>

is a radar like pattern and
<B>YGradient</B>

is a Yin Yang style (but without the dots).
<P>
The color gradient syntax has two forms:
<P>
<DL COMPACT>
<DT><B>?Gradient </B><I>colors start-color end-color</I>

<DD>
This form specifies a linear gradient.  The arguments denote the
total number of
<I>colors</I>

to allocate (between 2 and 1000), the initial color and the final color.
<P>
Example:


<P>


<blockquote><PRE>TitleStyle VGradient 20 rgb:b8/ce/bc rgb:5b/85/d0</PRE></blockquote>
<P>



<P>
<DT><B>?Gradient </B><I>colors segments color length color</I><B> [</B><I>length color</I><B>] ...</B>

<DD>
The second form specifies a nonlinear gradient.  The arguments are:
the total number of
<I>colors</I>

to allocate (between 2 and 1000), then the number of
<I>segments</I>.

For each segment, specify the starting
<I>color</I>,

a relative
<I>length</I>,

then the ending color.  Each subsequent segment begins with the
second color of the last segment.  The lengths may be any
non-negative integers.  The length of one segment divided by the
sum of all segment's lengths is the fraction of the colors that
are used for the segment.
</blockquote>
<P>
Examples:


<P>


<blockquote><PRE>MenuStyle * MenuFace DGradient \
  128 2 lightgrey 50 blue 50 white

# 20% gradient from red to blue,
# 30% from blue to black,
# 50% from black to grey
MenuStyle * DGradient 100 3 Red 20 Blue 30 \
  Black 50 Grey

# 50% from blue to green, then
# 50% from yellow to red
*FvwmTheme: Colorset 0 Blue Red HGradient \
  128 3 Blue 1000 Green 1 Yellow 1000 Red</PRE></blockquote>
<P>



<P>
</DL>
<A NAME="lbBS">&nbsp;</A>
<H2>ENVIRONMENT</H2>

<P>
<DL COMPACT>
<DT><I>DISPLAY</I>

<DD>
Fvwm starts on this display unless the
<I>-display</I>

option is given.
<DT><I>FVWM_MODULEDIR</I>

<DD>
Set by fvwm to the directory containing the standard fvwm modules.
<DT><I>FVWM_USERDIR</I>

<DD>
Used to determine the user's data directory for reading and
sometimes writing personal files. If this variable is not already
set, it is set by fvwm to $HOME/.fvwm, which is the default user's
data directory.
<DT><I>SESSION_MANAGER</I>

<DD>
Fvwm tries to contact this session manager.
<DT><I>SESSION_MANAGER_NAME</I>

<DD>
This is used mainly to determine xsm running to work around its
bug. If this variable is set to &quot;xsm&quot;, DiscardCommand is set as
xsm expects it and not as XSMP requires.  If you run fvwm under
xsm, you should set this variable to &quot;xsm&quot;, otherwise old state
files are not removed.
<DT><I>SM_SAVE_DIR</I>

<DD>
If this is set, fvwm saves its session data in this
directory. Otherwise it uses
<I>$HOME</I>.

Note, the state files are named
<I>.fs-??????</I>

and normally are removed automatically when not used anymore.
<P>
</DL>
<A NAME="lbBT">&nbsp;</A>
<H2>AUTHORS</H2>

<P>
Robert Nation with help from many people, based on twm code, which
was written by Tom LaStrange.  After Robert Nation came Charles
Hines, followed by Brady Montz. Currently fvwm is developed by a
number of people on the fvwm-workers mailing list.
<P>
<A NAME="lbBU">&nbsp;</A>
<H2>COPYRIGHT</H2>

<P>
Fvwm and all the modules, scripts and other files coming with the
distribution are subject to the GNU General Public License
(GPL). Please refer to the
<I>COPYING</I>

file that came with fvwm for details.
<P>
<A NAME="lbBV">&nbsp;</A>
<H2>BUGS</H2>

<P>
As of fvwm version 2.4.0 there were exactly 71.8 unidentified
bugs. Since then 22.825 bugs have been fixed.  Assuming that there
are at least 10 unidentified bugs for every identified one, that
leaves us with 71.8 - 22.825 + 10 * 22.825 = 277.225 unidentified
bugs. If we follow this to its logical conclusion we will have an
infinite number of unidentified bugs before the number of bugs can
start to diminish, at which point the program will be bug-free.
Since this is a computer program infinity = 3.4028e+38 if you
don't insist on double-precision.  At the current rate of bug
discovery we should expect to achieve this point in 4.27e+27
years.  I guess we better plan on passing this thing on to our
children...
<P>
Known bugs can be found in the fvwm bug tracking system
(accessible from the fvwm home page) and in the
<I>BUGS</I> or <I>TODO</I>

files in the distribution.  These files are no longer maintained
and may be out of date.
<P>
Bug reports can be sent to the fvwm-workers mailing list (see the
<I>FAQ</I>)

or reported through the bug tracking system.
<P>
The official fvwm homepage is
<B><A HREF="http://www.fvwm.org/">http://www.fvwm.org/</A></B>.

<P>
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">OPTIONS</A><DD>
<DT><A HREF="#lbAF">ANATOMY OF A WINDOW</A><DD>
<DT><A HREF="#lbAG">THE VIRTUAL DESKTOP</A><DD>
<DT><A HREF="#lbAH">USE ON MULTI-SCREEN DISPLAYS</A><DD>
<DT><A HREF="#lbAI">XINERAMA SUPPORT</A><DD>
<DT><A HREF="#lbAJ">INITIALIZATION</A><DD>
<DT><A HREF="#lbAK">COMPILATION OPTIONS</A><DD>
<DT><A HREF="#lbAL">ICONS</A><DD>
<DT><A HREF="#lbAM">MODULES</A><DD>
<DT><A HREF="#lbAN">ICCCM COMPLIANCE</A><DD>
<DT><A HREF="#lbAO">GNOME COMPLIANCE</A><DD>
<DT><A HREF="#lbAP">MWM COMPATIBILITY</A><DD>
<DT><A HREF="#lbAQ">OPEN LOOK and XVIEW COMPATIBILITY</A><DD>
<DT><A HREF="#lbAR">M4 PREPROCESSING</A><DD>
<DT><A HREF="#lbAS">CPP PREPROCESSING</A><DD>
<DT><A HREF="#lbAT">AUTO-RAISE</A><DD>
<DT><A HREF="#lbAU">CONFIGURATION FILES</A><DD>
<DT><A HREF="#lbAV">SUPPLIED CONFIGURATION</A><DD>
<DT><A HREF="#lbAW">KEYBOARD SHORTCUTS</A><DD>
<DT><A HREF="#lbAX">SESSION MANAGEMENT</A><DD>
<DT><A HREF="#lbAY">BOOLEAN ARGUMENTS</A><DD>
<DT><A HREF="#lbAZ">BUILT IN KEY AND MOUSE BINDINGS</A><DD>
<DT><A HREF="#lbBA">BUILT IN COMMANDS</A><DD>
<DL>
<DT><A HREF="#lbBB">QUOTING</A><DD>
<DT><A HREF="#lbBC">COMMAND EXPANSION</A><DD>
<DT><A HREF="#lbBD">THE LIST OF BUILTIN COMMANDS</A><DD>
<DT><A HREF="#lbBE">COMMANDS FOR MENUS</A><DD>
<DT><A HREF="#lbBF">MISCELLANEOUS COMMANDS</A><DD>
<DT><A HREF="#lbBG">COMMANDS AFFECTING WINDOW MOVEMENT AND PLACEMENT</A><DD>
<DT><A HREF="#lbBH">COMMANDS FOR FOCUS AND MOUSE MOVEMENT</A><DD>
<DT><A HREF="#lbBI">COMMANDS CONTROLLING WINDOW STATE</A><DD>
<DT><A HREF="#lbBJ">COMMANDS FOR MOUSE, KEY AND STROKE BINDINGS</A><DD>
<DT><A HREF="#lbBK">THE STYLE COMMAND (CONTROLLING WINDOW STYLES)</A><DD>
<DT><A HREF="#lbBL">OTHER COMMANDS CONTROLLING WINDOW STYLES</A><DD>
<DT><A HREF="#lbBM">COMMANDS CONTROLLING THE VIRTUAL DESKTOP</A><DD>
<DT><A HREF="#lbBN">COMMANDS FOR USER FUNCTIONS AND SHELL COMMANDS</A><DD>
<DT><A HREF="#lbBO">CONDITIONAL COMMANDS</A><DD>
<DT><A HREF="#lbBP">MODULE COMMANDS</A><DD>
<DT><A HREF="#lbBQ">QUIT, RESTART AND SESSION MANAGEMENT COMMANDS</A><DD>
<DT><A HREF="#lbBR">COLOR GRADIENTS</A><DD>
</DL>
<DT><A HREF="#lbBS">ENVIRONMENT</A><DD>
<DT><A HREF="#lbBT">AUTHORS</A><DD>
<DT><A HREF="#lbBU">COPYRIGHT</A><DD>
<DT><A HREF="#lbBV">BUGS</A><DD>
</DL>
<HR>
This document was created by
<A HREF="./">man2html</A>,
using the manual pages.<BR>
Time: 22:13:59 GMT, October 12, 2001
</BODY>
</HTML>
</pre>
<hr>
<!-- This file automatically generated by run_man2html.sh
on Sat Oct 13 00:13:59 IST 2001 -->
</body>
</html>

