<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>The Official FVWM Homepage - Interface and Initialization Mechanism</title>
</head>
<body text="white" bgcolor="black" link="#FFFF88" vlink="#EEDDDD" alink="#FF0000" background="black-stone1.jpg">

<h1 align="center"><font color="#FFC0CB">
The Official FVWM Homepage - Interface and Initialization Mechanism
</font></h1>

<h2><font color="#40E0D0">
Module Invocation
</font></h2>
Modules MUST be launched by Fvwm. Fvwm will first open a pair of pipes
for communication with the module. One pipe is for messages to Fvwm from
the module, and the other is for messages to the module from Fvwm. Each
module has its own pair of pipes. After the pipes are open, Fvwm will fork
and exec the module. Modules not specified with an absolute path must be
located in the ModulePath, as specified in the user's .fvwm2rc file.
Modules can be initiated as fvwm starts up,
or can be launched part way through an X session.

<h2>
<font color="#40E0D0">
Module Arguments</font></h2>

<h3>
Args 0
</h3>
Like any UNIX program, arg 0 is the full pathname of the module. Most modules
acquire this for use in error message, parsing their own configuration
commands, some other possible uses. Arg 0 is related to the optional arg
6 described under "Module Aliases".

<h3>
Args 1 and 2
</h3>
The pipes are open when the module starts execution. The integer file
descriptors are passed to the module as the first and second command
line arguments.

<h3>
Arg 3
</h3>
The third command line argument is a character pointer pointing to the
full path name of the last configuration file that fvwm read in. If there
was no configuration file this arg points to a string containing "none".
In fvwm2 there is little reason for a module to use this argument. It is
there for backward compatibility with old modules and is not guaranteed to
point to anything useful.

<h3>
Arg 4
</h3>
The next command line argument is the application window in whose context
the module was launched. This is 0 if the module is launched without an
application window context.

<h3>
Arg 5
</h3>
The next argument is the context of the window decoration in which the
module was launched. Contexts are listed below:
<pre><font color="#FFFF00">
#define C_NO_CONTEXT     0 - launched during initialization
#define C_WINDOW         1 - launched from an application window
#define C_TITLE          2 - launched from a title bar
#define C_ICON           4 - launched from an icon window
#define C_ROOT           8 - launched from the root window
#define C_FRAME         16 - launched from a corner piece
#define C_SIDEBAR       32 - launched from a side-bar
#define C_L1            64 - launched from left button #1
#define C_L2           128 - launched from left button #2
#define C_L3           256 - launched from left button #3
#define C_L4           512 - launched from left button #4
#define C_L5          1024 - launched from left button #5
#define C_R1          2048 - launched from right button #1
#define C_R2          4096 - launched from right button #2
#define C_R3          8192 - launched from right button #3
#define C_R4         16384 - launched from right button #4
#define C_R5         32768 - launched from right button #5

</font></pre>
Note that no more than one bit will ever be set so a case statement may be
used with the values above.

<h3>
Arg 6 and above
</h3>
A number of user specified command line arguments may be present (optional).
Up to 35 arguments may be passed. For example, in:
<pre><font color="#FFFF00">
        Module  "FvwmIdentify"  FvwmIdentify Hello rob! ``-fg purple''

</font></pre>
we would get argv[6] = ``Hello'', argv[7] = ``rob!'', argv[8] = ``-fg purple''.

<h2>
<font color="#40E0D0">
Module Aliases
</font></h2>
In the original fvwm, if you wanted to run 2 copies of a module, you were
advised to copy or soft-link the module executable to another name. For
example, you might have had to copies of FvwmButtons running. Some of the
modules now accept arg 6 as an Alias of the module name.
<p>
This alias is used in module generated messages, in recognizing configuration
commands, and possibly other uses. FvwmAnimate makes full use of this and
might provide a good model to follow.

<h2><font color="#40E0D0">
Acquiring the read/write pipes
</font></h2>
The following mechanism is recommended to acquire the pipe descriptors:
<pre><font color="#FFFF00">
int fd[2];
void main(int argc, char **argv) {
  if((argc &lt; 6)) {
    fprintf(stderr,
      "%s: Should only be executed by fvwm!\n", argv[0]);
    exit(1);
  }
  fd[0] = atoi(argv[1]);
  fd[1] = atoi(argv[2]);

</font></pre>
The descriptor fd[0] is available for the module to send messages to fvwm,
while the descriptor fd[1] is available to read messages from fvwm. Since
"int fd[2]" is an array, you will often see modules send commands to fvwm
with the construct "SendText(fd,"Command",0);". Of course, they really
mean "SendText(&amp;fd[0],"Command",0);".

<h2><font color="#40E0D0">
Pipe Status
</font></h2>
Special attention is paid to the status of the pipe. If Fvwm gets a read
error on a module-to-fvwm pipe, then it assumes that the module is terminating,
and all communication with the module is terminated. Similarly, if a module
gets a read error on an fvwm-to-module pipe, then it should assume that
fvwm is terminating, and it should gracefully shut down. All modules should
also allow themselves to be shut down via the Delete Window protocol for
X11.

<h2><font color="#40E0D0">
Reading initial configuration information
</font></h2>
In previous implementations, the modules were expected to read and parse
the .fvwmrc file by themselves. This caused some difficulty if a pre-processor
was used on the .fvwmrc file. In fvwm-2.0 and later, fvwm retains the module
command lines (those which start with a ``*''), and passes them to any
module on request. Modules can request the command list by sending a
``Send_ConfigInfo'' command to fvwm. Modules can request configuration
commands to be sent whenever fvwm reads one, even after the module has started
up, see
<a href="mod_m2f_communication.html#M_SENDCONFIG">M_SENDCONFIG</a> in
<a href="mod_m2f_communication.html">Module-to-Fvwm Communication</a>.


<h2><a NAME="colorsets"></a><font color="#40E0D0">
Colorset support
</font></h2>
When a module requests configuration information the configuration commands
sent are preceded by some global configuration lines and a list of colorsets.
In order to use colorsets a module must do the following:
<ul>
<li>make sure <em>-lm</em> is contained in the <em>LDADD</em> variable in
    <em>Makefile.am</em></li>
<li><em>#include "libs/Colorset.h"</em></li>
<li>Call <em>InitPictureCMap()</em> just after <em>XOpenDisplay()</em> to get
    access to the visuals that fvwm uses. Sharing pixmaps will not work unless
    you use the same colormap. This means that the module cannot create a top
    level window with <em>XCreateSimpleWindow()</em>. It must use
    <em>XCreateWindow()</em> and specify the visual as <em>Pvisual</em>, the
    colormap as <em>Pcmap</em>, the depth as <em>Pdepth</em>, the background
    and border pixels must also be specified otherwise they default to
    <em>CopyFromParent</em> which may give an error.</li>
<li>Call <em>AllocColorset(0)</em> to initialize the colorset array.</li>
<li>Set the <em>M_SENDCONFIG</em> bit in the message mask</li>
<li>In the configuration parsing routine look for <em>Colorset</em> and pass
    the line to <em>LoadColorset()</em></li>
<li>Add additional configuration commands such as
    <em>*&lt;module_name>Colorset</em> and parse for them. Colorsets usually
    duplicate static settings of foreground and background so you probably
    want a different colorset option for each background color option.</li>
<li>Add some state to select between using a colorset or a fore/background
    color for an object. The convention is that the last configuration command
    takes precedence.</li>
<li>The module must wait on <em>select()</em> not <em>XNextEvent()</em>. The
    <em>select()</em> must include the fvwm pipe so that messages from fvwm
    can be read. Any <em>M_CONFIG_INFO</em> message must be passed to the
    option parser so that a colorset message can be passed on to
    <em>LoadColorset()</em>. If a colorset that is referenced is changed the
    module must redraw itself. Don't forget that colorset backgrounds have to
    be redrawn when the window is resized.</li>
<li>Accessing colorset <em>N</em> must be done with via <em>Colorset[N]</em>.
    <em>Colorset[]</em> is a global array in <em>libs/Colorset.c</em>.
    It is a good idea to call <em>AllocColorset(N)</em> whenever <em>N</em>
    is changed before trying to access <em>Colorset[n]</em>. The pixels
    available are.
    <ul>
    <li>fg: the foreground pixel</li>
    <li>bg: the background pixel</li>
    <li>hilite: the top and left shadow pixel</li>
    <li>shadow: the bottom and right shadow pixel</li>
    </ul>
<li><em>SetWindowBackground()</em> takes a colorset pointer, generates an
    appropriate background for the window. An additional input enables the
    background to be painted and generates an expose event so the normal
    event handling will repaint the window. If performance is critical the
    module should clear the window itself and call it's repaint routine to
    save a round trip delay.</li>
<li><em>CreateBackgroundPixmap()</em> creates the pixmap used by
    <em>SetWindowBackground()</em> in case you want to paint the background
    manually, you have to check that the colorset contains a valid pixmap first
    though: <em>
    (cset.pixmap&nbsp;&amp;&amp;&nbsp;cset.pixmap&nbsp;!=&nbsp;<a href="#transparency">ParentRelative</a>)
    </em>. Note that if you call this function with a colorset that has no
    pixmap, it returns a pixmap filled with the <em>cset.bg</em> pixel.</li>
<li><em>SetRectangleBackground()</em> draws the background provided in a
    colorset directly into the specified rectangle of a target drawable. Note
    that this creates and deletes a pixmap internally every time it is used.</li>
<li><em>CreateBackgroundPixmap()</em> does not handle the shape mask in the
    colorset at all while <em>SetRectangleBackground()</em> only draws the
    pixels selected in the shape mask. Only <em>SetWindowBackground()</em>
    will shape a window with the shape mask. Thus
    <em>SetWindowBackground()</em> should be used for the application's main
    window while shaping is optional everywhere else.</li>
</ul>

<h2><a NAME="transparency"></a><font color="#40E0D0">
Transparency
</font></h2>
Fvwm and modules can implement a limited form of transparency. It does not
allow the contents of one window to show through another but instead copies the
root window background into the window. X11 makes it impossible to examine the
background color or pixmap of any window so there is no facility to tint
or shade the root window background. Transpency is only supported in colorsets
managed by FvwmTheme and it won't work if you start fvwm with the -visual option.
<p>
In order to support transparency a module must do the following:
<ul>
<li>Detect transparency in a colorset by
    <em>(colorset.pixmap&nbsp;==&nbsp;ParentRelative)</em>.</li>
<li>For any item that may be drawn with a transparent colorset set the window
    background pixmap to <em>ParentRelative</em> and all ancestor windows up to
    the top level window. <em>SetWindowBackground()</em> will do this for
    a single window.</li>
<li>If any window that has been set to ParentRelative is drawn with a
    non-transparent colorset <em>CreateBackgroundPixmap()</em> must be used
    together with <em>XFillRectangle()</em> to paint the background instead
    of <em>SetWindowBackground()</em>.</li>
<li>If the window is likely to be moved or repositions itself the module must
    handle <em>ConfigureNotify</em> events and repaint the whole window
    whenever it is moved. This is because X servers only handle ParentRelative
    on the window that moves (the window manager frame) and don't propogate
    the background down to any descendants of a ParentRelative window. Luckily
    most fvwm modules will only be run by fvwm and there is a reliable method
    of handling this situation (from FvwmWinList)
    <pre><font color="yellow">
    XEvent Event;

    XNextEvent(dpy,&Event);
    switch(Event.type)
    {
      case ConfigureNotify:
        {
          XEvent event;

        /* Opaque moves cause lots of these to be sent which causes flickering
         * It's better to miss out on intermediate steps than to do them all
         * and take too long. Look down the event queue and do the last one */
          while (XCheckTypedWindowEvent(dpy, win, ConfigureNotify, &event))
          {
            /* If send_event is true it means the user has moved the window or
             * winlist has mapped itself, take note of the new position.
             * If it is false it comes from the Xserver and is bogus */
            if (!event.xconfigure.send_event)
              continue;
            Event.xconfigure.x = event.xconfigure.x;
            Event.xconfigure.y = event.xconfigure.y;
            Event.xconfigure.send_event = True;
          }
        }
        if (Event.xconfigure.send_event && (win_x != Event.xconfigure.x
            || win_y != Event.xconfigure.y)) {
          win_x = Event.xconfigure.x;
          win_y = Event.xconfigure.y;
          if (win_bg == ParentRelative)
            RedrawWindow(True, True); /* clears the window, redraw everything */
        }
        break;
    }

    </font></pre></li>
<li>Whenever a colorset change is handled by the configuration parsing routine
    it must be prepared to handle colorsets changing to and from transparent.
    It would be annoying for a user to try a transparent theme and be stuck with
    it until a restart.</li>
</ul>
The user must also arrange for the window manager frame to support transparency
with the <em>``Style&nbsp;module_name&nbsp;ParentalRelativity''</em> command. This
is not the default style as it results in the root window background being
drawn in windows in some circumstances (which are OK for transparent windows).
<p>
I humbly apologize for <em>ParentalRelativity</em>, it's the only thing I could
think of that wouldn't imply something else. Count yourself lucky that the
opposite setting is <em>Opacity</em> and not <em>Obscurity</em> or
<em>ParentalIndifference</em>
</body>
</html>
