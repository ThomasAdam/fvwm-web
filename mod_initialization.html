<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.51 [en] (X11; I; Linux 2.2.5 i686) [Netscape]">
   <title>The Official FVWM Homepage - Interface and Initialization Mechanism</title>
</head>
<body text="#FFFFFF" bgcolor="#000000" link="#FFFF88" vlink="#EEDDDD" alink="#FF0000" background="black-stone1.jpg">

<center>
<h1>
<font color="#FFC0CB">The Official FVWM Homepage - Interface and Initialization
Mechanism</font></h1></center>

<h2>
<font color="#40E0D0">Module Invocation</font></h2>
Modules MUST be launched by Fvwm. Fvwm will first open a pair of pipes
for communication with the module. One pipe is for messages to Fvwm from
the module, and the other is for messages to the module from Fvwm. Each
module has its own pair of pipes. After the pipes are open, Fvwm will fork
and spawn the module. Modules must be located in the ModulePath, as specified
in the user's .fvwm2rc file. Modules can be initiated as fvwm starts up,
or can be launched part way through an X session.
<h2>
<font color="#40E0D0">Module Arguments</font></h2>

<h3>
Args 0</h3>
Like any UNIX program, arg 0 is the full pathname of the module. Most modules
acquire this for use in error message, parsing their own configuration
commands, some other possible uses. Arg 0 is related to the optional arg
6 described under "Module Aliases".
<h3>
Args 1 and 2</h3>
The pipes are open when the module starts execution. The integer file
descriptors are passed to the module as the first and second command
line arguments.
<h3>
Arg 3</h3>
The third command line argument is a character pointer pointing to the
full path name of the last configuration file that fvwm read in. If there
was no configuration file this arg points as to a string containing "none".
In fvwm2, there is little reason for a module to use this argument.
<h3>
Arg 4</h3>
The next command line argument is the application window in whose context
the module was launched. This is 0 if the module is launched without an
application window context.
<h3>
Arg 5</h3>
The next argument is the context of the window decoration in which the
module was launched. Contexts are listed below:
<pre><font color="#FFFF00">#define C_NO_CONTEXT&nbsp;&nbsp;&nbsp;&nbsp; 0 - launched during initialization
#define C_WINDOW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 - launched from an application window
#define C_TITLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 - launched from a title bar
#define C_ICON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 - launched from an icon window
#define C_ROOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 - launched from the root window
#define C_FRAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16 - launched from a corner piece
#define C_SIDEBAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32 - launched from a side-bar
#define C_L1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64 - launched from left button #1
#define C_L2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 128 - launched from left button #2
#define C_L3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 256 - launched from left button #3
#define C_L4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 512 - launched from left button #4
#define C_L5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1024 - launched from left button #5
#define C_R1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2048 - launched from right button #1
#define C_R2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096 - launched from right button #2
#define C_R3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8192 - launched from right button #3
#define C_R4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16384 - launched from right button #4
#define C_R5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32768 - launched from right button #5</font></pre>

<h3>
Arg 6 and above</h3>
A number of user specified command line arguments may be present (optional).
Up to 35 arguments may be passed. For example, in:
<pre><font color="#FFFF00">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Module&nbsp; "FvwmIdentify"&nbsp; FvwmIdentify Hello rob! ``-fg purple''</font></pre>
we would get argv[6] = ``Hello'', argv[7] = ``rob!'', argv[8] = ``-fg purple''.
<h2>
<font color="#40E0D0">Module Aliases</font></h2>
In the original fvwm, if you wanted to run 2 copies of a module, you where
advised to copy or soft-link the module executable to another name. For
example, you might have had to copies of FvwmButtons running. Some of the
modules now accept arg 6 as an Alias of the module name.
<p>This alias is used in module generated messages, in recognizing configuration
commands, and possibly other uses. FvwmAnimate makes full use of this and
might provide a good model to follow.
<h2>
<font color="#40E0D0">Acquiring the read/write pipes</font></h2>
The following mechanism is recommended to acquire the pipe descriptors:
<pre><font color="#FFFF00">int fd[2];
void main(int argc, char **argv) {
&nbsp; if((argc &lt; 6)) {
&nbsp;&nbsp;&nbsp; fprintf(stderr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "%s: Should only be executed by fvwm!\n", argv[0]);
&nbsp;&nbsp;&nbsp; exit(1);
&nbsp; }
&nbsp; fd[0] = atoi(argv[1]);
&nbsp; fd[1] = atoi(argv[2]);</font></pre>
The descriptor fd[0] is available for the module to send messages to fvwm,
while the descriptor fd[1] is available to read messages from fvwm. Since
"int fd[2]" is an array, you will often see modules send commands to fvwm
with the construct "SendText(fd,"Command",0);". Of course, they really
mean "SendText(&amp;fd[0],"Command",0);".
<h2>
<font color="#40E0D0">Pipe Status</font></h2>
Special attention is paid to the status of the pipe. If Fvwm gets a read
error on a module-to-fvwm pipe, then it assumes that the module is terminating,
and all communication with the module is terminated. Similarly, if a module
gets a read error on an fvwm-to-module pipe, then it should assume that
fvwm is terminating, and it should gracefully shut down. All modules should
also allow themselves to be shut down via the Delete Window protocol for
X-11.
<h2>
<font color="#40E0D0">Reading initial configuration information</font></h2>
In previous implementations, the modules were expected to read and parse
the .fvwmrc file by themselves. This caused some difficulty if a pre-processor
was used on the .fvwmrc file. In fvwm-2.0 and later, fvwm retains the module
command lines (those which start with a ``*''), and passes them to any
module on request. Modules can request the command list by sending a
``Send_ConfigInfo''
command to fvwm. Modules can request configuration commands interactively,
see M_SENDCONFIG in
<a href="mod_f2m_communication.html">Fvwm-to-Module
Communication</a> and
<a href="mod_m2f_communication.html">Module-to-Fvwm
Communication</a>.&nbsp;
<hr><a NAME="colorsets"></a>
<h2>
Colorset support</h2>
When a module requests configuration information the configuration commands
sent are preceded by some global configuration lines and a list of colorsets.
In order to use colorsets a module must do the following:
<ul>
<li>
make sure <i>-lm</i> is contained in the LDADD variable in Makefile.am</li>

<li>
<i>#include "libs/Colorset.h"</i></li>

<li>
Call InitPictureCMap() just after XOpenDisplay() to get access to the visuals
that fvwm uses. Sharing pixmaps will not work unless you use the same colormap.
This means that the module cannot create a top level window with
XCreateSimpleWindow().
It must use XCreateWindow() and specify the visual as <i>Pvisual</i>, the
colormap as <i>Pcmap</i>, the depth as <i>Pdepth</i>, the background and
border pixels must also be specified otherwise they default to
<i>CopyFromParent</i> which may give an error.</li>

<li>
Call AllocColorset(0) to initialize the colorset array.</li>

<li>
Set the M_SENDCONFIG bit in the message mask</li>

<li>
In the configuration parsing routine look for Colorset and pass the line
to LoadColorset()</li>

<li>
Add additional configuration commands such as *Fvwm&lt;module>Colorset
and parse for them. Colorsets usually duplicate static settings of foreground
and background so you proabaly want a different colorset option for each
background color option.</li>

<li>
Add some state to select between using a colorset or a fore/background
color for an object. The convention is that the last configuration command
takes precedence.</li>

<li>
The module must wait on select() not XNextEvent(). The select() must include
the fvwm pipe so that messages from fvwm can be read. Any M_CONFIG_INFO
message must be passed to the option parser so that a colorset message
can be passed on to LoadColorset(). If a colorset that is referenced is
changed the module must redraw itself. Don't forget that colorset backgrounds
have to be redrawn when the window is resized.</li>

<li>
Accessing colorset N must be done with via <i>Colorset[</i>N<i> % nColorsets]</i>.
Colorset[] and nColorsets are globals maintained libs/Colorset.c. The pixels
available are</li>

<ul>
<li>
fg: the foreground pixel</li>

<li>
bg: the background pixel</li>

<li>
hilite: the top and left shadow pixel</li>

<li>
relief: the bottom and right shadow pixel</li>
</ul>

<li>
SetWindowBackground() takes a colorset pointer and generates an appropriate
background. It generates an expose event.</li>

<li>
CreateBackgroundPixmap() creates the pixmap used by SetWindowBackground()
in case you want to paint the background manually, you have to check that
the colorset contains a pixmap first though (cset.pixmap != None). Note
that if you call this function with a colorset that has no pixmap, it returns
a pixmap filled with the cset.pg pixel value.</li>

<li>
SetRectangleBackground() draws the background provided in a colorset directly
into the specified rectangle of a target drawable. Note that this still
creates and deletes a pixmap internally.</li>

<li>
CreateBackgroundPixmap() does not handle the shape mask in the colorset
at all while SetRectangleBackground() just doesn't draw the pixels not
selected in the shape mask. Only SetWindowBackground() will shape a window
with the shape mask. Thus, SetWindowBackground() should be used for the
application's main window while shaping is optional everywhere else.</li>
</ul>

</body>
</html>
